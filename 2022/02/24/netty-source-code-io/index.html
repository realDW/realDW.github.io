

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/blogFavicon.png">
  <link rel="icon" href="/img/blogFavicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  
    <meta name="description" content="">
  
  <meta name="author" content="Daiwei">
  <meta name="keywords" content="">
  
  <title>Netty流程剖析 — I/O就绪操作源码剖析 - Daiwei‘s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.8","typing":{"enable":true,"typeSpeed":100,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Daiwei's blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://raw.githubusercontent.com/realDaiwei/image/master/ricardo-gomez-angel--4F1rjgDWIk-unsplash.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Netty流程剖析 — I/O就绪操作源码剖析">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-02-24 22:00" pubdate>
        2022年2月24日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      16.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      74
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Netty流程剖析 — I/O就绪操作源码剖析</h1>
            
            <div class="markdown-body">
              <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面一篇我们梳理了Netty服务的启动流程，这一小节，我们开始分析I/O就绪操作，I/O就绪操作大致可以划分为三个大的部分，第一个部分是OP_ACCEPT操作，这个部分我们接着上一小节继续分析，当服务启动之后，客户端向服务端发起连接，服务端是怎么如果处理连接，并且设置监听OP_READ。第二个部分也就是OP_READ操作的上半部分，随着客户端通过建立的连接通道发送数据到服务端，服务端又是怎么接受数据并进行层层处理。第三个部分是OP_READ的下半部分，也就是最后服务端通过write方法将响应的消息发送到客户端。完成这几个部分的代码剖析也就基本完成了，也就基本完成了Netty的NIO热点代码分析。在阅读这几个部分的源码，我们还会看到前面我们剖析的几个核心组件。在上一小节，我们加深了对eventLoop和channel的理解，这一小节我们看看channel和bytebuf之间配合进行数据读写。</p>
<h1 id="I-O就绪事件处理之OP-ACCEPT"><a href="#I-O就绪事件处理之OP-ACCEPT" class="headerlink" title="I/O就绪事件处理之OP_ACCEPT"></a>I/O就绪事件处理之OP_ACCEPT</h1><p>通过前面的学习，深入剖析了Netty的启动过程，以及Netty采用辅助类ServerBootstrap启动，通过eventloop线程，依次开启initAndRegister开启Selector，并将ServerSocketChannel注册到Selector上，绑定端口监听，最后设置监听OP_ACCEPT事件。</p>
<h2 id="OP-ACCEPT处理就绪概述"><a href="#OP-ACCEPT处理就绪概述" class="headerlink" title="OP_ACCEPT处理就绪概述"></a>OP_ACCEPT处理就绪概述</h2><p>在这个部分的开始我们先看<code>OP_ACCEPT</code>事件处理的时序图。</p>
<p><img src="https://raw.githubusercontent.com/realDaiwei/image/master/20220216224154.png" srcset="/img/loading.gif"></p>
<p>从上面这个时序图我们前面启动逻辑很相似，通过调用pipeline中的方法来实现的。首先是通过<code>processSelectedKey</code>解析出这是一个<code>OP_ACCEPT</code>事件，调用<code>unsafe.read</code>方法，真正调用的是pipeline.channelRead方法，channelRead是<code>inboundHandler</code>的方法。在调用到serverBootstrapAcceptor时候，将作为消息msg传递的<code>NioSocketChannel</code>绑定到childGroup上eventLoop上并完成channelRegister和channelActive方法的调用。<code>NioSocketChannel</code>在read方法中创建<code>NioSocketChannel</code>监听<code>OP_READ</code>操作。</p>
<p>主要操作分为下面三步：</p>
<ol>
<li><p>当eventLoop中的<strong>多路复用器Selector轮询到就绪的SelectionKey时，判断Key的readOps类型是否是OP_ACCEPT</strong>，如果是，那么Key的<strong>attachment就是NioServerSocketChannel</strong>，先获取SelectionKey的attachment对象，再触发此对象的辅助类Unsafe的实现类NioMessageUnsafe的read()方法进行处理。</p>
</li>
<li><p>在NioMessageUnsafe的<code>read()</code>方法中会执行<code>doReadMessages</code>。真正调用的是<code>AbstractNioMessageChannel</code>的子类<code>NioServerSocketChannel</code>的<code>doReadMessage()</code>方法。此方法最终调用<code>ServerSocketChannel</code>的<code>accept()</code>方法，以获取接入的<code>SocketChannel</code>。在获取到SocketChannel后，构建<code>NioSocketChannel</code>，并把构造好的NioSocketChannel<strong>作为消息msg</strong>传送给Handler（<code>ServerBootstrapAcceptor</code>)，触发pipeline的fireChannelRead，进而触发read事件。最后会调用Handler的channelRead()方法。</p>
</li>
<li><p>在ServerBootstrapAcceptor的channelRead()方法中，把<strong>NioSocketChannel注册到Worker线程上，同时绑定channel的handler链。</strong></p>
</li>
</ol>
<h2 id="OP-ACCEPT事件处理源码剖析"><a href="#OP-ACCEPT事件处理源码剖析" class="headerlink" title="OP_ACCEPT事件处理源码剖析"></a>OP_ACCEPT事件处理源码剖析</h2><p>上面的部分我们简单的梳理了OP_ACCEPT事件的处理流程，但是这个过程如果不结合源码一起分析的话还是有一种云里雾里的感觉。所以我们结合源码深入分析OP_ACCEPT事件处理的逻辑，从代码层面深入剖析netty如何完成上面的三步操作。</p>
<h3 id="熟悉的pocessSelectedKeys"><a href="#熟悉的pocessSelectedKeys" class="headerlink" title="熟悉的pocessSelectedKeys"></a>熟悉的pocessSelectedKeys</h3><p>在nioEventLoop的源码分析中，我们提到如果有当Selector轮训到就绪的SelectionKey时，会从nioEventLoop的run方法中的<code>select(curDeadlineNanos)</code>返回，返回的值是当前就绪key的个数，随后执行调用<code>processSelectedKeys()</code>方法，处理就绪的SelectionKey，我们的源码剖析也就从这里开始。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.channel.nio.NioEventLoop#processSelectedKeys</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processSelectedKeys</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//判断优化后的selectedKeys是否为空</span><br>    <span class="hljs-keyword">if</span> (selectedKeys != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 优化处理</span><br>        processSelectedKeysOptimized();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 原始处理</span><br>        processSelectedKeysPlain(selector.selectedKeys());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.nio.NioEventLoop#processSelectedKeysOptimized</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processSelectedKeysOptimized</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; selectedKeys.size; ++i) &#123;<br>        <span class="hljs-keyword">final</span> SelectionKey k = selectedKeys.keys[i];<br>        <span class="hljs-comment">// null out entry in the array to allow to have it GC&#x27;ed once the Channel close</span><br>        <span class="hljs-comment">// See https://github.com/netty/netty/issues/2363</span><br>        <span class="hljs-comment">// 将selectedKeys.keys[i]设置为null,并被JVM快速回收。</span><br>        selectedKeys.keys[i] = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">final</span> Object a = k.attachment();<br><br>        <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> AbstractNioChannel) &#123;<br>            <span class="hljs-comment">//根据Key的就绪事件触发对应的事件方法。</span><br>            processSelectedKey(k, (AbstractNioChannel) a);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;<br>            processSelectedKey(k, task);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (needsToSelectAgain) &#123;<br>            <span class="hljs-comment">// null out entries in the array to allow to have it GC&#x27;ed once the Channel close</span><br>            <span class="hljs-comment">// See https://github.com/netty/netty/issues/2363</span><br>            selectedKeys.reset(i + <span class="hljs-number">1</span>);<br><br>            selectAgain();<br>            i = -<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.nio.NioEventLoop#processSelectedKey(java.nio.channels.SelectionKey, io.netty.channel.nio.AbstractNioChannel)</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processSelectedKey</span><span class="hljs-params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();<br>    <span class="hljs-comment">//如果当前selectionKey无效，直接关闭unsafe。</span><br>    <span class="hljs-keyword">if</span> (!k.isValid()) &#123;<br>        <span class="hljs-keyword">final</span> EventLoop eventLoop;<br>        <span class="hljs-keyword">try</span> &#123;<br>            eventLoop = ch.eventLoop();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable ignored) &#123;<br>            <span class="hljs-comment">// If the channel implementation throws an exception because there is no event loop, we ignore this</span><br>            <span class="hljs-comment">// because we are only trying to determine if ch is registered to this event loop and thus has authority</span><br>            <span class="hljs-comment">// to close ch.</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// Only close ch if ch is still registered to this EventLoop. ch could have deregistered from the event loop</span><br>        <span class="hljs-comment">// and thus the SelectionKey could be cancelled as part of the deregistration process, but the channel is</span><br>        <span class="hljs-comment">// still healthy and should not be closed.</span><br>        <span class="hljs-comment">// See https://github.com/netty/netty/issues/5125</span><br>        <span class="hljs-keyword">if</span> (eventLoop == <span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-comment">// close the channel if the key is not valid anymore</span><br>            unsafe.close(unsafe.voidPromise());<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">int</span> readyOps = k.readyOps();<br>        <span class="hljs-comment">// We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise</span><br>        <span class="hljs-comment">// the NIO JDK channel implementation may throw a NotYetConnectedException.</span><br>        <span class="hljs-comment">// 处理连接事件</span><br>        <span class="hljs-keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking</span><br>            <span class="hljs-comment">// See https://github.com/netty/netty/issues/924</span><br>            <span class="hljs-keyword">int</span> ops = k.interestOps();<br>            ops &amp;= ~SelectionKey.OP_CONNECT;<br>            k.interestOps(ops);<br><br>            unsafe.finishConnect();<br>        &#125;<br><br>        <span class="hljs-comment">// 处理写事件</span><br>        <span class="hljs-comment">// Process OP_WRITE first as we may be able to write some queued buffers and so free memory.</span><br>        <span class="hljs-keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write</span><br>            ch.unsafe().forceFlush();<br>        &#125;<br><br>        <span class="hljs-comment">// 处理读事件和ACCEPT事件</span><br>        <span class="hljs-comment">// Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead</span><br>        <span class="hljs-comment">// to a spin loop</span><br>        <span class="hljs-keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="hljs-number">0</span> || readyOps == <span class="hljs-number">0</span>) &#123;<br>            unsafe.read();<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException ignored) &#123;<br>        unsafe.close(unsafe.voidPromise());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面这一段代码的剖析，我们在NioEventLoop中分析过，这里就简单提一下。我们要关注<code>OP_ACCEPT</code>的就绪事件，所以在<code>processSelectedKey(SelectionKey k, AbstractNioChannel ch)</code>方法中的分支判断中会调用<code>unsafe.read()</code>方法。</p>
<h3 id="AbstractNioMessageChannel中read方法的实现"><a href="#AbstractNioMessageChannel中read方法的实现" class="headerlink" title="AbstractNioMessageChannel中read方法的实现"></a>AbstractNioMessageChannel中read方法的实现</h3><p>这里有一个问题，是关于此时方法入参<code>AbstractNioChannel ch</code>的具体实现类，abstractNioChannel有两个子抽象类，<strong>一个是AbstractNioMessageChannel另一个是AbstractNioByteChannel，AbstractNioMessageChannel是NioServerSocketChannel的父类主要处理连接操作，AbstractNioByteChannel是NioSocketChannel的父类主要处理数据的读写。</strong>我们当前关注<code>OP_ACCEPT</code>的就绪事件，所以 方法传递进来的<code>AbstractNioChannel</code>为<code>AbstractNioMessageChannel</code>实例，所以unsafe.read()方法的具体方法就是<strong>AbstractNioMessageChannel#unsafe</strong>的read方法，也就是下面这段代码（这段代码我们在核心组件—Channel中也有详细的分析）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">assert</span> <span class="hljs-title">eventLoop</span><span class="hljs-params">()</span>.<span class="hljs-title">inEventLoop</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">final</span> ChannelConfig config = config();<br>    <span class="hljs-comment">// 当前的实例对象是NioServerSocketChannel，也就是当前eventLoop还是bossGroup的eventLoop</span><br>    <span class="hljs-keyword">final</span> ChannelPipeline pipeline = pipeline();<br>    <span class="hljs-keyword">final</span> RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();<br>    allocHandle.reset(config);<br><br>    <span class="hljs-keyword">boolean</span> closed = <span class="hljs-keyword">false</span>;<br>    Throwable exception = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-comment">// 从channel中读出消息，具体实现将accpect的channel包成NioSocketChannel</span><br>                <span class="hljs-keyword">int</span> localRead = doReadMessages(readBuf);<br>                <span class="hljs-comment">// 无数据直接跳出循环</span><br>                <span class="hljs-keyword">if</span> (localRead == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 链路关闭跳出循环</span><br>                <span class="hljs-keyword">if</span> (localRead &lt; <span class="hljs-number">0</span>) &#123;<br>                    closed = <span class="hljs-keyword">true</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>				<span class="hljs-comment">// 记录成功读的次数</span><br>                allocHandle.incMessagesRead(localRead);<br>                <span class="hljs-comment">// 默认读次数不超过16次</span><br>            &#125; <span class="hljs-keyword">while</span> (continueReading(allocHandle));<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            exception = t;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> size = readBuf.size();<br>        <span class="hljs-comment">// 循环处理数据</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i ++) &#123;<br>            readPending = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-comment">// 将创建的nioSockChannel作为消息(msg)调用NioServerSocketChannel#pipeline的fireChannelRead方法。</span><br>            pipeline.fireChannelRead(readBuf.get(i));<br>        &#125;<br>        <span class="hljs-comment">// 读完成，清空readBuffer</span><br>        readBuf.clear();<br>        allocHandle.readComplete();<br>        <span class="hljs-comment">// 调用pipeline的readComplete方法。</span><br>        pipeline.fireChannelReadComplete();<br><br>        <span class="hljs-keyword">if</span> (exception != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 处理异常关闭</span><br>            closed = closeOnReadError(exception);<br>			<span class="hljs-comment">// 调用pipeline的exceptionCaught方法</span><br>            pipeline.fireExceptionCaught(exception);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (closed) &#123;<br>            <span class="hljs-comment">// 正常关闭。</span><br>            inputShutdown = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">if</span> (isOpen()) &#123;<br>                close(voidPromise());<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// Check if there is a readPending which was not processed yet.</span><br>        <span class="hljs-comment">// This could be for two reasons:</span><br>        <span class="hljs-comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method</span><br>        <span class="hljs-comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// See https://github.com/netty/netty/issues/2254</span><br>        <span class="hljs-keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;<br>            removeReadOp();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.socket.nio.NioServerSocketChannel#doReadMessages</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doReadMessages</span><span class="hljs-params">(List&lt;Object&gt; buf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">// 从acceptor中获取socketChannel</span><br>    SocketChannel ch = SocketUtils.accept(javaChannel());<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (ch != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 将socketChannel包装成NioSocketChannel并放入到buf中</span><br>            buf.add(<span class="hljs-keyword">new</span> NioSocketChannel(<span class="hljs-keyword">this</span>, ch));<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        logger.warn(<span class="hljs-string">&quot;Failed to create a new channel from an accepted socket.&quot;</span>, t);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            ch.close();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t2) &#123;<br>            logger.warn(<span class="hljs-string">&quot;Failed to close a socket.&quot;</span>, t2);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上的部分源码是<code>unsafe.read()</code>方法的具体调用，这里需要注意的第一个点是channel具体实现类是<code>AbstractNioMessageChannel</code>的子类，即<code>NioServerSocketChannel</code>，这<strong>和我们OP_READ就绪事件处理的实现类不是同一个类</strong>。这段方法的主要逻辑是将accept的channel包装成NioSocketChannel，并且作为参数调用ServerNioSocketChannel的pipelineHander的channelRead方法。也就是ServerChannelhandler即在服务启动时添加<code>LoggingHandler</code>和<code>ServerBootstrapAcceptor</code>加入到NioSocketChannelPipeline中。</p>
<h3 id="NioSocketChannel的注册"><a href="#NioSocketChannel的注册" class="headerlink" title="NioSocketChannel的注册"></a>NioSocketChannel的注册</h3><p><code> pipeline.fireChannelRead()</code>是inbound的方法，所以fireChannelRead方法会从沿着handler链<strong>从前往后</strong>依次调用handler的ChannelRead方法，同时<strong>NioSocketChannel将作为入参</strong>传递。以下是<code>LoggingHandler</code>和<code>ServerBootstrapAcceptor</code>的channelRead方法的源码剖析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.handler.logging.LoggingHandler#channelRead</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">if</span> (logger.isEnabled(internalLevel)) &#123;<br>        <span class="hljs-comment">// 将msg即nioSocketChannel对象日志输出</span><br>        logger.log(internalLevel, format(ctx, <span class="hljs-string">&quot;READ&quot;</span>, msg));<br>    &#125;<br>    <span class="hljs-comment">// 调用下一个handler的channelRead方法，即ServerBootstrapAcceptor#channelRead</span><br>    ctx.fireChannelRead(msg);<br>&#125;<br><br><span class="hljs-comment">//io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#channelRead</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;<br>    <span class="hljs-comment">// 这个方法里面就有一些关键的东西了</span><br>    <span class="hljs-keyword">final</span> Channel child = (Channel) msg;<br>	<span class="hljs-comment">// 将我们在ServerBootstrap创建阶段childHandler加入到nioSocketChannel的pipeline中。</span><br>    child.pipeline().addLast(childHandler);<br>	<br>    setChannelOptions(child, childOptions, logger);<br>    setAttributes(child, childAttrs);<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 将childChannel注册到childGroup也就是workerEventLoopGroup上</span><br>        childGroup.register(child).addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                <span class="hljs-keyword">if</span> (!future.isSuccess()) &#123;<br>                    forceClose(child, future.cause());<br>                &#125;<br>            &#125;<br>        &#125;);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        forceClose(child, t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过<code>ServerBootstrapAcceptor#read</code>方法调用，netty完成<strong>当前nioSocketChannel的初始化并将NioSocketChannel注册到workGroup上</strong>。这个过程可以理解为NioSocketChannel也就是我们实际执行读写的channel的“initAndRegister”。整个注册register的过程和前面NioServerSocketChannel的过程是类似的，复用的也是同一套register0代码。接下来，我们从NioSocketChannel的角度再来分析下这段代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// io.netty.channel.AbstractChannel.AbstractUnsafe#register</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(EventLoop eventLoop, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;<br>    ObjectUtil.checkNotNull(eventLoop, <span class="hljs-string">&quot;eventLoop&quot;</span>);<br>    <span class="hljs-keyword">if</span> (isRegistered()) &#123;<br>        promise.setFailure(<span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;registered to an event loop already&quot;</span>));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!isCompatible(eventLoop)) &#123;<br>        promise.setFailure(<br>            <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;incompatible event loop type: &quot;</span> + eventLoop.getClass().getName()));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 此时的eventLoop则是workerGroup的eventLoop</span><br>    AbstractChannel.<span class="hljs-keyword">this</span>.eventLoop = eventLoop;<br><br>    <span class="hljs-comment">// 当前调用的线程是bossGroup的线程，因此这里走false分支</span><br>    <span class="hljs-keyword">if</span> (eventLoop.inEventLoop()) &#123;<br>        register0(promise);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 启动workerGroup线程继续完车register0的逻辑</span><br>            eventLoop.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    register0(promise);<br>                &#125;<br>            &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            logger.warn(<br>                <span class="hljs-string">&quot;Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;&quot;</span>,<br>                AbstractChannel.<span class="hljs-keyword">this</span>, t);<br>            closeForcibly();<br>            closeFuture.setClosed();<br>            safeSetFailure(promise, t);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.AbstractChannel.AbstractUnsafe#register0</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register0</span><span class="hljs-params">(ChannelPromise promise)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// check if the channel is still open as it could be closed in the mean time when the register</span><br>        <span class="hljs-comment">// call was outside of the eventLoop</span><br>        <span class="hljs-keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">boolean</span> firstRegistration = neverRegistered;<br>        <span class="hljs-comment">// 将channel注册到eventLoop的selector上设置selectionKey</span><br>        doRegister();<br>        neverRegistered = <span class="hljs-keyword">false</span>;<br>        registered = <span class="hljs-keyword">true</span>;<br><br>        <span class="hljs-comment">// Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the</span><br>        <span class="hljs-comment">// user may already fire events through the pipeline in the ChannelFutureListener.</span><br>        <span class="hljs-comment">// 将childHandler加入到nioSocketChannel中</span><br>        pipeline.invokeHandlerAddedIfNeeded();<br><br>        <span class="hljs-comment">// promise设置成功</span><br>        safeSetSuccess(promise);<br>        <span class="hljs-comment">// 调用pipelineChannelHandler的channelRegister方法。</span><br>        pipeline.fireChannelRegistered();<br>        <span class="hljs-comment">// Only fire a channelActive if the channel has never been registered. This prevents firing</span><br>        <span class="hljs-comment">// multiple channel actives if the channel is deregistered and re-registered.</span><br>        <span class="hljs-comment">// 当前chennal已经被激活</span><br>        <span class="hljs-keyword">if</span> (isActive()) &#123;<br>            <span class="hljs-keyword">if</span> (firstRegistration) &#123;<br>                调用pipelineChannelHandler的channelActive方法<br>                pipeline.fireChannelActive();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (config().isAutoRead()) &#123;<br>                <span class="hljs-comment">// This channel was registered before and autoRead() is set. This means we need to begin read</span><br>                <span class="hljs-comment">// again so that we process inbound data.</span><br>                <span class="hljs-comment">//</span><br>                <span class="hljs-comment">// See https://github.com/netty/netty/issues/4805</span><br>                beginRead();<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-comment">// Close the channel directly to avoid FD leak.</span><br>        closeForcibly();<br>        closeFuture.setClosed();<br>        safeSetFailure(promise, t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这一段的逻辑大体上可以分为四个部分分别是<strong>将channel注册到selector上</strong>，<strong>初始化pipeline（将channelHandler加入到pipeline中）</strong>，<strong>调用pipelineChanelHandler的channelRegister方法</strong>和<strong>调用pipelineChannelHandler的channelActive方法</strong>。这段逻辑和服务启动时注册即NioServerSocketChannel调用register的逻辑共用同一段代码。但是在服务启动阶段，channel并没有被激活而在此时的调用中，channel已经被激活所以直接调用channelActive，开启对OP_READ事件的监听。</p>
<h3 id="OP-ACCEPT就绪操作逻辑小结"><a href="#OP-ACCEPT就绪操作逻辑小结" class="headerlink" title="OP_ACCEPT就绪操作逻辑小结"></a>OP_ACCEPT就绪操作逻辑小结</h3><p>这个部分是我自己的一些看法和见解，也是我在看源码之后对OP_ACCEPT就绪操作的一些新的认识。在没有深入看OP_ACCEPT部分的源码之前，对于OP_ACCEPT就绪操作不是很理解，Netty的主从Reactor结构的确是可以很大程度上提高处理的速度，但是代码层面到底做了些什么操作是不清楚的。我一直以为在每次进行读写的时候都会初始化childChannel，也就是NioSocketChannel。因为每次debug的时候都会执行serveBootstrap中childHandler中的初始化逻辑。但是现在看来这些理解都是错误的。OP_ACCEPT是BossGroup的eventLoop来操作的，在这个过程中处理的逻辑很简单就是<strong>拿到socketChannel包装成NioSocketChannel，然后通过ServerBootstrapAcceptor将channel注册到workerGroup的eventLoop上的selector上监听OP_READ就绪事件</strong>。也就是<strong>后续的读写操作都会直接和workerGroup的eventLoop进行交互</strong>，完成后续操作。现在在看下面这个图是不是更清楚了。</p>
<p><img src="https://raw.githubusercontent.com/realDaiwei/image/master/20210921223233.png" srcset="/img/loading.gif"></p>
<blockquote>
<p>拿一个餐厅服务员招待顾客举例子，一个食客来到一家餐厅就餐，一开始会有一个餐厅经理老王在外面叫号，当老王叫到你的号之后，他会给你安排好座位和餐具等，并把你交给另外一名服务员小二，告诉你后续的点餐上餐投诉反馈等需求你直接和服务员小二沟通就好了。</p>
<p>这个过程其实就是Netty的OP_ACCEPT的操作过程。其中餐厅经理老王就是bossGroup线程组中的eventLoop，当连接来了之后，他会初始化nioSocketChannel，当前socket注册到workerGroup上，并监听OP_READ。后续的读写操作，直接由WorkerGroup的eventLoop线程进行处理，而bossGroup的eventLoop则继续处理下一个链接，这样极大的提高了netty处理连接的处理速度。</p>
</blockquote>
<h3 id="一个小细节-interestOps与attachment"><a href="#一个小细节-interestOps与attachment" class="headerlink" title="一个小细节- interestOps与attachment"></a>一个小细节- interestOps与attachment</h3><p>在前面的代码分析过程中，我有一个点很迷惑，在channel注册到Selector上时候，设置的ops也就是<code>interestOps</code>是0，不论是netty服务启动时NioServerSocketChannel的register调用，还是NioSocketChannel的register的调用传入的<code>interestOps</code>都是0，也就是下面这段代码。这是不是不对啊。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// io.netty.channel.nio.AbstractNioChannel#doRegister</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doRegister</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">boolean</span> selected = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException e) &#123;<br>            <span class="hljs-keyword">if</span> (!selected) &#123;<br>                <span class="hljs-comment">// Force the Selector to select now as the &quot;canceled&quot; SelectionKey may still be</span><br>                <span class="hljs-comment">// cached and not removed because no Select.select(..) operation was called yet.</span><br>                eventLoop().selectNow();<br>                selected = <span class="hljs-keyword">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// We forced a select operation on the selector before but the SelectionKey is still cached</span><br>                <span class="hljs-comment">// for whatever reason. JDK bug ?</span><br>                <span class="hljs-keyword">throw</span> e;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>后来我发现，在调用register方法还有传了一个att也就是this作为入参，也就是我们包装的abstractNioChannel。当有操作就绪的时候，代码判断的不是注册时的<code>interestOps</code>，我们注册的时候本来传入的就都是0，也无法判断。最后在开启读操作中，设置当前selectionKey的<code>interestOps</code>的值和NioServerSocketChannel中的<code>readInterestOp</code>一致。这样也就开启了读。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.channel.nio.AbstractNioChannel#doBeginRead</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBeginRead</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">// Channel.read() or ChannelHandlerContext.read() was called</span><br>    <span class="hljs-keyword">final</span> SelectionKey selectionKey = <span class="hljs-keyword">this</span>.selectionKey;<br>    <span class="hljs-keyword">if</span> (!selectionKey.isValid()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    readPending = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> interestOps = selectionKey.interestOps();<br>    <span class="hljs-keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="hljs-number">0</span>) &#123;<br>        selectionKey.interestOps(interestOps | readInterestOp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我还有一个疑惑的点就是在processKey的过程中，是如何确定对应的channel的呢？也就是这个方法签名中<code>processSelectedKey(SelectionKey k, AbstractNioChannel ch)</code>的ch是怎么传递过来的？通过源码我看到是通过attachment的方式实现，在register阶段，<strong>将netty包装的abstractNioChannel作为attachment进行注册</strong>，也就是这个入参中的this<code>register(eventLoop().unwrappedSelector(), 0, this)</code>这样在下次命中当前selectionKey就可以直接拿到对应的channel了。Selector的结构如下图：</p>
<p><img src="https://raw.githubusercontent.com/realDaiwei/image/master/20220216223937.png" srcset="/img/loading.gif"></p>
<h1 id="I-O就绪事件处之OP-READ（—）"><a href="#I-O就绪事件处之OP-READ（—）" class="headerlink" title="I/O就绪事件处之OP_READ（—）"></a>I/O就绪事件处之OP_READ（—）</h1><p>前面我们梳理了就绪事件OP_ACCEPT操作，了解了bossGroup线程组中NioEventLoop线程处理Socket链路接入的整个过程。在分析完链路接入部分的逻辑，我们来分析I/O事件读写的逻辑。当然读写的逻辑也是可以分开的，从workerGroup的eventLoop处理processSelectedKeys的OP_READ事件开始，到我们自定义逻辑的inBoundHandler的channelRread方法结束作为我们OP_READ的第一部分。从EchoServerHandler中的channelRead方法开始到将数据从server端把数据发送出去作为第二个部分。我们先来探究第一个部分，一起来看看workerGroup线程组NioEventLoop线程是如何读取Socket链路传过来的数据。</p>
<h2 id="OP-READ事件读操作概述"><a href="#OP-READ事件读操作概述" class="headerlink" title="OP_READ事件读操作概述"></a>OP_READ事件读操作概述</h2><p>和前面OP_ACCEPT就绪事件的剖析一样，先来看看读数据这部分操作的时序图。</p>
<p><img src="https://raw.githubusercontent.com/realDaiwei/image/master/20220226145651.png" srcset="/img/loading.gif"></p>
<p>这个时序图和OP_ACCEPT的非常相似。因为都是基于Netty的模型的pipeline的处理器链结构。通过fireChannelXXX的方式去调用下一个Handler，每个handler处理的对应的一些逻辑。其中在整个处理过程中传递方法<strong>参数msg是从channel中读到的数据</strong>。在读写操作时，我们都会加上一些自定义的编解码器。在Netty中，我们解码需要继承<code>MessageToByteEncoder</code>，然后调用<code>decode</code>方法执行不同的子类方法来实现具体的编解码逻辑。在下面的源码剖析部分，我们也会重点看看这部分的源码。</p>
<h2 id="OP-READ事件读操作源码剖析"><a href="#OP-READ事件读操作源码剖析" class="headerlink" title="OP_READ事件读操作源码剖析"></a>OP_READ事件读操作源码剖析</h2><p>这个部分我们开始分析OP_READ事件读部分的源码。从上面的processSelectedKeysh中发现，<code>OP_READ</code>和<code>OP_ACCEPT</code>都会走到一段代码逻辑，即<code>unsafe.read()</code>方法，但是OP_ACCEPT和OP_READ操作的具体实例是不一样的。OP_READ的<code>unsafe.read()</code>的操作实例<code>AbstractNioByteChannel</code>。所以这个部分的源码剖析也就从这里开始。</p>
<h3 id="unsafe-read-的另一副面孔AbstractNioByteChannel"><a href="#unsafe-read-的另一副面孔AbstractNioByteChannel" class="headerlink" title="unsafe.read()的另一副面孔AbstractNioByteChannel"></a>unsafe.read()的另一副面孔AbstractNioByteChannel</h3><p>abstractNioByteChannel之前我们剖析过，他的父类AbstractNioChannel拥有channel的注册、连接等功能，但把数据读写功能交给了其子类，AbstractNioMessageChannel前面我们讨论过，主要处理<code>OP_ACCEPT</code>连接事件处理其处理的msg是<code>NioSocketChannel</code>。我们这里要讨论的<code>AbstractNioByteChannel</code>是处理传输的实际数据，这里要处理的msg则是<code>byteBuf</code>。以下则是源码的深入分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//获取pipeline通道配置、channel管道</span><br>    <span class="hljs-keyword">final</span> ChannelConfig config = config();<br>    <span class="hljs-comment">//socketChannel已经关闭</span><br>    <span class="hljs-keyword">if</span> (shouldBreakReadReady(config)) &#123;<br>        clearReadPending();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">final</span> ChannelPipeline pipeline = pipeline();<br>    <span class="hljs-comment">// 获取内容分配器，默认为PooledByteBufAllocator</span><br>    <span class="hljs-keyword">final</span> ByteBufAllocator allocator = config.getAllocator();<br>    <span class="hljs-keyword">final</span> RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();<br>    <span class="hljs-comment">//清空上一次读取的字节数，每次读取时均重新计算</span><br>    <span class="hljs-comment">//字节Buf分配器，并计算字节buf分配器 Handler</span><br>    allocHandle.reset(config);<br><br>    ByteBuf byteBuf = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">boolean</span> close = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-comment">// 分配内存</span><br>            byteBuf = allocHandle.allocate(allocator);<br>            <span class="hljs-comment">// 读取通道接收缓冲区的数据</span><br>            allocHandle.lastBytesRead(doReadBytes(byteBuf));<br>            <span class="hljs-keyword">if</span> (allocHandle.lastBytesRead() &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// nothing was read. release the buffer.</span><br>                <span class="hljs-comment">// 若没有数据可以读，则释放内存</span><br>                byteBuf.release();<br>                byteBuf = <span class="hljs-keyword">null</span>;<br>                close = allocHandle.lastBytesRead() &lt; <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (close) &#123;<br>                    <span class="hljs-comment">//当读到-1时，表示Channel通道已经关闭，没有必要再继续读。</span><br>                    <span class="hljs-comment">// There is nothing left to read as we received an EOF.</span><br>                    readPending = <span class="hljs-keyword">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>			<span class="hljs-comment">// 更新读取消息计数器</span><br>            allocHandle.incMessagesRead(<span class="hljs-number">1</span>);<br>            readPending = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-comment">//通知通道处理器处理数据，触发Channel通道的fireChannelRead事件</span><br>            pipeline.fireChannelRead(byteBuf);<br>            byteBuf = <span class="hljs-keyword">null</span>;<br>        &#125; <span class="hljs-keyword">while</span> (allocHandle.continueReading());<br>		<span class="hljs-comment">// 读取操作完毕</span><br>        allocHandle.readComplete();<br>        pipeline.fireChannelReadComplete();<br>		<br>        <span class="hljs-keyword">if</span> (close) &#123;<br>            <span class="hljs-comment">// 如果Socket通道关闭，则关闭读操作</span><br>            closeOnRead(pipeline);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-comment">// 处理读异常</span><br>        handleReadException(pipeline, byteBuf, t, close, allocHandle);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// Check if there is a readPending which was not processed yet.</span><br>        <span class="hljs-comment">// This could be for two reasons:</span><br>        <span class="hljs-comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method</span><br>        <span class="hljs-comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// See https://github.com/netty/netty/issues/2254</span><br>        <span class="hljs-keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;<br>            <span class="hljs-comment">// 若读操作完毕，且没有配置自动读，则选择Key兴趣集中移除读操作事件。</span><br>            removeReadOp();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这段逻辑和<code>AbstractNioMessageChannel</code>中的read方法不同，这个实例中处理的是读写数据。大体的逻辑就<strong>分配内存</strong>、<strong>读取数据</strong>、<strong>调用pipelineChannel中handler的channelRead方法</strong>。在这几个操作<strong>循环结束后调用pipeline中channelReadComplete方法</strong>。所以我们接下来深入fireChannelRead方法，看看我们经常用到的编解码操作是如何被处理的。</p>
<h3 id="ByteToMessageDecoder-解码操作"><a href="#ByteToMessageDecoder-解码操作" class="headerlink" title="ByteToMessageDecoder 解码操作"></a>ByteToMessageDecoder 解码操作</h3><p>如果要使用编解码操作，我们需要继承<code>ByteToMessageDecoder</code>类<code>EchoDecoder</code>，并实现其<code>decode</code>方法。因此我们在<code>EchoServer</code>中childHandler的<code>ChannelInitializer</code>中pipeline的添加我们创建的实现类<code>EchoDecoder</code>。也就是下面这个代码片段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">.childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ChannelPipeline p = ch.pipeline();<br>        <span class="hljs-keyword">if</span> (sslCtx != <span class="hljs-keyword">null</span>) &#123;<br>            p.addLast(sslCtx.newHandler(ch.alloc()));<br>        &#125;<br>        <span class="hljs-comment">// 添加编码器</span><br>        p.addLast(<span class="hljs-keyword">new</span> EchoEncoder());<br>        <span class="hljs-comment">// 添加解码器</span><br>        p.addLast(<span class="hljs-keyword">new</span> EchoDecoder());<br>        p.addLast(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.INFO));<br>        p.addLast(serverHandler);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>我们接着上面AbstractNioByteChannel中的fireChannelRead逻辑继续往下走。依照我们前面配置的逻辑，nioSocketChannel的pipeline中应该包括<code>EchoDecoder</code>、<code>LoggingHandler</code>和<code>EchoServerHandler</code>这几个业务伤的Handler，当然handler调用链还包括头节点<code>headContext</code>和尾节点<code>tailContext</code>。按照前面我们分析fireChannelXXX的逻辑来看，channelRead方法是<strong>inboundHandler</strong>的方法。所以<strong>从前往后</strong>执行调用链中inboundHandler的channelRead方法（fireChannelXXX方法的调用链执行逻辑，前面已经分析过了，这里就不深入了🥱）。因此以下是EchoDecoder的父类也就是<code>ByteToMessageDecoder</code>的readChannel方法的源码剖析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.handler.codec.ByteToMessageDecoder#channelRead</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> ByteBuf) &#123;<br>        <span class="hljs-comment">// 解码后的消息列表</span><br>        CodecOutputList out = CodecOutputList.newInstance();<br>        <span class="hljs-keyword">try</span> &#123;<br>            first = cumulation == <span class="hljs-keyword">null</span>;<br>            <span class="hljs-comment">// 判断是否是第一次解码</span><br>            <span class="hljs-comment">// 如果是只需把data强转赋给字节容器即可。</span><br>            <span class="hljs-comment">// 否则把msg写入cumulation中</span><br>            cumulation = cumulator.cumulate(ctx.alloc(),<br>                                            first ? Unpooled.EMPTY_BUFFER : cumulation, (ByteBuf) msg);<br>            <span class="hljs-comment">// 从cumulation字节中解码出消息。</span><br>            callDecode(ctx, cumulation, out);<br>        &#125; <span class="hljs-keyword">catch</span> (DecoderException e) &#123;<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> DecoderException(e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 当字节容器不为空且不可读时，需要释放。</span><br>                <span class="hljs-comment">// 并置null,直接回收，将下次解码认为是第一次。</span><br>                <span class="hljs-keyword">if</span> (cumulation != <span class="hljs-keyword">null</span> &amp;&amp; !cumulation.isReadable()) &#123;<br>                    numReads = <span class="hljs-number">0</span>;<br>                    cumulation.release();<br>                    cumulation = <span class="hljs-keyword">null</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (++numReads &gt;= discardAfterReads) &#123;<br>                    <span class="hljs-comment">// 如果读取的字节数大于或等于discardAfterReads</span><br>                    <span class="hljs-comment">// 则设置读取字节数为0</span><br>                    <span class="hljs-comment">// 并移除字节容器中一部读取过的字节</span><br>                    <span class="hljs-comment">// We did enough reads already try to discard some bytes so we not risk to see a OOME.</span><br>                    <span class="hljs-comment">// See https://github.com/netty/netty/issues/4275</span><br>                    numReads = <span class="hljs-number">0</span>;<br>                    discardSomeReadBytes();<br>                &#125;<br><br>                <span class="hljs-keyword">int</span> size = out.size();<br>                <span class="hljs-comment">// fireChannelRead 属性在channelReadComplete() 方法中被调用。</span><br>                firedChannelRead |= out.insertSinceRecycled();<br>                <span class="hljs-comment">// 执行下一个handler</span><br>                fireChannelRead(ctx, out, size);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">//回收解码消息集合。</span><br>                out.recycle();<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 非ByteBuf消息，此解码器不进行解码</span><br>        ctx.fireChannelRead(msg);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// io.netty.handler.codec.ByteToMessageDecoder#callDecode</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callDecode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 循环编解码</span><br>        <span class="hljs-keyword">while</span> (in.isReadable()) &#123;<br>            <span class="hljs-comment">// 判断是否已经有可用消息</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> outSize = out.size();<br><br>            <span class="hljs-keyword">if</span> (outSize &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 当前存在可用消息，调用fireChannelRead触发下一个handler处理这些消息</span><br>                fireChannelRead(ctx, out, outSize);<br>                out.clear();<br><br>                <span class="hljs-comment">// Check if this handler was removed before continuing with decoding.</span><br>                <span class="hljs-comment">// If it was removed, it is not safe to continue to operate on the buffer.</span><br>                <span class="hljs-comment">//</span><br>                <span class="hljs-comment">// See:</span><br>                <span class="hljs-comment">// - https://github.com/netty/netty/issues/4635</span><br>                <span class="hljs-comment">// 如果当前上下文已经被移除了，则不能继续操作</span><br>                <span class="hljs-keyword">if</span> (ctx.isRemoved()) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>			<span class="hljs-comment">// 获取字节容器的可读字节数</span><br>            <span class="hljs-keyword">int</span> oldInputLength = in.readableBytes();<br>			<span class="hljs-comment">// 把消息容byteBuf in读取到对象out中，也就是在这里调用我们的子类方法。</span><br>            decodeRemovalReentryProtection(ctx, in, out);<br><br>            <span class="hljs-comment">// Check if this handler was removed before continuing the loop.</span><br>            <span class="hljs-comment">// If it was removed, it is not safe to continue to operate on the buffer.</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// See https://github.com/netty/netty/issues/1664</span><br>            <span class="hljs-keyword">if</span> (ctx.isRemoved()) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (out.isEmpty()) &#123;<br>                <span class="hljs-comment">// 如果当前out中没有数据，说明解码失败，无需继续</span><br>                <span class="hljs-keyword">if</span> (oldInputLength == in.readableBytes()) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (oldInputLength == in.readableBytes()) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> DecoderException(<br>                    StringUtil.simpleClassName(getClass()) +<br>                    <span class="hljs-string">&quot;.decode() did not read anything but decoded a message.&quot;</span>);<br>            &#125;<br>			<span class="hljs-comment">// 如果只是进行一次解码，直接退出。</span><br>            <span class="hljs-keyword">if</span> (isSingleDecode()) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (DecoderException e) &#123;<br>        <span class="hljs-keyword">throw</span> e;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception cause) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> DecoderException(cause);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// io.netty.handler.codec.ByteToMessageDecoder#decodeRemovalReentryProtection</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decodeRemovalReentryProtection</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span></span><br><span class="hljs-function">            <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    decodeState = STATE_CALLING_CHILD_DECODE;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 由实现子类完成解码。</span><br>        decode(ctx, in, out);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 判断channel的处理器是否正在移除。</span><br>        <span class="hljs-keyword">boolean</span> removePending = decodeState == STATE_HANDLER_REMOVED_PENDING;<br>        decodeState = STATE_INIT;<br>        <span class="hljs-keyword">if</span> (removePending) &#123;<br>            fireChannelRead(ctx, out, out.size());<br>            out.clear();<br>            handlerRemoved(ctx);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们通过上面的分析，很容易发现。编解码也是一个channelRead的方法实现，只是Netty提供了一个<code>ByteToMessageDecoder</code>的模版方法实现，把真正的解码过程流程实现类的<code>decode</code>方法。在完成编解码之后，再依次调用后续的处理器的channelRead方法（将拆到的业务数据传递给后续的handler）。这段代码整体逻辑如下：</p>
<ol>
<li><p>channelRead() 方法<strong>首先会判断msg是否为ByteBuf类型，只有在是的情况下才会进行解码</strong>。<strong>这就是为什么StringDecoder等MessageToMessageCodec解码器放在ByteToMessageDecoder子类之后的原因，这时的msg一般都是堆外直接内存DirectByteBuf，因为采用堆外直接内存在传输时可以少一次复制</strong>。然后判断是否为第一次解码，若是，则直接把msg赋值给cumulation（<strong>cumulation是读取半包的容器</strong>），如不是，则需要把msg写入cumulation中，写入之前要判断是否需要扩容。</p>
</li>
<li><p>把<strong>新读取到的数据写入cumulation之后，调用callDecode()方法</strong>。在callDecode()方法中会不断的调用子类的decode()方法，直到当前cumulation无法继续解码。其中，无法继续解码分为两种情况。第一种是无可以读的字节，第二种是经历过decode()方法后，可读字节数没有任何变化。</p>
</li>
<li><p>执行完callDecode()方法后，<strong>进入finally代码块进行收尾工作</strong>。若cumulation不为空，且不可读的时，需要把cumulation释放掉并赋空值，若连续16次（discardAfterReads的默认值）字节容器cumulation中仍然有未被业务拆包器读取的数据，则需要进行一次压缩：将有效数据段整体移动到容器的首部，同时用一个成员变量fireChannelRead来标识本次读取数据是否拆到了一个业务数据包，并触发fireChannelRead事件，将拆到的业务数据包传递给后续的handler，最后把out放回对象池中。</p>
</li>
</ol>
<h3 id="OP-READ事件读操作源码逻辑小结"><a href="#OP-READ事件读操作源码逻辑小结" class="headerlink" title="OP_READ事件读操作源码逻辑小结"></a>OP_READ事件读操作源码逻辑小结</h3><p>优秀的框架总会不断的强化一个其逻辑模型的特性，在netty的源码探索中，几乎所有的业务处理操作都离不开pipeline中handler调用链的处理。同样在OP_READ事件读操作中，也是通过调用pipeline中handler调用链的形式实现的。当前OP_READ的事件被触发时，调用prcessSelectionKeys中的<code>unsafe.read()</code>方法。但是这次和<code>OP_ACCEPT</code>事件不同。这次的具体的实现类是<code>AbstratNioByteChannel</code>，其侧重的是数据的读写。将数据读取到byteBuf之后，将byteBuf作fireChannelRead方法的入参msg调用pipeline的handler调用链。在实际的开发过程中，我们通常会自定义编解码器，在读这个阶段，需要对消息进行解码。通过继承<code>ByteToMessageDecoder</code>并实现具体<code>decode</code>方法来实现。ByteToMessageDecoder也是一个<code>inboundHandler</code>，它也是拓展channelRead方法来进行逻辑的处理。它的主要工作是将byteBuf的数据转换成对应的<code>List&lt;Object&gt;</code>对象(byteBuf -&gt; Object)。<strong>因此如果是后续对数据进一步编码的逻辑（Object -&gt; xxx）应该加在ByteToMessageDecoder的后面，可以减少一次堆外直接内存的复制。</strong>执行完当前的Handler之后，通过ctx.fireChannelRead()继续调用后续的Handler即<code>LoggingHandler</code>和<code>EchoServerHandler</code>。在读操作完成后，再调用<code>pipeline.fireChannelReadComplete()</code>它也是InboundHandler方法。他们的调用逻辑和前fireChannelActive、fireChannelRegister等inboundHandler中的方法调用逻辑一致，因此就不重复分析了。</p>
<h1 id="I-O就绪事件处之OP-READ（二）"><a href="#I-O就绪事件处之OP-READ（二）" class="headerlink" title="I/O就绪事件处之OP_READ（二）"></a>I/O就绪事件处之OP_READ（二）</h1><p>前面的部分我们梳理了Netty读写数据操作中读的部分，接下来，我们来详细梳理下Netty写数据的处理逻辑。在《<a target="_blank" rel="noopener" href="https://book.douban.com/subject/35246428/">Netty源码剖析与应用</a>》这本书中，这部分的剖析之前提出了几个有意思的问题，我们可以一起来找找答案。</p>
<blockquote>
<ul>
<li><p>Netty在写操作之前调用了那些Handler，并且这次的调用链和其他outboundHandler方法调用链的调用逻辑有什么区别？</p>
</li>
<li><p>在业务Handler中，若开启了额外的业务线程，那么在Netty内部是如何把业务的结果数据经过IO线程发送出去的呢？</p>
</li>
<li><p>为了提高网络的吞吐量，在调用write时，数据并没有直接被写到Socket中，而是被写到了Netty的缓冲区（channelOutboudBuffer）中，在并发很高的情况下，在对方接收数据比较慢时，Netty的写缓冲区如何防止内存溢出，防止出现大量内存无法释放的情况?</p>
</li>
</ul>
</blockquote>
<h2 id="OP-READ事件写操作概述"><a href="#OP-READ事件写操作概述" class="headerlink" title="OP_READ事件写操作概述"></a>OP_READ事件写操作概述</h2><p>写操作和前面的读操作register操作的整理逻辑是一样的，都是基于pipeline中handler调用链实现的。同样的这里的大体逻辑也是一样的。也是通过调用outbound的write方法将数据写入到<code>channelOutboundBuffer</code>中，然后调用flush方法将数据发送出去。同样的，这里我们先看调用的时序图。</p>
<p>![](/Users/daiwei/Library/Application Support/typora-user-images/image-20220226150743301.png)</p>
<p>从上面的时序图，不难看出Netty的write操作也是基于pipeline调用实现的，和读操作对应在发送数据之前需要将数据进行编码。因为是outboundHandler的方法，在HeadContext上会将数据写入到缓存中，并在最后调用flush方法将数据通过socket发送回去。</p>
<h2 id="OP-READ事件写操作源码剖析"><a href="#OP-READ事件写操作源码剖析" class="headerlink" title="OP_READ事件写操作源码剖析"></a>OP_READ事件写操作源码剖析</h2><p>在write的过程中要先调用编码方法，对写出的数据进行自定义协议的编码操作。在前面我们分析读操作时提到<code>ByteToMessageDecoder</code>解码器的逻辑要放在其他MessageToMessageCodec最前面，因为Netty的msg一般使用的是堆外直接内存DirectByteBuf。同样的<strong>MessageToByteEnCoder编码器也需要放在Handler调用链的最前面。write方法是outBound的方法，handler的调用链会从后向前调用，放在handler的最前面则会被最后调用</strong>。在下面源码剖析部分也会详细剖析编码的逻辑。在这个部分还有一个细节，就是<strong>write方法并不会直接将数据发送出去，而是会将数据暂存到channelOutboundBuffer中，只有当调用flush方法时才会将数据写入到socket中发送</strong>出去。那channelOutboundBuffer中的缓存数据维护的实现细节，以及buffer内存背压通知的实现又是怎样的？源码中都会有答案。</p>
<blockquote>
<p>write方法不会直接将数据发送出去，会先将数据暂存在channelOutboundBuffer中，只有调用flush方法才会将数据写入socket发送，真的调用了flush就一定会被直接发送出去么？🤔</p>
</blockquote>
<h3 id="熟悉的pipeline调用链"><a href="#熟悉的pipeline调用链" class="headerlink" title="熟悉的pipeline调用链"></a>熟悉的pipeline调用链</h3><p>在OP_READ操作读的部分剖析中，我们走到了<code>EchoServerHandler</code>的<code>channelRead</code>方法。我们从这里开始继续我们源码剖析。（p.s.：这一段可能和Netty的源码不太一致，这一段因为内容需要我进行了调整，直接将数据write回客户端，便于我们后续的调试。）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// io.netty.example.echo.EchoServerHandler</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;<br>        <span class="hljs-comment">// 将数据会客户端</span><br>        ctx.write(msg);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;<br>        <span class="hljs-comment">// 写操作完调用flush操作发送数据。</span><br>        ctx.flush();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;<br>        <span class="hljs-comment">// Close the connection when an exception is raised.</span><br>        cause.printStackTrace();<br>        ctx.close();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.AbstractChannelHandlerContext#write(java.lang.Object, boolean, io.netty.channel.ChannelPromise)</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(Object msg, <span class="hljs-keyword">boolean</span> flush, ChannelPromise promise)</span> </span>&#123;<br>    <span class="hljs-comment">// ctx.write()实际调用的方法。</span><br>    ObjectUtil.checkNotNull(msg, <span class="hljs-string">&quot;msg&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (isNotValidPromise(promise, <span class="hljs-keyword">true</span>)) &#123;<br>            ReferenceCountUtil.release(msg);<br>            <span class="hljs-comment">// cancelled</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;<br>        ReferenceCountUtil.release(msg);<br>        <span class="hljs-keyword">throw</span> e;<br>    &#125;<br><br>    <span class="hljs-comment">// 找到下一个实现wirte方法的outboudHandler</span><br>    <span class="hljs-keyword">final</span> AbstractChannelHandlerContext next = findContextOutbound(flush ?<br>                                                                   (MASK_WRITE | MASK_FLUSH) : MASK_WRITE);<br>    <span class="hljs-comment">// 记录当前对象访问位置（咱也不知道这是为啥）</span><br>    <span class="hljs-keyword">final</span> Object m = pipeline.touch(msg, next);<br>    EventExecutor executor = next.executor();<br>    <span class="hljs-keyword">if</span> (executor.inEventLoop()) &#123;<br>        <span class="hljs-keyword">if</span> (flush) &#123;<br>            <span class="hljs-comment">// 如果当前要直接flush，调用invokeWriteAndFlush直接写入socket</span><br>            next.invokeWriteAndFlush(m, promise);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 否则写入channelOutBoundBuffer中</span><br>            next.invokeWrite(m, promise);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果当前线程不是eventLoop线程，创建写任务task，并将task丢入到eventLoop的task队列中执行。</span><br>        <span class="hljs-keyword">final</span> WriteTask task = WriteTask.newInstance(next, m, promise, flush);<br>        <span class="hljs-keyword">if</span> (!safeExecute(executor, task, promise, m, !flush)) &#123;<br>            <span class="hljs-comment">// We failed to submit the WriteTask. We need to cancel it so we decrement the pending bytes</span><br>            <span class="hljs-comment">// and put it back in the Recycler for re-use later.</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// See https://github.com/netty/netty/issues/8343.</span><br>            <span class="hljs-comment">// 提交任务失败，任务取消。</span><br>            task.cancel();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里需要注意的是，我们<code>ctx.write(msg)</code>方法是<code>channelOutboundHandler</code>的中的方法。并且此时pipeline中有以下几个handler，<code>(headContext)</code>、<code>EchoEncoder</code>、<code>EchoDecoder</code>、<code>LoggingHandler</code>、<code>EchoServerHandler</code>、<code>(tailContext)</code>。同时<code>(headContext)</code>、<code>EchoEncoder</code>、<code>LoggingHandler</code>、<code>EchoServerHandler</code>、<code>(tailContext)</code>这几个handler是channelOutboundHandler（如下图）。</p>
<p><img src="https://raw.githubusercontent.com/realDaiwei/image/master/20220221235508.png" srcset="/img/loading.gif"></p>
<p>在<code>EchoServerHandler</code>中调用ctx.write()方法，实际执行的是AbstractChannelHandlerContext#write(Object, boolean, ChannelPromise)方法，在这个方法中，通过<code>findContextOutbound</code>方法寻找下一个outBound方法。按照我们前面对fireChannelXXX方法的分析，往后依次执行的handler应该是<code>LoggingHandler</code>、<code>EchoEncoder</code>、<code>(headContext)</code>。所以这里的逻辑和前面我们剖析的其他的pipelineChannelHandler方法不一样，它并没有从headContext开始从前往后执行，也不是从tailContext开始从后往前执行，而是从中间的handler开始按照outboundHandler的规则依次向前执行。同样的<code>ctx.flush()</code>也是这个逻辑。</p>
<p>在上面源码中的AbstractChannelHandlerContext#write方法，有提到一个<code>WriteTask</code>。代码中会判断当前执行线程是否是eventLoop线程，如果不是创建一个writeTask并丢到eventLoop队列中执行。看了这一段源码是不是我们在一小节提到的两个问题，你的心中是否已经有了答案呢？</p>
<blockquote>
<ul>
<li>Netty在写操作之前调用了那些Handler，并且这次的调用链和其他outboundHandler方法调用链的调用逻辑有什么区别？</li>
<li>在业务Handler中，若开启了额外的业务线程，那么在Netty内部是如何把业务的结果数据经过IO线程发送出去的呢？</li>
</ul>
</blockquote>
<p>我们接着上面pipeline调用链继续往下执行，按照我们前面的分析，下一个outboundHandler是LoggingHandler。这段逻辑很简单，输出一段日志信息即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.handler.logging.LoggingHandler#write</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">if</span> (logger.isEnabled(internalLevel)) &#123;<br>        logger.log(internalLevel, format(ctx, <span class="hljs-string">&quot;WRITE&quot;</span>, msg));<br>    &#125;<br>    ctx.write(msg, promise);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>下一个outboundHandler是<code>EchoEncoderHandler</code>这个handler中主要是编码操作，我们放在下面一个小节深入梳理。在编码的EchoEncoderHandler之后，就是我们的最后一个outboundHandler即<code>HeadContext</code>。下面是HeadContext的write方法的源码剖析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.channel.DefaultChannelPipeline.HeadContext#write</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> </span>&#123;<br>    unsafe.write(msg, promise);<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.AbstractChannel.AbstractUnsafe#write</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(Object msg, ChannelPromise promise)</span> </span>&#123;<br>    <span class="hljs-comment">// 校验是否是eventLoop方法</span><br>    assertEventLoop();<br><br>    <span class="hljs-comment">// 获取当前的outboundBuffer</span><br>    ChannelOutboundBuffer outboundBuffer = <span class="hljs-keyword">this</span>.outboundBuffer;<br>    <span class="hljs-keyword">if</span> (outboundBuffer == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 如果当前的outboundBuffer为null的话，直接调用释放当前byteBuf</span><br>            <span class="hljs-comment">// release message now to prevent resource-leak</span><br>            ReferenceCountUtil.release(msg);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// If the outboundBuffer is null we know the channel was closed and so</span><br>            <span class="hljs-comment">// need to fail the future right away. If it is not null the handling of the rest</span><br>            <span class="hljs-comment">// will be done in flush0()</span><br>            <span class="hljs-comment">// See https://github.com/netty/netty/issues/2362</span><br>            <span class="hljs-comment">// 设置promise写失败</span><br>            safeSetFailure(promise,<br>                           newClosedChannelException(initialCloseCause, <span class="hljs-string">&quot;write(Object, ChannelPromise)&quot;</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> size;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 一个消息转换的方法，但是这个方法直接返回了msg</span><br>        msg = filterOutboundMessage(msg);<br>        <span class="hljs-comment">// 计算msg的大小</span><br>        size = pipeline.estimatorHandle().size(msg);<br>        <span class="hljs-keyword">if</span> (size &lt; <span class="hljs-number">0</span>) &#123;<br>            size = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ReferenceCountUtil.release(msg);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            safeSetFailure(promise, t);<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>   	<span class="hljs-comment">// 将msg加入到channelOutboundBuffer中。</span><br>    outboundBuffer.addMessage(msg, size, promise);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面这部分是基于pipeline调用链对write方法进行剖析。当然写操作不仅仅只write方法，数据被写入到channelOutboudBuffer中，调用flush方法才会将数据写入到socket中发送出去。在前面对NioByteUnsafe#read方法的剖析中，完成<code>fireChannelRead()</code>的方法调用后会调用<code>fireChannelReadComplete()</code>方法，按照我们pipeline调用链的inboundHandler的调用逻辑，最终会调用echoServerHandler#readComplete方法，即执行<code>ctx.flush()</code>方法。前面我们提到flush的调用逻辑和write逻辑是一致的，flush是outboundHandler那按照<strong>outboundHandler</strong>的调用逻辑，会<strong>从后向前</strong>依次调用outboudHandler的flush方法，也就是<code>LoggingHandler</code>、<code>HeadContext</code>这几个Handler的flush方法，以下是flush操作的源码剖析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.handler.logging.LoggingHandler#flush</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flush</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">//loggingHandler的flush方法。</span><br>    <span class="hljs-keyword">if</span> (logger.isEnabled(internalLevel)) &#123;<br>        logger.log(internalLevel, format(ctx, <span class="hljs-string">&quot;FLUSH&quot;</span>));<br>    &#125;<br>    <span class="hljs-comment">// 调用下一个包含flush的outboundHandler</span><br>    ctx.flush();<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.DefaultChannelPipeline.HeadContext#flush</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flush</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;<br>    <span class="hljs-comment">// headContext中调用unsafe#flush()</span><br>    unsafe.flush();<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.AbstractChannel.AbstractUnsafe#flush</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flush</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 校验当前执行线程是否是eventLoop线程。</span><br>    assertEventLoop();<br><br>    ChannelOutboundBuffer outboundBuffer = <span class="hljs-keyword">this</span>.outboundBuffer;<br>    <span class="hljs-keyword">if</span> (outboundBuffer == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>	<span class="hljs-comment">// 将channelOutboundBuffer中的写入的数据加入到flush的队列中</span><br>    outboundBuffer.addFlush();<br>    <span class="hljs-comment">// 将flush队列中的entry数据写入到socket中。</span><br>    flush0();<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.ChannelOutboundBuffer#addFlush</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFlush</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// There is no need to process all entries if there was already a flush before and no new messages</span><br>    <span class="hljs-comment">// where added in the meantime.</span><br>    <span class="hljs-comment">// See https://github.com/netty/netty/issues/2577</span><br>    <span class="hljs-comment">// 移动链表中entry的操作，表明某个之前的数据需要被处理。</span><br>    Entry entry = unflushedEntry;<br>    <span class="hljs-keyword">if</span> (entry != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (flushedEntry == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// there is no flushedEntry yet, so start with the entry</span><br>            flushedEntry = entry;<br>        &#125;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-comment">// 统计要flush的entry的个数。</span><br>            flushed ++;<br>            <span class="hljs-comment">// 设置这些即将被flush的entry状态为uncancelable(不可取消状态)。</span><br>            <span class="hljs-keyword">if</span> (!entry.promise.setUncancellable()) &#123;<br>                <span class="hljs-comment">// 如果当前entry已经取消了，释放entry的内存，并且减小channelOutboundBuffer大小并触发后续事件。</span><br>                <span class="hljs-comment">// Was cancelled so make sure we free up memory and notify about the freed bytes</span><br>                <span class="hljs-keyword">int</span> pending = entry.cancel();<br>                decrementPendingOutboundBytes(pending, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);<br>            &#125;<br>            entry = entry.next;<br>        &#125; <span class="hljs-keyword">while</span> (entry != <span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">// All flushed so reset unflushedEntry</span><br>        unflushedEntry = <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.AbstractChannel.AbstractUnsafe#flush0</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flush0</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (inFlush0) &#123;<br>        <span class="hljs-comment">// Avoid re-entrance</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> ChannelOutboundBuffer outboundBuffer = <span class="hljs-keyword">this</span>.outboundBuffer;<br>    <span class="hljs-keyword">if</span> (outboundBuffer == <span class="hljs-keyword">null</span> || outboundBuffer.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    inFlush0 = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-comment">// Mark all pending write requests as failure if the channel is inactive.</span><br>    <span class="hljs-keyword">if</span> (!isActive()) &#123;<br>        <span class="hljs-comment">// 如果当前通道已经关闭了，异常处理即可。</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// Check if we need to generate the exception at all.</span><br>            <span class="hljs-keyword">if</span> (!outboundBuffer.isEmpty()) &#123;<br>                <span class="hljs-keyword">if</span> (isOpen()) &#123;<br>                    outboundBuffer.failFlushed(<span class="hljs-keyword">new</span> NotYetConnectedException(), <span class="hljs-keyword">true</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// Do not trigger channelWritabilityChanged because the channel is closed already.</span><br>                    outboundBuffer.failFlushed(newClosedChannelException(initialCloseCause, <span class="hljs-string">&quot;flush0()&quot;</span>), <span class="hljs-keyword">false</span>);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            inFlush0 = <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 将channelOutboundBuffer的数据写入socket中。</span><br>        doWrite(outboundBuffer);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        handleWriteError(t);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        inFlush0 = <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.socket.nio.NioSocketChannel#doWrite</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doWrite</span><span class="hljs-params">(ChannelOutboundBuffer in)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    SocketChannel ch = javaChannel();<br>    <span class="hljs-keyword">int</span> writeSpinCount = config().getWriteSpinCount();<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">if</span> (in.isEmpty()) &#123;<br>            <span class="hljs-comment">// All written so clear OP_WRITE</span><br>            clearOpWrite();<br>            <span class="hljs-comment">// Directly return here so incompleteWrite(...) is not called.</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// Ensure the pending writes are made of ByteBufs only.</span><br>        <span class="hljs-comment">// 确保挂起的写入数据仅由byteBuf组成。</span><br>        <span class="hljs-keyword">int</span> maxBytesPerGatheringWrite = ((NioSocketChannelConfig) config).getMaxBytesPerGatheringWrite();<br>        <span class="hljs-comment">// 为entry创建byteBuffer数组</span><br>        ByteBuffer[] nioBuffers = in.nioBuffers(<span class="hljs-number">1024</span>, maxBytesPerGatheringWrite);<br>        <span class="hljs-keyword">int</span> nioBufferCnt = in.nioBufferCount();<br><br>        <span class="hljs-comment">// Always use nioBuffers() to workaround data-corruption.</span><br>        <span class="hljs-comment">// See https://github.com/netty/netty/issues/2761</span><br>        <span class="hljs-keyword">switch</span> (nioBufferCnt) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                <span class="hljs-comment">// 没有enrty数据需要处理。</span><br>                <span class="hljs-comment">// We have something else beside ByteBuffers to write so fallback to normal writes.</span><br>                writeSpinCount -= doWrite0(in);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: &#123;<br>                <span class="hljs-comment">// 只有一个entry数据需要处理。</span><br>                <span class="hljs-comment">// Only one ByteBuf so use non-gathering write</span><br>                <span class="hljs-comment">// Zero length buffers are not added to nioBuffers by ChannelOutboundBuffer, so there is no need</span><br>                <span class="hljs-comment">// to check if the total size of all the buffers is non-zero.</span><br>                <span class="hljs-comment">// 取出第一个bytebufer</span><br>                ByteBuffer buffer = nioBuffers[<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">int</span> attemptedBytes = buffer.remaining();<br>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> localWrittenBytes = ch.write(buffer);<br>                <span class="hljs-keyword">if</span> (localWrittenBytes &lt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 写入没有完成，后续以eventLoop的task任务形式执行。</span><br>                    incompleteWrite(<span class="hljs-keyword">true</span>);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <span class="hljs-comment">// 调整自适应写，批量写数据时，如果尝试写的都写进去了，接下来会尝试写更多</span><br>                adjustMaxBytesPerGatheringWrite(attemptedBytes, localWrittenBytes, maxBytesPerGatheringWrite);<br>                <span class="hljs-comment">// 移除已经写入的entry，并更新bytebuf的读索引。</span><br>                in.removeBytes(localWrittenBytes);<br>                <span class="hljs-comment">// 减少连续写次数，默认16次。</span><br>                --writeSpinCount;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">default</span>: &#123;<br>                <span class="hljs-comment">// Zero length buffers are not added to nioBuffers by ChannelOutboundBuffer, so there is no need</span><br>                <span class="hljs-comment">// to check if the total size of all the buffers is non-zero.</span><br>                <span class="hljs-comment">// We limit the max amount to int above so cast is safe</span><br>               <span class="hljs-comment">// 多个entry数据需要处理。</span><br>                <span class="hljs-keyword">long</span> attemptedBytes = in.nioBufferSize();<br>                <span class="hljs-comment">// 将数据写入socket</span><br>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> localWrittenBytes = ch.write(nioBuffers, <span class="hljs-number">0</span>, nioBufferCnt);<br>                <span class="hljs-keyword">if</span> (localWrittenBytes &lt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 写入没有完成，后续以eventLoop的task任务形式执行。</span><br>                    incompleteWrite(<span class="hljs-keyword">true</span>);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <span class="hljs-comment">// Casting to int is safe because we limit the total amount of data in the nioBuffers to int above.</span><br>          		<span class="hljs-comment">// 调整自适应写，批量写数据时，如果尝试写的都写进去了，接下来会尝试写更多</span><br>                adjustMaxBytesPerGatheringWrite((<span class="hljs-keyword">int</span>) attemptedBytes, (<span class="hljs-keyword">int</span>) localWrittenBytes,<br>                                                maxBytesPerGatheringWrite);<br>                <span class="hljs-comment">// 移除已经写入的entry，并更新bytebuf的读索引。</span><br>                in.removeBytes(localWrittenBytes);<br>                <span class="hljs-comment">// 减少连续写次数，默认16次。</span><br>                --writeSpinCount;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (writeSpinCount &gt; <span class="hljs-number">0</span>);<br>	<span class="hljs-comment">// 因为连续写入16次，不能保证所有数据都会写完，如果存在后续任务以eventLoop的task任务形式执行。</span><br>    incompleteWrite(writeSpinCount &lt; <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.nio.AbstractNioByteChannel#incompleteWrite</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">incompleteWrite</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> setOpWrite)</span> </span>&#123;<br>    <span class="hljs-comment">// Did not write completely.</span><br>    <span class="hljs-keyword">if</span> (setOpWrite) &#123;<br>        <span class="hljs-comment">// 当前写socket时返回值小于写入长度甚至返回0,表示有数据积压，此时应该注册write事件，</span><br>        <span class="hljs-comment">// 待所有数据写后没有数据可写时，取消write事件并注册read事件</span><br>        setOpWrite();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// It is possible that we have set the write OP, woken up by NIO because the socket is writable, and then</span><br>        <span class="hljs-comment">// use our write quantum. In this case we no longer want to set the write OP because the socket is still</span><br>        <span class="hljs-comment">// writable (as far as we know). We will find out next time we attempt to write if the socket is writable</span><br>        <span class="hljs-comment">// and set the write OP if necessary.</span><br>        <span class="hljs-comment">// 清除op_write事件</span><br>        clearOpWrite();<br><br>        <span class="hljs-comment">// Schedule flush again later so other tasks can be picked up in the meantime</span><br>        eventLoop().execute(flushTask);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上就是flush逻辑的分析。通过这个部分的分析我们可以容易发现，flush的逻辑也是基于pipeline调用链实现的，并且write方法只会把数据写入到channelOutboundBuffer中，并不会直接写入到socket中，只有后续调用flush方法，才会将数据写入到socket中。在后续的写入socket的操作中，netty并没有简单的写入而是有多个参数来“感知”当前写入的“情况”（socketChannel能写就多写一些，写不了就等等）。当然在这个部分，还有一些有意思的内容没深入，比如<code>entry</code>、<code>opWrite</code>和<code>writeSpinCount</code>等。这些内容我们会在下面的内容中深入分析。</p>
<h3 id="MessageToByteEncoder编码操作"><a href="#MessageToByteEncoder编码操作" class="headerlink" title="MessageToByteEncoder编码操作"></a>MessageToByteEncoder编码操作</h3><p>在前面我们分析基于pipeline调用链调用write方法过程中，write操作调用我们实现的编码EchoEncoder，对数据进行编码。EchoEncoder继承于<code>MessageToByteEcoder</code>，我们这个部分的源码剖析也就从这里开始。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    ByteBuf buf = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 校验当前msg是否应该被处理。</span><br>        <span class="hljs-keyword">if</span> (acceptOutboundMessage(msg)) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-comment">// 强制类型转换</span><br>            I cast = (I) msg;<br>            <span class="hljs-comment">// 分配ByteBuf，preferDirect 是否要使用直接内存</span><br>            buf = allocateBuffer(ctx, cast, preferDirect);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 调用子类的编码方法</span><br>                encode(ctx, cast, buf);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 数据已经写入到bytebuf中，释放msg对象</span><br>                ReferenceCountUtil.release(cast);<br>            &#125;<br><br>            <span class="hljs-comment">//如果当前byteBuf可读</span><br>            <span class="hljs-keyword">if</span> (buf.isReadable()) &#123;<br>                <span class="hljs-comment">// 调用下一个outboundHandler的write方法。</span><br>                ctx.write(buf, promise);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 释放bytebuf</span><br>                buf.release();<br>                <span class="hljs-comment">//写一个空的bytebuf，继续调用下一个outboundHandler的write方法。</span><br>                ctx.write(Unpooled.EMPTY_BUFFER, promise);<br>            &#125;<br>            buf = <span class="hljs-keyword">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果当前msg不应该被处理，直接调用下一个outboundHandler的write方法。</span><br>            ctx.write(msg, promise);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (EncoderException e) &#123;<br>        <span class="hljs-keyword">throw</span> e;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> EncoderException(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 全部执行完成释放bytebuf</span><br>        <span class="hljs-keyword">if</span> (buf != <span class="hljs-keyword">null</span>) &#123;<br>            buf.release();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//io.netty.example.echo.EchoEncoder</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoEncoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToByteEncoder</span>&lt;<span class="hljs-title">Object</span>&gt; </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Encode a message into a &#123;<span class="hljs-doctag">@link</span> ByteBuf&#125;. This method will be called for each written message that can be handled</span><br><span class="hljs-comment">     * by this encoder.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx the &#123;<span class="hljs-doctag">@link</span> ChannelHandlerContext&#125; which this &#123;<span class="hljs-doctag">@link</span> MessageToByteEncoder&#125; belongs to</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msg the message to encode</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> out the &#123;<span class="hljs-doctag">@link</span> ByteBuf&#125; into which the encoded message will be written</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception is thrown if an error occurs</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ByteBuf out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 自定义编码方法很简单，先发送数据长度，再发送数据byte数据/</span><br>        out.writeInt(msg.toString().length());<br>        out.writeBytes(msg.toString().getBytes(CharsetUtil.UTF_8));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个编码操作相较于解码操作则简单了不少，在<strong>进行编码操作前只是简单的判断当前msg是否应该处理</strong>，<strong>然后创建用于写入msg的bytebuf</strong>，<strong>随后调用encode方法即我们自定义编码器实现encoder方法对msg进行自定义编码</strong>将结果写入到bytebuf中。</p>
<h3 id="ChannelOutboundBuffer结构剖析"><a href="#ChannelOutboundBuffer结构剖析" class="headerlink" title="ChannelOutboundBuffer结构剖析"></a>ChannelOutboundBuffer结构剖析</h3><p>前面我们提到了write方法并不会直接把数据写到socketChannel中，而是会写到channelOutboundBuffer中。只有调用flush方法才会将数据从channelOutboundBuffer中写入到socketChannel中。当然在OP_READ读操作剖析这部分开始时，我们还提了一个问题“为了提高网络的吞吐量，在调用write时，数据并没有直接被写到Socket中，而是被写到了Netty的缓冲区（channelOutboudBuffer）中，在并发很高的情况下，在对方接收数据比较慢时，Netty的写缓冲区如何防止内存溢出，防止出现大量内存无法释放的情况？”。在解答这个问题之前，先来了解一下Netty的缓冲区ChannelOutboundBuffer。它也是<strong>一个链表结构，链表的每个节点都是一个entry，entry中有消息的内容、next指针</strong>等，其中有5个非常重要的属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Entry(flushedEntry) --&gt; ... Entry(unflushedEntry) --&gt; ... Entry(tailEntry)</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The Entry that is the first in the linked-list structure that was flushed</span><br><span class="hljs-comment">// 链表中被刷新的第一个元素，此元素准备第一个写入Socket</span><br><span class="hljs-keyword">private</span> Entry flushedEntry;<br><span class="hljs-comment">// The Entry which is the first unflushed in the linked-list structure</span><br><span class="hljs-comment">//链表中的第一个未刷新的元素</span><br><span class="hljs-comment">// 当调用addMessage()方法后，从原链表tailEntry到Entry（现链表的tailEntry）节点</span><br><span class="hljs-comment">// 都是未被刷新的数据</span><br><span class="hljs-keyword">private</span> Entry unflushedEntry;<br><span class="hljs-comment">// The Entry which represents the tail of the buffer</span><br><span class="hljs-comment">// 链表末尾节点。</span><br><span class="hljs-keyword">private</span> Entry tailEntry;<br><span class="hljs-comment">// The number of flushed entries that are not written yet</span><br><span class="hljs-comment">// 表示已经刷新但还没写到socket中的entry数量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> flushed;<br><span class="hljs-comment">//每新增一个Entry，其大小要加上Entry实例的大小（96B）和真实数据的大小。</span><br><span class="hljs-meta">@SuppressWarnings(&quot;UnusedDeclaration&quot;)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> totalPendingSize;<br></code></pre></td></tr></table></figure>

<p>在深入ChannelOutboundBuffer的数据结构之前，我们先<code>addMessage()</code>方法，也就是AbstractChannel#write通过这个方法，将要发送的数据写入到ChannelOutboundBuffer中。换言之这个方法是<strong>将待发送数据插入到缓存链表的方法</strong>，以下是这个方法的源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Add given message to this &#123;<span class="hljs-doctag">@link</span> ChannelOutboundBuffer&#125;. The given &#123;<span class="hljs-doctag">@link</span> ChannelPromise&#125; will be notified once</span><br><span class="hljs-comment"> * the message was written.</span><br><span class="hljs-comment"> * 每调用一次addMessage()方法，并把数据加在链表的最后。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//io.netty.channel.ChannelOutboundBuffer#addMessage</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addMessage</span><span class="hljs-params">(Object msg, <span class="hljs-keyword">int</span> size, ChannelPromise promise)</span> </span>&#123;<br>    <span class="hljs-comment">//把msg消息数据包装成Entry对象</span><br>    Entry entry = Entry.newInstance(msg, size, total(msg), promise);<br>    <span class="hljs-comment">// 若链表为空，则尾节点为当前节点</span><br>    <span class="hljs-keyword">if</span> (tailEntry == <span class="hljs-keyword">null</span>) &#123;<br>        flushedEntry = <span class="hljs-keyword">null</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 当链表不为空时，把新的Entry对象添加到链表尾</span><br>        Entry tail = tailEntry;<br>        tail.next = entry;<br>    &#125;<br>    <span class="hljs-comment">// 设置最后当前节点为尾节点。</span><br>    tailEntry = entry;<br>    <span class="hljs-comment">// 如果当前unflushedEntry链表为空，</span><br>    <span class="hljs-comment">// 则表明调用addFlush()方法将链表中之前的元素都已经全部加入了需要发送的节点，</span><br>    <span class="hljs-comment">// 否则链表为空</span><br>    <span class="hljs-keyword">if</span> (unflushedEntry == <span class="hljs-keyword">null</span>) &#123;<br>        unflushedEntry = entry;<br>    &#125;<br><br>    <span class="hljs-comment">// 修改通道缓存总数据的大小，若缓存总数据大小超过了最高水位，</span><br>    <span class="hljs-comment">// 则会触发fireChannelWriteabilityChanged事件，进入背压。</span><br>    <span class="hljs-comment">// increment pending bytes after adding message to the unflushed arrays.</span><br>    <span class="hljs-comment">// See https://github.com/netty/netty/issues/1619</span><br>    incrementPendingOutboundBytes(entry.pendingSize, <span class="hljs-keyword">false</span>);<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.ChannelOutboundBuffer#incrementPendingOutboundBytes(long, boolean)</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">incrementPendingOutboundBytes</span><span class="hljs-params">(<span class="hljs-keyword">long</span> size, <span class="hljs-keyword">boolean</span> invokeLater)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>	<br>    <span class="hljs-comment">//当前缓存总数据大小</span><br>    <span class="hljs-keyword">long</span> newWriteBufferSize = TOTAL_PENDING_SIZE_UPDATER.addAndGet(<span class="hljs-keyword">this</span>, size);<br>    <span class="hljs-comment">// 如果大于设置的writeBuffer的高水位，设置不可写状态</span><br>    <span class="hljs-keyword">if</span> (newWriteBufferSize &gt; channel.config().getWriteBufferHighWaterMark()) &#123;<br>        setUnwritable(invokeLater);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>flushedEntry</code>、<code>unflushedEntry</code>和<code>tailEntry</code>将链表划分为刷新和待刷新的数据链表。调用<code>addMessage()</code>的链表示意图如下：</p>
<p><img src="https://raw.githubusercontent.com/realDaiwei/image/master/20220222233058.png" srcset="/img/loading.gif"></p>
<p>在调用<code>addMessage()</code>方法之后，采用<strong>CAS方式增加待发送节点的字节数</strong>，此时如果待发送的字节数大于通道写buf的最高阈值<code>writeBufferHighWaterMark</code>，则更新通道状态为不可写，同时会触发channelWriteabilityChanged事件防止buf溢出。<strong>调用addMessage()方法将数据添加到channelOutboundBuffer中，我们都知道此时数据并没有发送出去，只有调用了flush方法数据才会被发送出去</strong>。通过前面的源码剖析我们发现，调用AbstractUnsafe#flush0将数据写入到socket中之前，会先调用<code>outboundBuffer.addFlush()</code>修改buffer中链表数据的状态。具体的修改逻辑代码解读如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Add a flush to this &#123;<span class="hljs-doctag">@link</span> ChannelOutboundBuffer&#125;. This means all previous added messages are marked as flushed</span><br><span class="hljs-comment"> * and so you will be able to handle them.</span><br><span class="hljs-comment"> * 将前面所有的消息标识为flushed。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//io.netty.channel.ChannelOutboundBuffer#addFlush</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFlush</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// There is no need to process all entries if there was already a flush before and no new messages</span><br>    <span class="hljs-comment">// where added in the meantime.</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// See https://github.com/netty/netty/issues/2577</span><br>    <span class="hljs-comment">// </span><br> 	<span class="hljs-comment">// 获取当前未flush的第一个entry</span><br>    Entry entry = unflushedEntry;<br>    <span class="hljs-keyword">if</span> (entry != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (flushedEntry == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// there is no flushedEntry yet, so start with the entry</span><br>            <span class="hljs-comment">// 如果当前flushedEntry指针没有指向任何数据，指向未flush的第一个entry</span><br>            flushedEntry = entry;<br>        &#125;<br>        <span class="hljs-comment">// 从unflushedEntry开始循环设置，将这些全部设置不可取消（uncancel）状态，全部加入到flushed链表中。</span><br>        <span class="hljs-keyword">do</span> &#123;<br>            flushed ++;<br>            <span class="hljs-keyword">if</span> (!entry.promise.setUncancellable()) &#123;<br>                <span class="hljs-comment">// 设置失败是因为当前entry已经是取消状态的了</span><br>                <span class="hljs-comment">// Was cancelled so make sure we free up memory and notify about the freed bytes</span><br>                <span class="hljs-keyword">int</span> pending = entry.cancel();<br>                <span class="hljs-comment">// 返回当前entry的size并调用下面方法进行释放对应的大小，</span><br>                <span class="hljs-comment">// 如果缓存总数据的大小小于低水位，触发fireChannelWritabilityChanged事件</span><br>                decrementPendingOutboundBytes(pending, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);<br>            &#125;<br>            <span class="hljs-comment">// 继续下一个entry</span><br>            entry = entry.next;<br>        &#125; <span class="hljs-keyword">while</span> (entry != <span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">// All flushed so reset unflushedEntry</span><br>        <span class="hljs-comment">//因为所有的entry都被加入到flushed链表中，所以设置unflushedEntry设置为null。</span><br>        <span class="hljs-comment">// 下一次添加数据时，unflushedEntry为最先添加的entry。</span><br>        unflushedEntry = <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在调用完addFlush()方法之后，channelOutboundBuffer的链表结构如下图：</p>
<p><img src="https://raw.githubusercontent.com/realDaiwei/image/master/20220223003515.png" srcset="/img/loading.gif"></p>
<p>在addFlush()之后，调用<code>doWrite(ChannelOutboundBuffer in)</code>将数据写入到socket中。但是这里需要注意一个细节，ChannelOutboundBuffer并不会直接被写入到socket中。而是会转化为nio的ByteBuffer数组，然后写入到socket中。在doWrite()方法中调用<strong>ChannelOutboundBuffer#nioBuffers(int, long)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.channel.ChannelOutboundBuffer#nioBuffers(int, long)</span><br><span class="hljs-comment">// 在发送数据时需要把ChannelOutboundBuffer中的msg转换成ByteBuffer</span><br><span class="hljs-keyword">public</span> ByteBuffer[] nioBuffers(<span class="hljs-keyword">int</span> maxCount, <span class="hljs-keyword">long</span> maxBytes) &#123;<br>    <span class="hljs-keyword">assert</span> maxCount &gt; <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">assert</span> maxBytes &gt; <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">long</span> nioBufferSize = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> nioBufferCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">final</span> InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.get();<br>    <span class="hljs-comment">// 从线程本地缓存中获取ByteBuffer数组</span><br>    ByteBuffer[] nioBuffers = NIO_BUFFERS.get(threadLocalMap);<br>    <span class="hljs-comment">// 从准备第一个写入Socket的元素开始</span><br>    Entry entry = flushedEntry;<br>    <span class="hljs-comment">//循环遍历entry，entry必须为准备写入Socket的元素且为非取消状态</span><br>    <span class="hljs-keyword">while</span> (isFlushedEntry(entry) &amp;&amp; entry.msg <span class="hljs-keyword">instanceof</span> ByteBuf) &#123;<br>        <span class="hljs-keyword">if</span> (!entry.cancelled) &#123;<br>            <span class="hljs-comment">// 获取entry节点中实际发送的数据</span><br>            ByteBuf buf = (ByteBuf) entry.msg;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> readerIndex = buf.readerIndex();<br>            <span class="hljs-comment">// 获取可发送字节数</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> readableBytes = buf.writerIndex() - readerIndex;<br>			<span class="hljs-comment">// 若可发送字节数 &gt; 0 时，否则跳过</span><br>            <span class="hljs-keyword">if</span> (readableBytes &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 累计发送字节不能大于maxBytes</span><br>                <span class="hljs-keyword">if</span> (maxBytes - readableBytes &lt; nioBufferSize &amp;&amp; nioBufferCount != <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// If the nioBufferSize + readableBytes will overflow maxBytes, and there is at least one entry</span><br>                    <span class="hljs-comment">// we stop populate the ByteBuffer array. This is done for 2 reasons:</span><br>                    <span class="hljs-comment">// 1. bsd/osx don&#x27;t allow to write more bytes then Integer.MAX_VALUE with one writev(...) call</span><br>                    <span class="hljs-comment">// and so will return &#x27;EINVAL&#x27;, which will raise an IOException. On Linux it may work depending</span><br>                    <span class="hljs-comment">// on the architecture and kernel but to be safe we also enforce the limit here.</span><br>                    <span class="hljs-comment">// 2. There is no sense in putting more data in the array than is likely to be accepted by the</span><br>                    <span class="hljs-comment">// OS.</span><br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-comment">// See also:</span><br>                    <span class="hljs-comment">// - https://www.freebsd.org/cgi/man.cgi?query=write&amp;sektion=2</span><br>                    <span class="hljs-comment">// - https://linux.die.net//man/2/writev</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 累计发送字节数</span><br>                nioBufferSize += readableBytes;<br>                <span class="hljs-comment">// 获取entry中byteBuffer的个数</span><br>                <span class="hljs-keyword">int</span> count = entry.count;<br>                <span class="hljs-keyword">if</span> (count == -<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-comment">//noinspection ConstantValueVariableUse</span><br>                    entry.count = count = buf.nioBufferCount();<br>                &#125;<br>                <span class="hljs-comment">// 需要多少个byteBuffer</span><br>                <span class="hljs-keyword">int</span> neededSpace = min(maxCount, nioBufferCount + count);<br>                <span class="hljs-comment">// nioBuffers长度不够，需要扩容。</span><br>                <span class="hljs-keyword">if</span> (neededSpace &gt; nioBuffers.length) &#123;<br>                    nioBuffers = expandNioBufferArray(nioBuffers, neededSpace, nioBufferCount);<br>                    NIO_BUFFERS.set(threadLocalMap, nioBuffers);<br>                &#125;<br>                <span class="hljs-comment">// 如果ByteBuffer的个数为1，则直接获取ByteBuffer并放入nioBuffers数组中。</span><br>                <span class="hljs-keyword">if</span> (count == <span class="hljs-number">1</span>) &#123;<br>                    ByteBuffer nioBuf = entry.buf;<br>                    <span class="hljs-keyword">if</span> (nioBuf == <span class="hljs-keyword">null</span>) &#123;<br>                        <span class="hljs-comment">// cache ByteBuffer as it may need to create a new ByteBuffer instance if its a</span><br>                        <span class="hljs-comment">// derived buffer</span><br>                        entry.buf = nioBuf = buf.internalNioBuffer(readerIndex, readableBytes);<br>                    &#125;<br>                    nioBuffers[nioBufferCount++] = nioBuf;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 如果有多个循环获取ByteBuffer放入nioBuffers数组中。</span><br>                    <span class="hljs-comment">// The code exists in an extra method to ensure the method is not too big to inline as this</span><br>                    <span class="hljs-comment">// branch is not very likely to get hit very frequently.</span><br>                    nioBufferCount = nioBuffers(entry, buf, nioBuffers, nioBufferCount, maxCount);<br>                &#125;<br>                <span class="hljs-comment">// 不能超过最大个数限制</span><br>                <span class="hljs-keyword">if</span> (nioBufferCount &gt;= maxCount) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 获取下一个节点</span><br>        entry = entry.next;<br>    &#125;<br>    <span class="hljs-keyword">this</span>.nioBufferCount = nioBufferCount;<br>    <span class="hljs-keyword">this</span>.nioBufferSize = nioBufferSize;<br><br>    <span class="hljs-keyword">return</span> nioBuffers;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过<strong>nioBuffers()方法获取到需要发送的ByteBuffer数组，然后通过SocketChannel写到网络中，并返回写成功了多少个字节</strong>，此时ChannelOutboudBuffer需要把<strong>这些字节从链表中移除</strong>，<strong>同时需要把刚刚生成的ByteBuffer数组也一起移除</strong>，下面继续看removeByte()与remove()方法的解读：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Removes the fully written entries and update the reader index of the partially written entry.</span><br><span class="hljs-comment"> * This operation assumes all messages in this buffer is &#123;<span class="hljs-doctag">@link</span> ByteBuf&#125;.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//io.netty.channel.ChannelOutboundBuffer#removeBytes</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeBytes</span><span class="hljs-params">(<span class="hljs-keyword">long</span> writtenBytes)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// 与nioBuffers()方法一样，从准备写入socket的节点开始获取此节点的buf数据</span><br>        Object msg = current();<br>        <span class="hljs-keyword">if</span> (!(msg <span class="hljs-keyword">instanceof</span> ByteBuf)) &#123;<br>            <span class="hljs-keyword">assert</span> writtenBytes == <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">final</span> ByteBuf buf = (ByteBuf) msg;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> readerIndex = buf.readerIndex();<br>        <span class="hljs-comment">// 获取buf可发送字节数</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> readableBytes = buf.writerIndex() - readerIndex;<br>	<br>        <span class="hljs-comment">//如果当前节点字节数小于或等于已发送的字节数，则直接删除整个节点，更新进度progress(writtenBytes);</span><br>        <span class="hljs-comment">// remove()也就是将entry从链表中移除。</span><br>        <span class="hljs-keyword">if</span> (readableBytes &lt;= writtenBytes) &#123;<br>            <span class="hljs-keyword">if</span> (writtenBytes != <span class="hljs-number">0</span>) &#123;<br>                progress(readableBytes);<br>                writtenBytes -= readableBytes;<br>            &#125;<br>            remove();<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// readableBytes &gt; writtenBytes</span><br>            <span class="hljs-comment">// 若当前节点还有一部分未发送，则缩小当前节点的可发送字节长度。</span><br>            <span class="hljs-keyword">if</span> (writtenBytes != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 修改readerIndex并更新进度</span><br>                buf.readerIndex(readerIndex + (<span class="hljs-keyword">int</span>) writtenBytes);<br>                progress(writtenBytes);<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 由于每次在发送时，都需要从线程本地缓存中取出byteBuffer数组，</span><br>    <span class="hljs-comment">// 并且每次拿到的数组都应该是干净的（无数据），因此这里清空它。</span><br>    clearNioBuffers();<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.ChannelOutboundBuffer#clearNioBuffers</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clearNioBuffers</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> count = nioBufferCount;<br>    <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>        nioBufferCount = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 填入null对象</span><br>        Arrays.fill(NIO_BUFFERS.get(), <span class="hljs-number">0</span>, count, <span class="hljs-keyword">null</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.ChannelOutboundBuffer#remove()</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 与nioBuffers()、removeBytes() 方法一样。</span><br>    Entry e = flushedEntry;<br>    <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>) &#123;<br>        clearNioBuffers();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    Object msg = e.msg;<br><br>    ChannelPromise promise = e.promise;<br>    <span class="hljs-keyword">int</span> size = e.pendingSize;<br>	<span class="hljs-comment">// 从链表中移除此entry，同时将flushedEntry指针指向下一个节点</span><br>    removeEntry(e);<br><br>    <span class="hljs-keyword">if</span> (!e.cancelled) &#123;<br>        <span class="hljs-comment">// entry在uncancel的状态下执行到了这里。</span><br>        <span class="hljs-comment">// only release message, notify and decrement if it was not canceled before.</span><br>        <span class="hljs-comment">// entry数据已经写入到socket发送出去了，释放内存空间。</span><br>        ReferenceCountUtil.safeRelease(msg);<br>        <span class="hljs-comment">// 通知处理成功</span><br>        safeSuccess(promise);<br>        <span class="hljs-comment">// 减少当前outbundBuffer中数据对应的大小。</span><br>        decrementPendingOutboundBytes(size, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// recycle the entry</span><br>    <span class="hljs-comment">// 回收entry对象并放回对象池。</span><br>    e.recycle();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.ChannelOutboundBuffer#removeEntry</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeEntry</span><span class="hljs-params">(Entry e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (-- flushed == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 若最后的节点也被移除了，则所有指针都是null</span><br>        <span class="hljs-comment">// processed everything</span><br>        flushedEntry = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span> (e == tailEntry) &#123;<br>            tailEntry = <span class="hljs-keyword">null</span>;<br>            unflushedEntry = <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        flushedEntry = e.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>所以通过上面源码的分析，在entry数据被写入到socket中，会被移除出链表，移除的方式也非常简单，flushedEntry指针指向后一个entry即可，即如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/realDaiwei/image/master/20220224004003.png" srcset="/img/loading.gif"></p>
<p>到这里对channelOutboundBuffer的分析梳理也就结束了，channelOutboundBuffer会将msg封装成一个个entry，并组成一个链表结构，通过三个指针来标识出刷新和待刷新的部分，调用addMessage()方法可以将msg加入链表也就是write最后的操作。<strong>调用flush方法，将链表中的所有元素全部由unflushed状态转变为flushed</strong>，然后<strong>调用doWrite方法将flushed的entry写入到socket中，发送完成后移除对应的entry释放空间。</strong></p>
<h3 id="另一个小细节-—-Netty背压处理与自适应写"><a href="#另一个小细节-—-Netty背压处理与自适应写" class="headerlink" title="另一个小细节  — Netty背压处理与自适应写"></a>另一个小细节  — Netty背压处理与自适应写</h3><p>在看源码的过程中发现，我还看到了两个有意思的小细节。在看部分之前，我们先思考前面我们提到的那个问题“为了提高网络的吞吐量，在调用write时，数据并没有直接被写到Socket中，而是被写到了Netty的缓冲区（channelOutboudBuffer）中，在并发很高的情况下，在对方接收数据比较慢时，Netty的写缓冲区如何防止内存溢出，防止出现大量内存无法释放的情况？”buffer空间不是无限的，如果写入socket的发送速率&gt;写入buffer的速率那么内存一定会溢出。换个角度思考问题，如果当达到了某个阈值提醒生产方停止往buffer中写入数据是不是就可以了呢？这就是背压机制。</p>
<blockquote>
<p>背压是指在<strong>异步场景中，被观察者发送事件速度远快于观察者的处理速度的情况下，一种告诉上游的被观察者降低发送速度的策略。</strong></p>
<p>简单来说，<strong>背压就是一种流控策略。</strong></p>
</blockquote>
<p>我们其实在前面的梳理中有接触过背压，也就是我们TCP的流控策略。通过当前滑动窗口大小来控制发送速率，来处理发送端的发送速率和接收端处理速率不匹配的问题。</p>
<p>那Netty背压是怎么处理的呢？换句话说netty是怎么通上游来降低写入速率的呢？通过方法<code>incrementPendingOutboundBytes(long, boolean)</code>和方法<code>decrementPendingOutboundBytes(long, boolean, boolean)</code>来配合触发对应的<code>fireChannelWritabilityChanged</code>事件来通知上游pipeline中的handler。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这个方法在将msg加入channelOutboundBuffer之后调用</span><br><span class="hljs-comment">//io.netty.channel.ChannelOutboundBuffer#incrementPendingOutboundBytes(long, boolean)</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">incrementPendingOutboundBytes</span><span class="hljs-params">(<span class="hljs-keyword">long</span> size, <span class="hljs-keyword">boolean</span> invokeLater)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>	<br>    <span class="hljs-comment">// CAS加上并获取当前的channelOutboundBufffer的大小</span><br>    <span class="hljs-keyword">long</span> newWriteBufferSize = TOTAL_PENDING_SIZE_UPDATER.addAndGet(<span class="hljs-keyword">this</span>, size);<br>    <span class="hljs-comment">// 如果当前buffer的size 大于 channel配置的高水位</span><br>    <span class="hljs-keyword">if</span> (newWriteBufferSize &gt; channel.config().getWriteBufferHighWaterMark()) &#123;<br>        <span class="hljs-comment">// 触发channel不可写</span><br>        setUnwritable(invokeLater);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.ChannelOutboundBuffer#setUnwritable</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUnwritable</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> invokeLater)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> oldValue = unwritable;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> newValue = oldValue | <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// CAS设置不可写状态为1， 如果设置成功对应的channel的abstractChannel#isWritable为false</span><br>        <span class="hljs-keyword">if</span> (UNWRITABLE_UPDATER.compareAndSet(<span class="hljs-keyword">this</span>, oldValue, newValue)) &#123;<br>            <span class="hljs-keyword">if</span> (oldValue == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 如果本次操作将值由0设置成1，调用fireChannelWritabilityChanged方法。</span><br>                fireChannelWritabilityChanged(invokeLater);<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 当数据写入socket之后调用这个方法，释放channelOutboundBuffer的内存</span><br><span class="hljs-comment">//io.netty.channel.ChannelOutboundBuffer#decrementPendingOutboundBytes(long, boolean, boolean)</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrementPendingOutboundBytes</span><span class="hljs-params">(<span class="hljs-keyword">long</span> size, <span class="hljs-keyword">boolean</span> invokeLater, <span class="hljs-keyword">boolean</span> notifyWritability)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>	<br>    <span class="hljs-comment">// CAS减去size并获取当前channelOutboundBuffer的大小</span><br>    <span class="hljs-keyword">long</span> newWriteBufferSize = TOTAL_PENDING_SIZE_UPDATER.addAndGet(<span class="hljs-keyword">this</span>, -size);<br>    <span class="hljs-comment">// 如果当前设置notifyWritability == true 并且当前channelOutboundBuffer的大小 &lt; channel配置的低水位</span><br>    <span class="hljs-keyword">if</span> (notifyWritability &amp;&amp; newWriteBufferSize &lt; channel.config().getWriteBufferLowWaterMark()) &#123;<br>        <span class="hljs-comment">// 设置channel可写</span><br>        setWritable(invokeLater);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 设置当前通道可写</span><br><span class="hljs-comment">//io.netty.channel.ChannelOutboundBuffer#setWritable</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWritable</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> invokeLater)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> oldValue = unwritable;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> newValue = oldValue &amp; ~<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// CAS设置当前不可写状态为0，如果设置成功对应的channel的abstractChannel#isWritable为true</span><br>        <span class="hljs-keyword">if</span> (UNWRITABLE_UPDATER.compareAndSet(<span class="hljs-keyword">this</span>, oldValue, newValue)) &#123;<br>            <span class="hljs-keyword">if</span> (oldValue != <span class="hljs-number">0</span> &amp;&amp; newValue == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 如果本次操作将值从1设置成0，调用fireChannelWritabilityChanged方法。</span><br>                fireChannelWritabilityChanged(invokeLater);<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 触发pipeline的channelWriteabilityChanged事件</span><br><span class="hljs-comment">//io.netty.channel.ChannelOutboundBuffer#fireChannelWritabilityChanged</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fireChannelWritabilityChanged</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> invokeLater)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ChannelPipeline pipeline = channel.pipeline();<br>    <span class="hljs-comment">// 是否要稍后调用</span><br>    <span class="hljs-keyword">if</span> (invokeLater) &#123;<br>        <span class="hljs-comment">// 如果稍后调用，包装一个task丢入eventLoop的task队列中</span><br>        Runnable task = fireChannelWritabilityChangedTask;<br>        <span class="hljs-keyword">if</span> (task == <span class="hljs-keyword">null</span>) &#123;<br>            fireChannelWritabilityChangedTask = task = <span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    pipeline.fireChannelWritabilityChanged();<br>                &#125;<br>            &#125;;<br>        &#125;<br>        channel.eventLoop().execute(task);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 否则直接调用触发方法。</span><br>        pipeline.fireChannelWritabilityChanged();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在看这段逻辑的时候，我发现我们平时写代码中并没有对背压事件进行特别的处理，如果有需要调整发送速率或是做出响应的动作，重写inboundHandler的<code>channelWritabilityChanged</code>方法即可，同时<strong>对应channel的abstractChannel#isWritable为true。</strong>通过方法<code>incrementPendingOutboundBytes(long, boolean)</code>和<code>decrementPendingOutboundBytes(long, boolean, boolean)</code>来可以写入buffer的速率和写入socket发送速率不匹配的问题。那么如何才能保证我们当前的发送速率达到当前的最佳速率呢？也就是netty是如何自动调整发送数据的速率，让channel尽可能多的发送数据的呢？这里不得不提到Netty的自适应写。我们先看下面这些代码片段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取最大可写入字节数</span><br><span class="hljs-keyword">int</span> maxBytesPerGatheringWrite = ((NioSocketChannelConfig) config).getMaxBytesPerGatheringWrite();<br>ByteBuffer[] nioBuffers = in.nioBuffers(<span class="hljs-number">1024</span>, maxBytesPerGatheringWrite);<br><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> maxBytesPerGatheringWrite = Integer.MAX_VALUE;<br><span class="hljs-comment">//io.netty.channel.socket.nio.NioSocketChannel.NioSocketChannelConfig#NioSocketChannelConfig</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">NioSocketChannelConfig</span><span class="hljs-params">(NioSocketChannel channel, Socket javaSocket)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(channel, javaSocket);<br>    <span class="hljs-comment">// 计算最大可写字节数</span><br>    calculateMaxBytesPerGatheringWrite();<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.socket.nio.NioSocketChannel.NioSocketChannelConfig#calculateMaxBytesPerGatheringWrite</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">calculateMaxBytesPerGatheringWrite</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Multiply by 2 to give some extra space in case the OS can process write data faster than we can provide.</span><br>    <span class="hljs-comment">// 最大可写字节数设置为sendBufferSize * 2，乘以2可以留出一些额外的空间，以防操作系统处理写数据的速度比我们提供的快</span><br>    <span class="hljs-keyword">int</span> newSendBufferSize = getSendBufferSize() &lt;&lt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (newSendBufferSize &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 设置最大可写字节数。</span><br>        setMaxBytesPerGatheringWrite(newSendBufferSize);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.socket.nio.NioSocketChannel#doWrite中的代码片段</span><br><span class="hljs-keyword">default</span>: &#123;<br>    <span class="hljs-comment">// Zero length buffers are not added to nioBuffers by ChannelOutboundBuffer, so there is no need</span><br>    <span class="hljs-comment">// to check if the total size of all the buffers is non-zero.</span><br>    <span class="hljs-comment">// We limit the max amount to int above so cast is safe</span><br>    <span class="hljs-keyword">long</span> attemptedBytes = in.nioBufferSize();<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> localWrittenBytes = ch.write(nioBuffers, <span class="hljs-number">0</span>, nioBufferCnt);<br>    <span class="hljs-keyword">if</span> (localWrittenBytes &lt;= <span class="hljs-number">0</span>) &#123;<br>        incompleteWrite(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// Casting to int is safe because we limit the total amount of data in the nioBuffers to int above.</span><br>    <span class="hljs-comment">// 根据实际写入的数据量来调整最大可写字节数</span><br>    adjustMaxBytesPerGatheringWrite((<span class="hljs-keyword">int</span>) attemptedBytes, (<span class="hljs-keyword">int</span>) localWrittenBytes,<br>                                    maxBytesPerGatheringWrite);<br>    in.removeBytes(localWrittenBytes);<br>    --writeSpinCount;<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-comment">// io.netty.channel.socket.nio.NioSocketChannel#adjustMaxBytesPerGatheringWrite</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">adjustMaxBytesPerGatheringWrite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> attempted, <span class="hljs-keyword">int</span> written, <span class="hljs-keyword">int</span> oldMaxBytesPerGatheringWrite)</span> </span>&#123;<br>    <span class="hljs-comment">// By default we track the SO_SNDBUF when ever it is explicitly set. However some OSes may dynamically change</span><br>    <span class="hljs-comment">// SO_SNDBUF (and other characteristics that determine how much data can be written at once) so we should try</span><br>    <span class="hljs-comment">// make a best effort to adjust as OS behavior changes.</span><br>    <span class="hljs-comment">// 判断是否所有字节都写入socket中发送</span><br>    <span class="hljs-keyword">if</span> (attempted == written) &#123;<br>        <span class="hljs-comment">//如果本次写入所有字节数都写入socket中</span><br>        <span class="hljs-keyword">if</span> (attempted &lt;&lt; <span class="hljs-number">1</span> &gt; oldMaxBytesPerGatheringWrite) &#123;<br>            <span class="hljs-comment">// 写入字节数 * 2 大于设置的可以写入的最大字节数，则更新可写入最大字节数为写入字节数 * 2</span><br>            ((NioSocketChannelConfig) config).setMaxBytesPerGatheringWrite(attempted &lt;&lt; <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (attempted &gt; MAX_BYTES_PER_GATHERING_WRITE_ATTEMPTED_LOW_THRESHOLD &amp;&amp; written &lt; attempted &gt;&gt;&gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 本次写入并不是所有字节都写入socket中</span><br>        <span class="hljs-comment">// 那么如果尝试写入的字节数比最大可写入字节的的最小阈值(可以理解为最小的写入最大值上限)，并且写入的值小于尝试写入字节数/2</span><br>        <span class="hljs-comment">// 将最大可写入字节数 / 2，按照写入时的网络情况，设置的最大可写入字节数仍然大于实际可写入字节数，</span><br>        <span class="hljs-comment">// 即使降低最大可写字节数仍然可以充分利用网络资源。</span><br>        ((NioSocketChannelConfig) config).setMaxBytesPerGatheringWrite(attempted &gt;&gt;&gt; <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过当前socket写入情况，<strong>Netty动态调整当前可写入的最大字节数，充分利用网络资源发送尽可能多数据</strong>。</p>
<blockquote>
<p>写到这里，我突然发现这个场景很像我们小时候做过的一道题的背景，一个水池一个管子进水一个管子出水。需要怎么做去保证这个池子的水在不溢出的情况下，将水通过池子高效的转移。</p>
<p>调控进水的管子，不能因为进水速度太快从而导致池子水溢出。同时又要尽可能加快池子排出水的速度，不让水长时间停留在池子里。</p>
<p>对进水管的调控策略就是背压机制，而对于出水管的策略就是自适应写。</p>
</blockquote>
<p>这里还有一个细节的点要注意。前面我们提到一个问题“调用flush方法之后，数据一定会被立刻发送出去么？”答案是否定的。从下面的代码片段我们可以发现，<code>doWrite</code>方法中循环写入socket中的逻辑最多执行<code>writeSpinCount</code>次（writeSpinCount的默认值是16）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.channel.socket.nio.NioSocketChannel#doWrite</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doWrite</span><span class="hljs-params">(ChannelOutboundBuffer in)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    SocketChannel ch = javaChannel();<br>    <span class="hljs-keyword">int</span> writeSpinCount = config().getWriteSpinCount();<br>    <span class="hljs-keyword">do</span> &#123;<br>        ... write to socekt logical ...<br>        --writeSpinCount;<br>        ... write to socekt logical ...<br>    &#125; <span class="hljs-keyword">while</span> (writeSpinCount &gt; <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 未完成的写操作</span><br>    incompleteWrite(writeSpinCount &lt; <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.nio.AbstractNioByteChannel#incompleteWrite</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">incompleteWrite</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> setOpWrite)</span> </span>&#123;<br>    <span class="hljs-comment">// Did not write completely.</span><br>    <span class="hljs-keyword">if</span> (setOpWrite) &#123;<br>        <span class="hljs-comment">// 设置OP_WRITE事件。</span><br>        setOpWrite();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// It is possible that we have set the write OP, woken up by NIO because the socket is writable, and then</span><br>        <span class="hljs-comment">// use our write quantum. In this case we no longer want to set the write OP because the socket is still</span><br>        <span class="hljs-comment">// writable (as far as we know). We will find out next time we attempt to write if the socket is writable</span><br>        <span class="hljs-comment">// and set the write OP if necessary.</span><br>        <span class="hljs-comment">// 清空OP_WRITE事件标识</span><br>        clearOpWrite();<br><br>        <span class="hljs-comment">// Schedule flush again later so other tasks can be picked up in the meantime</span><br>        <span class="hljs-comment">// 使用eventLoop的task方式执行后续写操作。</span><br>        eventLoop().execute(flushTask);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果循环16次之后，依旧没有完成所有的写操作，那么此时<code>writeSpinCount == 0</code>即调用<code>incompleteWrite(false);</code>清空OP_WRITE事件标识并将flushTask放入eventLoop的TaskQueue继续执行。<strong>这部分数据并不会第一时间写出去，增加服务响应时延。</strong></p>
<blockquote>
<p>当看到这里我又想到一个问题，什么场景下才会设置NIO的SelectionKey监听OP_WRITE事件呢？</p>
<p>OP_WRITE代表socket buffer可写，当写入socket时返回值小于写入的字节长度甚至为0的时候，代表socket buffer中有数据积压，这个时候应该取消监听read时间，注册write事件，待所有数据写入完毕，取消write事件监听，重新注册read事件监听。</p>
<p>OP_WRITE事件只要buffer没有写满就可以一直触发可写事件，所以直接注册OP_WRITE而不取消会导致CPU跑满。在没有数据需要写的时候就应该及时取消OP_WRITE事件监听。</p>
</blockquote>
<h3 id="OP-READ事件写操作源码逻辑小结"><a href="#OP-READ事件写操作源码逻辑小结" class="headerlink" title="OP_READ事件写操作源码逻辑小结"></a>OP_READ事件写操作源码逻辑小结</h3><p>这个部分我们接上OP_READ读操作的逻辑继续分析OP_READ写操作。将数据从server端写出去需要调用write和flush这两个方法，他们都是outboundHandler的方法。从调用过程的逻辑角度来看，他们都是从方法发起调用的handler（echoServerHandler）开始沿着pipeline中的channelHandler从后向前发起调用。在wirte方法调用过程中，我们自定义的MessageToByteEncoder编码器的write方法会被调用，这里的逻辑就是简单的模版方法最终会调用子类实现的encode方法，将Object对象通过自定义编码器转变成byteBuf字节码数据。当write方法调用到最后一个write方法的handler(HeadContext)进行简单的校验后，将msg转变成entry加入到channelOutBoundBuffer中。channelOutboundBuffer中是一个链表的结构，通过unflushEntry，flushedEntry和tailEntry这三个指针标识出未被flush和被flush的entry。write操作会将msg加入到unflushedEntry链表中，调用flush方法之后会把所有unflushEntry中的元素加入到flushedEntry中。当这些数据被写入到socket中之后，再将调用removeEntry方法将这些空间全部释放掉即可。在写数据的细节上，为了防止channelOutboundBuffer溢出，netty设计了简单的背压机制。为了保证socket通道能充分利用带宽资源，netty设计了自适应写操作。这些都是一些很有意思的点。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到这里我们完成了Netty流程源码的剖析，原本是准备一个小节完成启动流程和读写操作的源码剖析的。在自己看源码的过程中真的收获了很多的东西，在之前我是很抗拒看源码的，通过这次的流程源码分析真的很喜欢看源码，点亮了源码阅读的技能树，加深了自己对Netty更加深层次的理解。同时还学到了很多优秀的设计，在今后的业务开发中也多了一个思考的纬度。上一个小节我们详细剖析了Netty服务是怎么启动的，这个小节我们深入剖析，Netty服务是如何处理读写请求的。Netty的抽象真的非常的优秀，随着代码的调用，就像是一支笔一样不断的在描绘着主从Reactor的设计模型，不断加深我对主从Reactor模型的理解。下一个小节我们继续我们对Netty的剖析，看看Netty优秀的内存管理策略～</p>
<h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><ul>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/anlian523/article/details/105020210">Java NIO 注册事件的正确姿势 以及对attach()的理解</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://book.douban.com/subject/35246428/">Netty源码剖析与应用</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/455625954">JAVA NIO SelectionKey 中 OP_WRITE 事件存在的意义？</a></p>
</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/NIO%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">NIO与网络编程</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Java%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84%E6%A2%B3%E7%90%86/">Java知识结构梳理</a>
                    
                      <a class="hover-with-bg" href="/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">学习总结</a>
                    
                      <a class="hover-with-bg" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
                    
                      <a class="hover-with-bg" href="/tags/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">源码剖析</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/02/17/netty-source-code-start-server/">
                        <span class="hidden-mobile">Netty流程剖析 — 服务启动源码剖析</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
