

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/blogFavicon.png">
  <link rel="icon" href="/img/blogFavicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  
    <meta name="description" content="">
  
  <meta name="author" content="Daiwei">
  <meta name="keywords" content="">
  
  <title>Netty流程剖析 — 服务启动源码剖析 - Daiwei‘s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.8","typing":{"enable":true,"typeSpeed":100,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Daiwei's blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://gitee.com/realDaiwei/img/raw/master/paul-winwar-qapoK-nSX_E-unsplash.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Netty流程剖析 — 服务启动源码剖析">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-02-17 23:44" pubdate>
        2022年2月17日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      15.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      75
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Netty流程剖析 — 服务启动源码剖析</h1>
            
            <div class="markdown-body">
              <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面几个小节，我们梳理了几个核心组建，深入的分析了这几个组建的工作原理和一些实现细节，但是细看局部总是难以获得一个全局的视角，很难把它们真正的串起来。在梳理完这几个组件之后，我最想知道的就是启动的时候和读写操作的时候，这几个组件是怎么配合工作。虽然我也看过一切流程图，和一些简单的总结，但是自己没有深入过源码总感觉缺了点什么。我相信只有真正分析调试过源码才能真正理解，各个组件之间是怎么协作的，各个组件之间的设计要点是什么了。带着这些疑惑，我深入了源码也收获颇丰。这个部分，我们将对Netty的启动过程进行深入的分析，看看Netty是如何进行注册、绑定和监听。</p>
<h1 id="NIO服务器的基本设计思路"><a href="#NIO服务器的基本设计思路" class="headerlink" title="NIO服务器的基本设计思路"></a>NIO服务器的基本设计思路</h1><p>我们知道Netty也是一套高性能网络框架，Netty底层有对各种IO模型的支持，包括BIO、NIO和后来的AIO（只是Netty对于AIO的尝试是一个悲伤的故事），最终Netty选择基于NIO模型来实现。在深入Netty的启动流程之前，我们先眼熟几个NIO中比较重要的类/组件：</p>
<ul>
<li><p><code>Selector</code>：多路复用器，是NIO的一个核心组件，在BIO中是没有的，主要用于监听NIO Channel的各种事件，并检查一个或者多个通道是否处于可读/写状态。在实现单条线程管理多条链路时候，<strong>传统的BIO管理多条链路是通过多线程上下文切换来实现的</strong>，而NIO有了Selector之后，一个Selector只需要用一个线程就可以轮询处理多个链路通道。</p>
</li>
<li><p><code>ServerSocketChannel</code>：与普通BIO中的ServerSocket一样，主要<strong>用来监听新加入的TCP连接通道</strong>，而且其启动方式与ServerSocket的启动方式也非常类似，<strong>只需要在开启端口监听之前，把ServerSocketChannel注册到Selector上，并设置OP_ACCEPT事件即可</strong>。</p>
</li>
<li><p><code>SocketChannel</code>：与普通BIO中的Socket一样，是连接到TCP网络Socket上的Channel。它的创建方式有两种：一种方式与ServerSocketChannel的创建方式类似，<strong>打开一个SocketChannel，这种方式主要用于客户端主动连接器</strong>；<strong>另一种方式是当有客户端连接器ServerSocketChannel上时，会创建一个SocketChannel。</strong></p>
</li>
</ul>
<p>NIO服务设计设计主要分为三步：第一步，服务器启动与端口监听；第二步，ServerSocketChannel 处理新接入链路；第三步，SocketChannel 读/写数据。</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20220113230430.png" srcset="/img/loading.gif"></p>
<h1 id="Server端服务启动源码分析"><a href="#Server端服务启动源码分析" class="headerlink" title="Server端服务启动源码分析"></a>Server端服务启动源码分析</h1><p> Netty服务的过程和上面的NIO服务器的启动的核心部分并没有多大的区别，同样是要创建Selector，不过Netty会使用额外的线程去创建，也需要打开ServerSocketChannel，只不过采用了NIOServerSocketChannel 来进行包装实现，同样也需要把ServerSocketChannel注册到Selector上，这一步Netty也是使用NioEventLoop来实现，并返回ChannelPromise来异步通知是否注册成功。Netty的启动分三步走，<code>register(注册)</code>、<code>bind(绑定)</code>、<code>active(激活)</code>。在后续的源码分析中，我们也将整个启动流程拆分成这三个阶段来帮助源码的分析和理解，以及看看启动是如何把我们前面的几个模块串接起来的。在开始分析启动流程之前，我们先再次过一下我们熟悉的服务端启动代码和Server启动类<code>ServerBootstrap</code>。</p>
<h2 id="鸟瞰全局与ServerBootstrap"><a href="#鸟瞰全局与ServerBootstrap" class="headerlink" title="鸟瞰全局与ServerBootstrap"></a>鸟瞰全局与ServerBootstrap</h2><p>这里我们分析的启动类是<code>EchoServer</code>，这是一个<code>io.netty.example</code>中的一个example，因为它足够简单，也方便我们对启动类信息分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.example.echo.EchoServer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoServer</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> SSL = System.getProperty(<span class="hljs-string">&quot;ssl&quot;</span>) != <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PORT = Integer.parseInt(System.getProperty(<span class="hljs-string">&quot;port&quot;</span>, <span class="hljs-string">&quot;8007&quot;</span>));<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// Configure SSL.</span><br>        <span class="hljs-keyword">final</span> SslContext sslCtx;<br>        <span class="hljs-keyword">if</span> (SSL) &#123;<br>            SelfSignedCertificate ssc = <span class="hljs-keyword">new</span> SelfSignedCertificate();<br>            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            sslCtx = <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 核心配置代码从这里开始</span><br>        <span class="hljs-comment">// Configure the server.</span><br>        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);<br>        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <br>        <span class="hljs-keyword">final</span> EchoServerHandler serverHandler = <span class="hljs-keyword">new</span> EchoServerHandler();<br>        <span class="hljs-keyword">try</span> &#123;<br>            ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();<br>            b.group(bossGroup, workerGroup)<br>             .channel(NioServerSocketChannel.class)<br>             .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">100</span>)<br>             .handler(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.INFO))<br>             .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                 <span class="hljs-meta">@Override</span><br>                 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                     ChannelPipeline p = ch.pipeline();<br>                     <span class="hljs-keyword">if</span> (sslCtx != <span class="hljs-keyword">null</span>) &#123;<br>                         p.addLast(sslCtx.newHandler(ch.alloc()));<br>                     &#125;<br>                     <span class="hljs-comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span><br>                     p.addLast(serverHandler);<br>                 &#125;<br>             &#125;);<br><br>            <span class="hljs-comment">// Start the server.</span><br>            ChannelFuture f = b.bind(PORT).sync();<br><br>            <span class="hljs-comment">// Wait until the server socket is closed.</span><br>            f.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// Shut down all event loops to terminate all threads.</span><br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面的代码我们不难看出，我们梳理过的一些核心组件都是通过<code>ServerBootstrap</code>组合在一起，其中<code>group()</code>方法关联主从EventLoop，<code>channel()</code>指定bossGroup中的负责监听的channel。<code>option()</code>方法可以指定一些参数，<code>handler()</code>则是启动过程中的一些处理事件。后面的<code>childHandler()</code>则是具读写事件的channel已经<code>channelPipline</code>处理链的一些配置，最后一个重要的方法是<code>bind()</code>在上面所有的配置完成之后，<code>bind()</code>方法将拉起整个Netty服务。下面我们来深入<code>ServerBootstrap</code>的细节。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//用于保存 childChannel 中的一些配置</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; childOptions = <span class="hljs-keyword">new</span> LinkedHashMap&lt;ChannelOption&lt;?&gt;, Object&gt;();<br><span class="hljs-comment">// 用于保存 childChannel 中的一些属性</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; childAttrs = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;AttributeKey&lt;?&gt;, Object&gt;();<br><span class="hljs-comment">// 一个包裹当前ServerBootstrap的包装对象。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServerBootstrapConfig config = <span class="hljs-keyword">new</span> ServerBootstrapConfig(<span class="hljs-keyword">this</span>);<br><span class="hljs-comment">// 主从reactor模型中的 workerEventLoopGroup</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> EventLoopGroup childGroup;<br><span class="hljs-comment">// childHandler 也就是上面配置过程中的 ChannelInitializer</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> ChannelHandler childHandler;<br></code></pre></td></tr></table></figure>

<p>在ServerBootstrap中还有一个内部类对象<code>ServerBootstrapAcceptor</code>，这个对象在启动过程终会被加入到BossGroup的channel的Pipline中，<strong>作为Pipeline的最后一个处理器用于监听连接事件</strong>，它继承了<code>ChannelInboundHandlerAdapter</code>是一个InBoundhandler。这个类可以理解发挥着<code>承上启下</code>的功能，从他的名字<code>Acceptor</code>也不难看出它是用于监听<code>OP_ACCEPT</code>连接事件，当Accept事件发生后会触发<code>channelRead</code>方法，将childChannel注册到 childGroup （即我们创建 workerGroup）进行具体的读写操作。这个会在Netty就绪事件处理的部分进行详细分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerBootstrapAcceptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EventLoopGroup childGroup;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChannelHandler childHandler;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] childOptions;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] childAttrs;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Runnable enableAutoReadTask;<br><br>    ServerBootstrapAcceptor(<br>        <span class="hljs-keyword">final</span> Channel channel, EventLoopGroup childGroup, ChannelHandler childHandler,<br>        Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] childOptions, Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] childAttrs) &#123;<br>        <span class="hljs-keyword">this</span>.childGroup = childGroup;<br>        <span class="hljs-keyword">this</span>.childHandler = childHandler;<br>        <span class="hljs-keyword">this</span>.childOptions = childOptions;<br>        <span class="hljs-keyword">this</span>.childAttrs = childAttrs;<br><br>        <span class="hljs-comment">// Task which is scheduled to re-enable auto-read.</span><br>        <span class="hljs-comment">// It&#x27;s important to create this Runnable before we try to submit it as otherwise the URLClassLoader may</span><br>        <span class="hljs-comment">// not be able to load the class because of the file limit it already reached.</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// See https://github.com/netty/netty/issues/1328</span><br>        enableAutoReadTask = <span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                channel.config().setAutoRead(<span class="hljs-keyword">true</span>);<br>            &#125;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> Channel child = (Channel) msg;<br><br>        child.pipeline().addLast(childHandler);<br><br>        setChannelOptions(child, childOptions, logger);<br>        setAttributes(child, childAttrs);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            childGroup.register(child).addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    <span class="hljs-keyword">if</span> (!future.isSuccess()) &#123;<br>                        forceClose(child, future.cause());<br>                    &#125;<br>                &#125;<br>            &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            forceClose(child, t);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">forceClose</span><span class="hljs-params">(Channel child, Throwable t)</span> </span>&#123;<br>        child.unsafe().closeForcibly();<br>        logger.warn(<span class="hljs-string">&quot;Failed to register an accepted channel: &#123;&#125;&quot;</span>, child, t);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">final</span> ChannelConfig config = ctx.channel().config();<br>        <span class="hljs-keyword">if</span> (config.isAutoRead()) &#123;<br>            <span class="hljs-comment">// stop accept new connections for 1 second to allow the channel to recover</span><br>            <span class="hljs-comment">// See https://github.com/netty/netty/issues/1328</span><br>            config.setAutoRead(<span class="hljs-keyword">false</span>);<br>            ctx.channel().eventLoop().schedule(enableAutoReadTask, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>        &#125;<br>        <span class="hljs-comment">// still let the exceptionCaught event flow through the pipeline to give the user</span><br>        <span class="hljs-comment">// a chance to do something with it</span><br>        ctx.fireExceptionCaught(cause);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>ServerBootstrap 中还有一个需要我们注意的重要的方法<code>init()</code>，这个方法在后续整个启动流程的注册和启动部分会被调用。这个方法整体来说非常简单，需要注意的点是后半部分，将配置的handler加入到ServerSocketChannel 的 pipleline的这部分代码，这部分代码和我们构建ServerBootstrap时候写childHandler初始化的代码类似。这里在ServerSocketChannel中加入一个channel初始化的Handler即<code>ChannelInitializer</code>，在这个初始化过程中，又将我们构造ServerBootstrap时添加的LoggingHandler加入pipeline。最后包装创建的Accptor（ServerBootstrapAcceptor）对象加入到Pipeline中。但是加入的方式有一些特殊，并<strong>不是直接由当前执行线程直接加入，而是包装成一个EventLoop的task，等待后续的BossGroup的EventLoop进行执行。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.bootstrap.ServerBootstrap#init</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(Channel channel)</span> </span>&#123;<br>    setChannelOptions(channel, newOptionsArray(), logger);<br>    setAttributes(channel, newAttributesArray());<br><br>    ChannelPipeline p = channel.pipeline();<br><br>    <span class="hljs-keyword">final</span> EventLoopGroup currentChildGroup = childGroup;<br>    <span class="hljs-keyword">final</span> ChannelHandler currentChildHandler = childHandler;<br>    <span class="hljs-keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions = newOptionsArray(childOptions);<br>    <span class="hljs-keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs = newAttributesArray(childAttrs);<br><br>    <span class="hljs-comment">// 将我们配置LoggerHandler加入到NioServerSocketChannel的Pipeline中，</span><br>    <span class="hljs-comment">// 并最后加入ServerBootstrapAcceptor</span><br>    p.addLast(<span class="hljs-keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Channel ch)</span> </span>&#123;<br>            <span class="hljs-keyword">final</span> ChannelPipeline pipeline = ch.pipeline();<br>            ChannelHandler handler = config.handler();<br>            <span class="hljs-keyword">if</span> (handler != <span class="hljs-keyword">null</span>) &#123;<br>                pipeline.addLast(handler);<br>            &#125;<br><br>            ch.eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    pipeline.addLast(<span class="hljs-keyword">new</span> ServerBootstrapAcceptor(<br>                        ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>看完上面的一些逻辑后，我们对于ServerBootstrap也有了一个大致的了解，接下来我们将从bind方法开始，具体看看Netty的启动是怎么样的，看看Netty是如何一步步的完成<code>register</code>、<code>bind</code>、<code>active</code>这几步操作的。在分析源码之前先提出两个两个问题，我们可以带着这两个问题去看源码；</p>
<blockquote>
<p>NioServerSocketChannel的Handle管道DefaultChannelPipeline是如何添加Handler并触发各种事件的？</p>
<p>在服务启动的过程中，register、bind、active操作是通过EventLoopTask的形式执行的，那他们是如何保证有序的？</p>
</blockquote>
<p>接下来我们就来从<code>ServerBootstrap</code>的<code>bind()</code>方法开始分析Netty的启动流程源码。</p>
<h2 id="initAndRegister（初始化与注册）部分剖析"><a href="#initAndRegister（初始化与注册）部分剖析" class="headerlink" title="initAndRegister（初始化与注册）部分剖析"></a>initAndRegister（初始化与注册）部分剖析</h2><p>这个部分我们要关注的主体方法<code>initAndRegister()</code>，这个方法会返回一个ChannelFuture(一个包着Channel的Future，因为这个channel在bind部分需要用)。在这个大方法中我们将完成通过反射创建在配置中预先设置的channel的NioServerSocketChannel实例对象，再调用<code>SelectableChannel</code>的<code>register()</code>方法注册到NioEventLoop的Selector上，并返回对应的<code>selectionKey</code>。完成注册之后，再调用DefaultChannelPipeline的<code>callHandlerAddedForAllHandlers()</code>方法，将<code>ServerBootstrapAcceptor</code>和一些<strong>自定义的handler加入到NioServerSocketChannel的pipleline。</strong></p>
<blockquote>
<p>这里要注意⚠️，这里的pipleline还只是NioServerSocketChannel的pipleline。</p>
</blockquote>
<p>完成了这一步的操作之后，设置初始化完成和注册操作的主体就已经完成了，接下来将future设置为成功，并执行future中设置的监听器，也就是拉起我们的下一步bind操作。bind操作则是加入到eventLoop的下一个task。在完成bind方法的链接之后，我们的eventLoop线程（是的，这个时候已经不是主线程在操作了，而是eventLoop线程了）将沿着我们的NioServerSocketChannel的pipleline挨个执行InboundHandler的<code>channelRegistered()</code>方法。当这个方法执行完成之后，我们的initAndRegister部分就执行结束了。所以通过上面的简单介绍，我们对initAndRegister有一个大致的印象了，主要有一下几个部分。</p>
<blockquote>
<p>不用着急，下面我们会深入源码一步步走一遍。</p>
</blockquote>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20220118002010.png" srcset="/img/loading.gif"></p>
<h3 id="深入bind-方法"><a href="#深入bind-方法" class="headerlink" title="深入bind()方法"></a>深入bind()方法</h3><p>以下我们从bind方法开始这一部分的源码分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.bootstrap.AbstractBootstrap#bind(int)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> inetPort)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> bind(<span class="hljs-keyword">new</span> InetSocketAddress(inetPort));<br>&#125;<br><br><span class="hljs-comment">//io.netty.bootstrap.AbstractBootstrap#bind(java.net.SocketAddress)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title">bind</span><span class="hljs-params">(SocketAddress localAddress)</span> </span>&#123;<br>    validate();<br>    <span class="hljs-keyword">return</span> doBind(ObjectUtil.checkNotNull(localAddress, <span class="hljs-string">&quot;localAddress&quot;</span>));<br>&#125;<br><br><span class="hljs-comment">// 以上都是两个bind重载方法，以下进行到真正的bind方法。</span><br><span class="hljs-comment">//io.netty.bootstrap.AbstractBootstrap#doBind</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> ChannelFuture <span class="hljs-title">doBind</span><span class="hljs-params">(<span class="hljs-keyword">final</span> SocketAddress localAddress)</span> </span>&#123;<br>    <span class="hljs-comment">//前面提到的initAndRegister方法，初始化channel并完成handle的注册操作</span><br>    <span class="hljs-comment">// 返回一个包着channel的future对象。</span><br>    <span class="hljs-keyword">final</span> ChannelFuture regFuture = initAndRegister();<br>    <span class="hljs-keyword">final</span> Channel channel = regFuture.channel();<br>    <span class="hljs-keyword">if</span> (regFuture.cause() != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> regFuture;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果主线执行到这里异步执行的initAndRegister已经执行完成了，直接调用doBind0()方法，</span><br>    <span class="hljs-comment">// 否则使用channelFuture添加监听器，在完成之后执行doBind0()方法。</span><br>    <span class="hljs-keyword">if</span> (regFuture.isDone()) &#123;<br>        <span class="hljs-comment">// At this point we know that the registration was complete and successful.</span><br>        ChannelPromise promise = channel.newPromise();<br>        doBind0(regFuture, channel, localAddress, promise);<br>        <span class="hljs-keyword">return</span> promise;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Registration future is almost always fulfilled already, but just in case it&#x27;s not.</span><br>        <span class="hljs-keyword">final</span> PendingRegistrationPromise promise = <span class="hljs-keyword">new</span> PendingRegistrationPromise(channel);<br>        regFuture.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                Throwable cause = future.cause();<br>                <span class="hljs-keyword">if</span> (cause != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span><br>                    <span class="hljs-comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span><br>                    promise.setFailure(cause);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// Registration was successful, so set the correct executor to use.</span><br>                    <span class="hljs-comment">// See https://github.com/netty/netty/issues/2586</span><br>                    promise.registered();<br><br>                    doBind0(regFuture, channel, localAddress, promise);<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">return</span> promise;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面这部分我们从bind()方法入手，再经过多次调用重载方法之后，我们看到这个初始化与注册阶段的核心方法调用<code>initAndRegister</code>。initAndRegister是一个异步方法，返回一个ChannelFuture对象。在这个调用完成之后，拉起doBind0()方法执行端口绑定操作。以下是<code>initAndRegister()</code>方法的源码剖析。</p>
<h3 id="initAndRegister-方法剖析"><a href="#initAndRegister-方法剖析" class="headerlink" title="initAndRegister()方法剖析"></a>initAndRegister()方法剖析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始化注册</span><br><span class="hljs-comment">//io.netty.bootstrap.AbstractBootstrap#initAndRegister</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">initAndRegister</span><span class="hljs-params">()</span> </span>&#123;<br>    Channel channel = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 通过channelFactory创建一个channel，这里channelFactory，初始化ServerBootstrap调用channel()时创建的，</span><br>        <span class="hljs-comment">// channelFactory.newChannel()构建出channel()方法入参的实例，即NioServerSocketChannel实例。</span><br>        channel = channelFactory.newChannel();<br><br>        <span class="hljs-comment">// 初始化channel，这个初始化上面我们分析过，这里就不深入了。</span><br>        <span class="hljs-comment">// 里面的大致逻辑是，将ServerBootstrap的handler传入的handler对象加入到channel的pipleline，</span><br>        <span class="hljs-comment">// 并创建一个eventloop的任务将 ServerBootstrapAcceptor 加入到pipleline最后。</span><br>        init(channel);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-comment">// 异常处理</span><br>        <span class="hljs-keyword">if</span> (channel != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// channel can be null if newChannel crashed (eg SocketException(&quot;too many open files&quot;))</span><br>            channel.unsafe().closeForcibly();<br>            <span class="hljs-comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);<br>        &#125;<br>        <span class="hljs-comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultChannelPromise(<span class="hljs-keyword">new</span> FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);<br>    &#125;<br><br>    <span class="hljs-comment">// channel注册并返回 ChannelFuture</span><br>    <span class="hljs-comment">// 这里调用io.netty.channel.SingleThreadEventLoop#register(io.netty.channel.Channel)</span><br>    ChannelFuture regFuture = config().group().register(channel);<br>    <span class="hljs-keyword">if</span> (regFuture.cause() != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 如果发生了异常关闭channel</span><br>        <span class="hljs-keyword">if</span> (channel.isRegistered()) &#123;<br>            channel.close();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            channel.unsafe().closeForcibly();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// If we are here and the promise is not failed, it&#x27;s one of the following cases:</span><br>    <span class="hljs-comment">// 1) If we attempted registration from the event loop, the registration has been completed at this point.</span><br>    <span class="hljs-comment">//    i.e. It&#x27;s safe to attempt bind() or connect() now because the channel has been registered.</span><br>    <span class="hljs-comment">// 2) If we attempted registration from the other thread, the registration request has been successfully</span><br>    <span class="hljs-comment">//    added to the event loop&#x27;s task queue for later execution.</span><br>    <span class="hljs-comment">//    i.e. It&#x27;s safe to attempt bind() or connect() now:</span><br>    <span class="hljs-comment">//         because bind() or connect() will be executed *after* the scheduled registration task is executed</span><br>    <span class="hljs-comment">//         because register(), bind(), and connect() are all bound to the same thread.</span><br><br>    <span class="hljs-keyword">return</span> regFuture;<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.SingleThreadEventLoop#register(io.netty.channel.Channel)</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title">register</span><span class="hljs-params">(Channel channel)</span> </span>&#123;<br>    <span class="hljs-comment">// 方法重载调用 io.netty.channel.SingleThreadEventLoop#register(io.netty.channel.ChannelPromise)</span><br>    <span class="hljs-keyword">return</span> register(<span class="hljs-keyword">new</span> DefaultChannelPromise(channel, <span class="hljs-keyword">this</span>));<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.SingleThreadEventLoop#register(io.netty.channel.ChannelPromise)</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title">register</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;<br>    ObjectUtil.checkNotNull(promise, <span class="hljs-string">&quot;promise&quot;</span>);<br>    <span class="hljs-comment">// 最终执行的注册方法为channel的unsafe类中的注册方法。</span><br>    <span class="hljs-comment">// 也就是io.netty.channel.AbstractChannel.AbstractUnsafe#register </span><br>    promise.channel().unsafe().register(<span class="hljs-keyword">this</span>, promise);<br>    <span class="hljs-keyword">return</span> promise;<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.AbstractChannel.AbstractUnsafe#register</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(EventLoop eventLoop, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;<br>    ObjectUtil.checkNotNull(eventLoop, <span class="hljs-string">&quot;eventLoop&quot;</span>);<br>    <span class="hljs-keyword">if</span> (isRegistered()) &#123;<br>        <span class="hljs-comment">// 如果已经注册过了</span><br>        promise.setFailure(<span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;registered to an event loop already&quot;</span>));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!isCompatible(eventLoop)) &#123;<br>        promise.setFailure(<br>            <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;incompatible event loop type: &quot;</span> + eventLoop.getClass().getName()));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    AbstractChannel.<span class="hljs-keyword">this</span>.eventLoop = eventLoop;<br><br>    <span class="hljs-keyword">if</span> (eventLoop.inEventLoop()) &#123;<br>        <span class="hljs-comment">// 如果当前线程是EventLoop，直接调用注册方法。</span><br>        register0(promise);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 将注册动作加入到eventLoop的Task中</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            eventLoop.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    register0(promise);<br>                &#125;<br>            &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            logger.warn(<br>                <span class="hljs-string">&quot;Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;&quot;</span>,<br>                AbstractChannel.<span class="hljs-keyword">this</span>, t);<br>            closeForcibly();<br>            closeFuture.setClosed();<br>            safeSetFailure(promise, t);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 注册主方法，这个方法里面完成了注册操作的主要逻辑</span><br><span class="hljs-comment">//io.netty.channel.AbstractChannel.AbstractUnsafe#register0</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register0</span><span class="hljs-params">(ChannelPromise promise)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// check if the channel is still open as it could be closed in the mean time when the register</span><br>        <span class="hljs-comment">// call was outside of the eventLoop</span><br>        <span class="hljs-keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">boolean</span> firstRegistration = neverRegistered;<br>        <span class="hljs-comment">// 将channel注册到selector上，并设置类局部变量selectionKey</span><br>        doRegister();<br>        neverRegistered = <span class="hljs-keyword">false</span>;<br>        registered = <span class="hljs-keyword">true</span>;<br><br>        <span class="hljs-comment">// Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the</span><br>        <span class="hljs-comment">// user may already fire events through the pipeline in the ChannelFutureListener.</span><br>        <br>        <span class="hljs-comment">// 下面这个方法将handler加入到pipeline中。这里是NioServerChannel的pipeline</span><br>        pipeline.invokeHandlerAddedIfNeeded();<br>        <span class="hljs-comment">// 将异步的promise设置成功，并调用promise中添加的Listener监听器。</span><br>        safeSetSuccess(promise);<br>        <span class="hljs-comment">// 调用依次调用pipleline中inBoundhandler的channelRegistered()方法。</span><br>        pipeline.fireChannelRegistered();<br>        <span class="hljs-comment">// Only fire a channelActive if the channel has never been registered. This prevents firing</span><br>        <span class="hljs-comment">// multiple channel actives if the channel is deregistered and re-registered.</span><br>        <br>        <span class="hljs-comment">// 如果channel已经被打开，并且已经绑定端口，完成下面的操作，否则方法结束。</span><br>        <span class="hljs-comment">// 这个方法在我们后面的源码代码分析中会经常见到。</span><br>        <span class="hljs-keyword">if</span> (isActive()) &#123;<br>            <span class="hljs-keyword">if</span> (firstRegistration) &#123;<br>                <span class="hljs-comment">// 第一次注册要依次调用触发</span><br>                pipeline.fireChannelActive();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (config().isAutoRead()) &#123;<br>                <span class="hljs-comment">// 如果开启了自动读，直接开始监听accept事件。</span><br>                <span class="hljs-comment">// This channel was registered before and autoRead() is set. This means we need to begin read</span><br>                <span class="hljs-comment">// again so that we process inbound data.</span><br>                <span class="hljs-comment">//</span><br>                <span class="hljs-comment">// See https://github.com/netty/netty/issues/4805</span><br>                beginRead();<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-comment">// Close the channel directly to avoid FD leak.</span><br>        closeForcibly();<br>        closeFuture.setClosed();<br>        safeSetFailure(promise, t);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// NioChannel的注册方法，将channel注册到selector上，并返回selectionKey。</span><br><span class="hljs-comment">//io.netty.channel.nio.AbstractNioChannel#doRegister</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doRegister</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">boolean</span> selected = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException e) &#123;<br>            <span class="hljs-keyword">if</span> (!selected) &#123;<br>                <span class="hljs-comment">// Force the Selector to select now as the &quot;canceled&quot; SelectionKey may still be</span><br>                <span class="hljs-comment">// cached and not removed because no Select.select(..) operation was called yet.</span><br>                eventLoop().selectNow();<br>                selected = <span class="hljs-keyword">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// We forced a select operation on the selector before but the SelectionKey is still cached</span><br>                <span class="hljs-comment">// for whatever reason. JDK bug ?</span><br>                <span class="hljs-keyword">throw</span> e;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个部分我们深入<code>initAndRegister</code>源码，这部分的源码逻辑也像方法名 initAndRegister，完成了serverBootstrap的init操作，随后就是register 方法，也就是随后将channel注册到selector上。（这个register 方法也包了好几层，最后是在AbstractUnsafe中实现了这个register方法，没错又是unsafe方法。）在注册完成后，调用<code>invokeHandlerAddedIfNeeded</code>将handler加入到channel的pipeline中，然后调用<code>safeSetSuccess(promise)</code>设promise操作成功，调用promise中设置的listener方法。在将handler加入到pipeline之后，调用<code>pipeline.fireChannelRegistered()</code>顺着pipeline调用inboundHandler的<code>channelRegistered()</code>，最后调用<code>isActive()</code>校验下是否channel是否已经开启并且已经绑定端口，正常情况下到这里都是没有isActive的结果都是false的。接下来，我们深入看看那<code>invokeHandlerAddedIfNeeded</code>、<code>safeSetSuccess(promise)</code>和<code>pipeline.fireChannelRegistered()</code>深入剖析下这些方法底层的实现细节。</p>
<h3 id="invokeHandlerAddedIfNeeded-方法剖析"><a href="#invokeHandlerAddedIfNeeded-方法剖析" class="headerlink" title="invokeHandlerAddedIfNeeded() 方法剖析"></a>invokeHandlerAddedIfNeeded() 方法剖析</h3><p>在initAndRegister这部分分析的开始我们提到了两个问题，其中第一个问题是“NioServerSocketChannel的Handle管道DefaultChannelPipeline是如何添加Handler并触发各种事件的？”，而<code>invokeHandlerAddedIfNeeded()</code>就是将ServerBootstrap中初始化的handler加入到Channel的Pipeline中。接下来我们一起来看看吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.channel.DefaultChannelPipeline#invokeHandlerAddedIfNeeded</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeHandlerAddedIfNeeded</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 简单的校当前是否是eventloop线程，执行到这，当前一定是eventloop线程。</span><br>    <span class="hljs-keyword">assert</span> channel.eventLoop().inEventLoop();<br>    <span class="hljs-comment">// 是否是第一次注册。</span><br>    <span class="hljs-keyword">if</span> (firstRegistration) &#123;<br>        firstRegistration = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-comment">// We are now registered to the EventLoop. It&#x27;s time to call the callbacks for the ChannelHandlers,</span><br>        <span class="hljs-comment">// that were added before the registration was done.</span><br>        <span class="hljs-comment">// 调用真正实现添加handler到pipeline的方法。</span><br>        callHandlerAddedForAllHandlers();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.DefaultChannelPipeline#callHandlerAddedForAllHandlers</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callHandlerAddedForAllHandlers</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// PendingHandlerCallback 这个类的功能类似于一个触发器，本质上是一个链表结构。</span><br>    <span class="hljs-comment">// 链表中的元素会在callHandlerCallbackLater()中被添加，</span><br>    <span class="hljs-comment">// 而方法 callHandlerCallbackLater()会在pipeline.addLast()中被调用。</span><br>    <span class="hljs-keyword">final</span> PendingHandlerCallback pendingHandlerCallbackHead;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        <span class="hljs-comment">// 这里锁操作，确保只能被注册一次。</span><br>        <span class="hljs-keyword">assert</span> !registered;<br><br>        <span class="hljs-comment">// This Channel itself was registered.</span><br>        <span class="hljs-comment">// 将 register 设置为true，这个会影响后面代码的逻辑，在后面的initAndRegister部分会多次出现。</span><br>        registered = <span class="hljs-keyword">true</span>;<br><br>        <span class="hljs-comment">// 将类局部变量赋值给方法变量，方便GC回收。</span><br>        pendingHandlerCallbackHead = <span class="hljs-keyword">this</span>.pendingHandlerCallbackHead;<br>        <span class="hljs-comment">// Null out so it can be GC&#x27;ed.</span><br>        <span class="hljs-keyword">this</span>.pendingHandlerCallbackHead = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// This must happen outside of the synchronized(...) block as otherwise handlerAdded(...) may be called while</span><br>    <span class="hljs-comment">// holding the lock and so produce a deadlock if handlerAdded(...) will try to add another handler from outside</span><br>    <span class="hljs-comment">// the EventLoop.</span><br>    PendingHandlerCallback task = pendingHandlerCallbackHead;<br>    <span class="hljs-keyword">while</span> (task != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 循环执行依次执行链表中每个callBackTask的execute方法。</span><br>        task.execute();<br>        task = task.next;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.DefaultChannelPipeline#callHandlerCallbackLater</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callHandlerCallbackLater</span><span class="hljs-params">(AbstractChannelHandlerContext ctx, <span class="hljs-keyword">boolean</span> added)</span> </span>&#123;<br>    <span class="hljs-keyword">assert</span> !registered;<br><br>    <span class="hljs-comment">// 创建得到一个PendingHandlerAddedTask，这个是DefaultChannelPipeline的一个内部类。</span><br>    PendingHandlerCallback task = added ? <span class="hljs-keyword">new</span> PendingHandlerAddedTask(ctx) : <span class="hljs-keyword">new</span> PendingHandlerRemovedTask(ctx);<br>    PendingHandlerCallback pending = pendingHandlerCallbackHead;<br>    <span class="hljs-keyword">if</span> (pending == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">//因为PendingHandlerCallback这个对象本身是一个链表结构，这里的操作是设置头</span><br>        pendingHandlerCallbackHead = task;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Find the tail of the linked-list.</span><br>        <span class="hljs-comment">// 循环找到链表的末尾元素并加入到最后。</span><br>        <span class="hljs-keyword">while</span> (pending.next != <span class="hljs-keyword">null</span>) &#123;<br>            pending = pending.next;<br>        &#125;<br>        pending.next = task;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 这个类是DefaultChannelPipeline的一个内部类。</span><br><span class="hljs-comment">// io.netty.channel.DefaultChannelPipeline.PendingHandlerAddedTask</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PendingHandlerAddedTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PendingHandlerCallback</span> </span>&#123;<br>	<br>    PendingHandlerAddedTask(AbstractChannelHandlerContext ctx) &#123;<br>        <span class="hljs-keyword">super</span>(ctx);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        callHandlerAdded0(ctx);<br>    &#125;<br><br>    <span class="hljs-comment">// 从这个方法就不难看出，这只是一个handler添加的触发器，作为PendingHandlerCallback链表结构的头元素，</span><br>    <span class="hljs-comment">//拉起整个pipleline中handler的添加。</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;<br>        EventExecutor executor = ctx.executor();<br>        <span class="hljs-comment">// 这里的代码结构就不深入了，本质上还是使用eventLoop去调用callHandlerAdded0()方法</span><br>        <span class="hljs-keyword">if</span> (executor.inEventLoop()) &#123;<br>            callHandlerAdded0(ctx);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                executor.execute(<span class="hljs-keyword">this</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException e) &#123;<br>                <span class="hljs-keyword">if</span> (logger.isWarnEnabled()) &#123;<br>                    logger.warn(<br>                        <span class="hljs-string">&quot;Can&#x27;t invoke handlerAdded() as the EventExecutor &#123;&#125; rejected it, removing handler &#123;&#125;.&quot;</span>,<br>                        executor, ctx.name(), e);<br>                &#125;<br>                atomicRemoveFromHandlerList(ctx);<br>                ctx.setRemoved();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.DefaultChannelPipeline#callHandlerAdded0</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callHandlerAdded0</span><span class="hljs-params">(<span class="hljs-keyword">final</span> AbstractChannelHandlerContext ctx)</span> </span>&#123;<br>     <span class="hljs-comment">// 这个方法也只是包了一层, 真正处理逻辑的是ctx.callHandlerAdded()，这个方法。</span><br>    <span class="hljs-comment">// 进到方法里面看handler调用自己的handlerAdded方法。</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        ctx.callHandlerAdded();<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-comment">// 如果发生了异常，执行handler的remove操作。</span><br>        <span class="hljs-keyword">boolean</span> removed = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            atomicRemoveFromHandlerList(ctx);<br>            ctx.callHandlerRemoved();<br>            removed = <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t2) &#123;<br>            <span class="hljs-keyword">if</span> (logger.isWarnEnabled()) &#123;<br>                logger.warn(<span class="hljs-string">&quot;Failed to remove a handler: &quot;</span> + ctx.name(), t2);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//设置异常</span><br>        <span class="hljs-keyword">if</span> (removed) &#123;<br>            fireExceptionCaught(<span class="hljs-keyword">new</span> ChannelPipelineException(<br>                ctx.handler().getClass().getName() +<br>                <span class="hljs-string">&quot;.handlerAdded() has thrown an exception; removed.&quot;</span>, t));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            fireExceptionCaught(<span class="hljs-keyword">new</span> ChannelPipelineException(<br>                ctx.handler().getClass().getName() +<br>                <span class="hljs-string">&quot;.handlerAdded() has thrown an exception; also failed to remove.&quot;</span>, t));<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.AbstractChannelHandlerContext#callHandlerAdded</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callHandlerAdded</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">// We must call setAddComplete before calling handlerAdded. Otherwise if the handlerAdded method generates</span><br>    <span class="hljs-comment">// any pipeline events ctx.handler() will miss them because the state will not allow it.</span><br>    <br>    <span class="hljs-comment">// 调用添加handler方法。</span><br>    <span class="hljs-keyword">if</span> (setAddComplete()) &#123;<br>        handler().handlerAdded(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面这半段逻辑是<code>invokeHandlerAddedIfNeeded()</code>方法的前半段。这个部分我们看到在方法内部调用了<code>callHandlerAddedForAllHandlers</code>方法，这个方法是拉起channel的pipeline中handlerAdded的主要方法，这个方法里面我们重点关注了一个类<code>PendingHandlerCallback</code>，这个类<strong>本质上是一个链表结构的类</strong>，在第一次调用<code>pipeline.addLast()</code>的时候会包装一个handler进去作为链表的头，并将add的handler添加到链表的最后。并且每次调用<code>pipeline.addLast()</code>如果此时还没完成注册，就会在这个链表的最后添加handler。回到我们的<code>callHandlerAddedForAllHandlers</code>方法，在拿到了<code>PendingHandlerCallback</code>之后，我们顺着链表依次执行<code>callHandlerAdded0</code>方法即ChannelHandler调用自己的<code>handlerAdded()</code>方法。</p>
<blockquote>
<p>理解这一段需要结合源码反复品。</p>
</blockquote>
<p>那么我的问题来，我们前面提到了<code>PendingHandlerCallback</code>是一个链表结构，我们会依次沿着这个链表初始化ChannelHandler，那么第一次执行到这里的handler()，具体是哪个对象呢？换一个角度问这个问题，这个链表结构中，第一个被加入的handler是什么呢，第一次调用<code>pipeline.addLast()</code>被加的handler是哪个实例呢？其实这个实例是<code>ChannelInitializer</code>，channel初始化的handler。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 第一次添加到pipeline中是在我们一开始bind方法中，</span><br><span class="hljs-comment">// 调用的serverBootstrap里面调用的init方法。</span><br><span class="hljs-comment">//io.netty.bootstrap.ServerBootstrap#init</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(Channel channel)</span> </span>&#123;<br>    setChannelOptions(channel, newOptionsArray(), logger);<br>    setAttributes(channel, newAttributesArray());<br><br>    ChannelPipeline p = channel.pipeline();<br><br>    <span class="hljs-keyword">final</span> EventLoopGroup currentChildGroup = childGroup;<br>    <span class="hljs-keyword">final</span> ChannelHandler currentChildHandler = childHandler;<br>    <span class="hljs-keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions = newOptionsArray(childOptions);<br>    <span class="hljs-keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs = newAttributesArray(childAttrs);<br><br>    p.addLast(<span class="hljs-keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Channel ch)</span> </span>&#123;<br>            <span class="hljs-keyword">final</span> ChannelPipeline pipeline = ch.pipeline();<br>            ChannelHandler handler = config.handler();<br>            <span class="hljs-keyword">if</span> (handler != <span class="hljs-keyword">null</span>) &#123;<br>                pipeline.addLast(handler);<br>            &#125;<br><br>            ch.eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    pipeline.addLast(<span class="hljs-keyword">new</span> ServerBootstrapAcceptor(<br>                        ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;);<br>&#125;<br><br><span class="hljs-comment">// 都看到这了，我们顺便来看看pipeline.addLast()里面的源码</span><br><span class="hljs-comment">//io.netty.channel.DefaultChannelPipeline#addLast(io.netty.channel.ChannelHandler...)</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">addLast</span><span class="hljs-params">(ChannelHandler... handlers)</span> </span>&#123;<br>    <span class="hljs-comment">// 原来addLast方法可以一次添加多个ChannelHandler</span><br>    <span class="hljs-keyword">return</span> addLast(<span class="hljs-keyword">null</span>, handlers);<br>&#125;<br><br><span class="hljs-comment">//再继续往下，addLast方法还需要一个executor，上面调用这个方法的时候直接给null。</span><br><span class="hljs-comment">//io.netty.channel.DefaultChannelPipeline#addLast(io.netty.util.concurrent.EventExecutorGroup, io.netty.channel.ChannelHandler...)</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">addLast</span><span class="hljs-params">(EventExecutorGroup executor, ChannelHandler... handlers)</span> </span>&#123;<br>    ObjectUtil.checkNotNull(handlers, <span class="hljs-string">&quot;handlers&quot;</span>);<br>	<span class="hljs-comment">// 循环调用将所有的handler</span><br>    <span class="hljs-keyword">for</span> (ChannelHandler h: handlers) &#123;<br>        <span class="hljs-keyword">if</span> (h == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        addLast(executor, <span class="hljs-keyword">null</span>, h);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// 真正执行addLast()操作的方法。</span><br><span class="hljs-comment">//io.netty.channel.DefaultChannelPipeline#addLast(io.netty.util.concurrent.EventExecutorGroup, java.lang.String, io.netty.channel.ChannelHandler)</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">addLast</span><span class="hljs-params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> AbstractChannelHandlerContext newCtx;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        checkMultiplicity(handler);<br>		<span class="hljs-comment">//创建一个新的DefaultChannelHandlerContext，设置eventLoopGroup和handler对象。</span><br>        newCtx = newContext(group, filterName(name, handler), handler);<br><br>        <span class="hljs-comment">// 将newContext添加到pipeline的链表的最后。</span><br>        addLast0(newCtx);<br><br>        <span class="hljs-comment">// If the registered is false it means that the channel was not registered on an eventLoop yet.</span><br>        <span class="hljs-comment">// In this case we add the context to the pipeline and add a task that will call</span><br>        <span class="hljs-comment">// ChannelHandler.handlerAdded(...) once the channel is registered.</span><br>        <span class="hljs-comment">// 如果当前，还没有注册完成，也就是还没有调用PendingHandlerCallback，</span><br>        <span class="hljs-comment">// 也就是还没有调用PendingHandlerCallback触发handler的handlerAdd方法。</span><br>        <span class="hljs-keyword">if</span> (!registered) &#123;<br>            newCtx.setAddPending();<br>            callHandlerCallbackLater(newCtx, <span class="hljs-keyword">true</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果线程不是eventLoop线程将其添加到eventLoop的Task队列执行。</span><br>        EventExecutor executor = newCtx.executor();<br>        <span class="hljs-keyword">if</span> (!executor.inEventLoop()) &#123;<br>            callHandlerAddedInEventLoop(newCtx, executor);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 执行到这里的条件是 当前是eventloop线程，并且当前已经完成了注册，直接添加并调用handlerAdd方法即可。</span><br>    callHandlerAdded0(newCtx);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>所以通过上面代码的分析，我们不难得出，<code>PendingHandlerCallback</code>这个handlerAdd方法调用链上的第一个处理器就是我们在ServerBootstrap的init()方法中的<code>ChannelInitializer</code>内部类，弄清楚了这个问题，接下来我们顺着<code>handler().handlerAdded(this);</code>方法继续往下走。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// io.netty.channel.ChannelInitializer#handlerAdded</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handlerAdded</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">if</span> (ctx.channel().isRegistered()) &#123;<br>        <span class="hljs-comment">// This should always be true with our current DefaultChannelPipeline implementation.</span><br>        <span class="hljs-comment">// The good thing about calling initChannel(...) in handlerAdded(...) is that there will be no ordering</span><br>        <span class="hljs-comment">// surprises if a ChannelInitializer will add another ChannelInitializer. This is as all handlers</span><br>        <span class="hljs-comment">// will be added in the expected order.</span><br>        <span class="hljs-comment">// 调用initChannel也就是我们在ServerBootstrap中init构造的内部类的initChannel方法。</span><br>        <span class="hljs-keyword">if</span> (initChannel(ctx)) &#123;<br><br>            <span class="hljs-comment">// We are done with init the Channel, removing the initializer now.</span><br>            removeState(ctx);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.ChannelInitializer#initChannel(io.netty.channel.ChannelHandlerContext)</span><br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">if</span> (initMap.add(ctx)) &#123; <span class="hljs-comment">// Guard against re-entrance.</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 调用执行initChannel 传入channel, 即p.addLast()内部类的initChannel方法。</span><br>            initChannel((C) ctx.channel());<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable cause) &#123;<br>            <span class="hljs-comment">// Explicitly call exceptionCaught(...) as we removed the handler before calling initChannel(...).</span><br>            <span class="hljs-comment">// We do so to prevent multiple calls to initChannel(...).</span><br>            exceptionCaught(ctx, cause);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// ChannelInitializer 初始化Handler执行完成之后，</span><br>            <span class="hljs-comment">// 将当前这个handler从pipeline中移出。</span><br>            ChannelPipeline pipeline = ctx.pipeline();<br>            <span class="hljs-keyword">if</span> (pipeline.context(<span class="hljs-keyword">this</span>) != <span class="hljs-keyword">null</span>) &#123;<br>                pipeline.remove(<span class="hljs-keyword">this</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br><br>p.addLast(<span class="hljs-keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;<br>    <br>    <span class="hljs-comment">// 在initChannel方法的逻辑中，我们先将ServerBootstrap的初始化的Handler加入到pipeline中，</span><br>    <span class="hljs-comment">// 并且最后将 ServerBootstrapAcceptor 加入到pipeline的最后，并且是以eventLoop的task的形式执行。</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Channel ch)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> ChannelPipeline pipeline = ch.pipeline();<br>        <span class="hljs-comment">// 获取到ServerBootstrap的handler，即 LoggingHandler</span><br>        ChannelHandler handler = config.handler();<br>        <span class="hljs-keyword">if</span> (handler != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//LoggerHandler加入到pipeline的最后，</span><br>            <span class="hljs-comment">//此时register为true，会直接触发handlerAdded方法。</span><br>            pipeline.addLast(handler);<br>        &#125;<br><br>        <span class="hljs-comment">// 使用eventloop的方式将ServerBootstrapAcceptor添加到task队列的最后。</span><br>        ch.eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                pipeline.addLast(<span class="hljs-keyword">new</span> ServerBootstrapAcceptor(<br>                    ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>在<code>ChannelInitializer</code>的初始化方法中，在初始化过程中，我们创建<code>LoggingHandler</code>实例也被加入到pipeline中，我们前面分析的<code>pipeline.addLast()</code>方法，会判断<code>register</code>来决定是立刻执行<code>HandlerAdded()</code>方法，还是包装成<code>PendingHandlerCallback</code>加入到链表中。在这个场景中，<code>register</code>为true，会直接执行<code>HandlerAdded()</code>，即<code>AbstractChannelHandlerContext#callHandlerAdded()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.channel.AbstractChannelHandlerContext#callHandlerAdded</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callHandlerAdded</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">// We must call setAddComplete before calling handlerAdded. Otherwise if the handlerAdded method generates</span><br>    <span class="hljs-comment">// any pipeline events ctx.handler() will miss them because the state will not allow it.</span><br>    <br>    <span class="hljs-comment">// 调用添加handler方法。</span><br>    <span class="hljs-keyword">if</span> (setAddComplete()) &#123;<br>        handler().handlerAdded(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>而此时的<code>handler()</code>则是<code>LoggingHandler</code>的实例。<code>LoggingHandler</code>并没有实现<code>handlerAdded()</code>方法，因此实际执行的是<strong>io.netty.channel.ChannelHandlerAdapter#handlerAdded()</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Do nothing by default, sub-classes may override this method.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//io.netty.channel.ChannelHandlerAdapter#handlerAdded</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handlerAdded</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">// NOOP</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>随着最后下面这段逻辑将ChannelInitializer从<code>pipeline</code>中移出去。<code>invokeHandlerAddedIfNeeded()</code>的逻辑也就结束了。当然最后还会通过 eventLoop的task的方式将<code>ServerBootstrapAcceptor</code>加入到pipeline中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">ChannelPipeline pipeline = ctx.pipeline();<br><span class="hljs-keyword">if</span> (pipeline.context(<span class="hljs-keyword">this</span>) != <span class="hljs-keyword">null</span>) &#123;<br>    pipeline.remove(<span class="hljs-keyword">this</span>);<br>&#125;<br><br>ch.eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        pipeline.addLast(<span class="hljs-keyword">new</span> ServerBootstrapAcceptor(<br>            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<h3 id="safeSetSuccess-与-fireChannelRegistered"><a href="#safeSetSuccess-与-fireChannelRegistered" class="headerlink" title="safeSetSuccess 与 fireChannelRegistered"></a>safeSetSuccess 与 fireChannelRegistered</h3><p>完成了对方法<code>invokeHandlerAddedIfNeeded()</code>的深入剖析之后，我们继续回到<code>register0()</code>方法中。在完成了<code>pipeline.invokeHandlerAddedIfNeeded();</code>的调用，Netty将调用<code>safeSetSuccess(promise);</code>将异步结果 promise 设置为成功，并且调用后续的<code>fireChannelRegistered()</code>方法，触发pipeline中的handler的<code>channelRegistered()</code>方法。最后还会判断当前是否已经激活，如果激活直接执行<code>channelActive</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.channel.AbstractChannel.AbstractUnsafe#register0</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register0</span><span class="hljs-params">(ChannelPromise promise)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// check if the channel is still open as it could be closed in the mean time when the register</span><br>        <span class="hljs-comment">// call was outside of the eventLoop</span><br>        <span class="hljs-keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">boolean</span> firstRegistration = neverRegistered;<br>        <span class="hljs-comment">// 将channel注册到selector上，并设置类局部变量selectionKey</span><br>        doRegister();<br>        neverRegistered = <span class="hljs-keyword">false</span>;<br>        registered = <span class="hljs-keyword">true</span>;<br><br>        <span class="hljs-comment">// Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the</span><br>        <span class="hljs-comment">// user may already fire events through the pipeline in the ChannelFutureListener.</span><br>        <br>        <span class="hljs-comment">// 下面这个方法将handler加入到pipeline中。这里是NioServerChannel的pipeline</span><br>        pipeline.invokeHandlerAddedIfNeeded();<br>        <span class="hljs-comment">// 将异步的promise设置成功，并调用promise中添加的Listener监听器。</span><br>        safeSetSuccess(promise);<br>        <span class="hljs-comment">// 调用依次调用pipleline中inBoundhandler的channelRegistered()方法。</span><br>        pipeline.fireChannelRegistered();<br>        <span class="hljs-comment">// Only fire a channelActive if the channel has never been registered. This prevents firing</span><br>        <span class="hljs-comment">// multiple channel actives if the channel is deregistered and re-registered.</span><br>        <br>        <span class="hljs-comment">// 如果channel已经被打开，并且已经绑定端口，完成下面的操作，否则方法结束。</span><br>        <span class="hljs-comment">// 这个方法在我们后面的源码代码分析中会经常见到。</span><br>        <span class="hljs-keyword">if</span> (isActive()) &#123;<br>            <span class="hljs-keyword">if</span> (firstRegistration) &#123;<br>                <span class="hljs-comment">// 第一次注册要依次调用触发</span><br>                pipeline.fireChannelActive();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (config().isAutoRead()) &#123;<br>                <span class="hljs-comment">// 如果开启了自动读，直接开始监听accept事件。</span><br>                <span class="hljs-comment">// This channel was registered before and autoRead() is set. This means we need to begin read</span><br>                <span class="hljs-comment">// again so that we process inbound data.</span><br>                <span class="hljs-comment">//</span><br>                <span class="hljs-comment">// See https://github.com/netty/netty/issues/4805</span><br>                beginRead();<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-comment">// Close the channel directly to avoid FD leak.</span><br>        closeForcibly();<br>        closeFuture.setClosed();<br>        safeSetFailure(promise, t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>首先我们先深入<code>safeSetSuccess(promise);</code>方法， 这个方法里面其实很简单CAS的方式设置futurePromise成功，并notify设置好的Listener监听器。下面是<code>safeSetSuccess(promise);</code>的源码剖析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.channel.AbstractChannel.AbstractUnsafe#safeSetSuccess</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">safeSetSuccess</span><span class="hljs-params">(ChannelPromise promise)</span> </span>&#123;<br>    <span class="hljs-comment">// 这里需要重点注意的方法是promise.trySuccess()</span><br>    <span class="hljs-keyword">if</span> (!(promise <span class="hljs-keyword">instanceof</span> VoidChannelPromise) &amp;&amp; !promise.trySuccess()) &#123;<br>        logger.warn(<span class="hljs-string">&quot;Failed to mark a promise as success because it is done already: &#123;&#125;&quot;</span>, promise);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.DefaultChannelPromise#trySuccess</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">trySuccess</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 调用重载方法</span><br>    <span class="hljs-keyword">return</span> trySuccess(<span class="hljs-keyword">null</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">trySuccess</span><span class="hljs-params">(V result)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> setSuccess0(result);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">setSuccess0</span><span class="hljs-params">(V result)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> setValue0(result == <span class="hljs-keyword">null</span> ? SUCCESS : result);<br>&#125;<br><br><span class="hljs-comment">//io.netty.util.concurrent.DefaultPromise#setValue0</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">setValue0</span><span class="hljs-params">(Object objResult)</span> </span>&#123;<br>    <span class="hljs-comment">// CAS操作设置Updater</span><br>    <span class="hljs-keyword">if</span> (RESULT_UPDATER.compareAndSet(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">null</span>, objResult) ||<br>        RESULT_UPDATER.compareAndSet(<span class="hljs-keyword">this</span>, UNCANCELLABLE, objResult)) &#123;<br>        <span class="hljs-comment">// checkNotifyWaiters 检查校验，是否有线程wait，如果存在调用 notifyAll，</span><br>        <span class="hljs-comment">// 并且返回 listerners != null</span><br>        <span class="hljs-keyword">if</span> (checkNotifyWaiters()) &#123;<br>            <span class="hljs-comment">// 如果当前存在Listener，调用notifyListeners，notify他们。</span><br>            notifyListeners();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br><br><span class="hljs-comment">//io.netty.util.concurrent.DefaultPromise#notifyListeners</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyListeners</span><span class="hljs-params">()</span> </span>&#123;<br>    EventExecutor executor = executor();<br>    <span class="hljs-comment">// 判断是否在 eventLoop中，如果在eventloop中直接执行。</span><br>    <span class="hljs-keyword">if</span> (executor.inEventLoop()) &#123;<br>        <span class="hljs-keyword">final</span> InternalThreadLocalMap threadLocals = InternalThreadLocalMap.get();<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> stackDepth = threadLocals.futureListenerStackDepth();<br>        <span class="hljs-comment">// 记录当前调用栈深度，如果操作最大的栈深度直接返回。</span><br>        <span class="hljs-keyword">if</span> (stackDepth &lt; MAX_LISTENER_STACK_DEPTH) &#123;<br>            <span class="hljs-comment">// 栈深度 +1</span><br>            threadLocals.setFutureListenerStackDepth(stackDepth + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//调用notifyListeners。</span><br>                notifyListenersNow();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 方法执行完成后，将调用栈深度设置回原来的值。</span><br>                threadLocals.setFutureListenerStackDepth(stackDepth);<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><br>    safeExecute(executor, <span class="hljs-keyword">new</span> Runnable() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            notifyListenersNow();<br>        &#125;<br>    &#125;);<br>&#125;<br><br><span class="hljs-comment">//io.netty.util.concurrent.DefaultPromise#notifyListenersNow</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyListenersNow</span><span class="hljs-params">()</span> </span>&#123;<br>    Object listeners;<br>    <span class="hljs-comment">// 加锁将当前需要当前需要notify的监听器取出来，而不是我们一直准备去处理监听器。</span><br>    <span class="hljs-comment">// 所以这一段的逻辑就是使用一个方法的局部变量listeners将类局部变量this.listeners</span><br>    <span class="hljs-comment">// 接出来，并将类的this.listeners设置为null。</span><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        <span class="hljs-comment">// Only proceed if there are listeners to notify and we are not already notifying listeners.</span><br>        <span class="hljs-keyword">if</span> (notifyingListeners || <span class="hljs-keyword">this</span>.listeners == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        notifyingListeners = <span class="hljs-keyword">true</span>;<br>        listeners = <span class="hljs-keyword">this</span>.listeners;<br>        <span class="hljs-keyword">this</span>.listeners = <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 循环listener执行。</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">if</span> (listeners <span class="hljs-keyword">instanceof</span> DefaultFutureListeners) &#123;<br>            notifyListeners0((DefaultFutureListeners) listeners);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            notifyListener0(<span class="hljs-keyword">this</span>, (GenericFutureListener&lt;?&gt;) listeners);<br>        &#125;<br>        <span class="hljs-comment">// 执行完成之后，在将notifyingListeners 加锁并设置为false。</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.listeners == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// Nothing can throw from within this method, so setting notifyingListeners back to false does not</span><br>                <span class="hljs-comment">// need to be in a finally block.</span><br>                notifyingListeners = <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            listeners = <span class="hljs-keyword">this</span>.listeners;<br>            <span class="hljs-keyword">this</span>.listeners = <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// DefaultFutureListeners listener的包装类，里面包了一个listener的list。</span><br><span class="hljs-comment">//io.netty.util.concurrent.DefaultPromise#notifyListeners0</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyListeners0</span><span class="hljs-params">(DefaultFutureListeners listeners)</span> </span>&#123;<br>    GenericFutureListener&lt;?&gt;[] a = listeners.listeners();<br>    <span class="hljs-keyword">int</span> size = listeners.size();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i ++) &#123;<br>        <span class="hljs-comment">// 循环调用notifyListener0即可。</span><br>        notifyListener0(<span class="hljs-keyword">this</span>, a[i]);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// notifyListener主方法，也就是调用listener中的operationComplete方法。</span><br><span class="hljs-comment">//io.netty.util.concurrent.DefaultPromise#notifyListener0</span><br> <span class="hljs-meta">@SuppressWarnings(&#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyListener0</span><span class="hljs-params">(Future future, GenericFutureListener l)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 调用operationComplete方法。</span><br>        l.operationComplete(future);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-keyword">if</span> (logger.isWarnEnabled()) &#123;<br>            logger.warn(<span class="hljs-string">&quot;An exception was thrown by &quot;</span> + l.getClass().getName() + <span class="hljs-string">&quot;.operationComplete()&quot;</span>, t);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这里完成Listener的回调，其实就是我们前面分析的拉起后续端口<code>bind</code>操作。也就是下面这段代码。如果注册的过程中没有出现异常，<code>doBind0(regFuture, channel, localAddress, promise);</code>即将bind任务加入到eventLoop的task队列中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">regFuture.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;<br>    <span class="hljs-comment">// listener监听器执行逻辑</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Throwable cause = future.cause();<br>        <span class="hljs-keyword">if</span> (cause != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span><br>            <span class="hljs-comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span><br>            promise.setFailure(cause);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Registration was successful, so set the correct executor to use.</span><br>            <span class="hljs-comment">// See https://github.com/netty/netty/issues/2586</span><br>            promise.registered();<br>			<span class="hljs-comment">// 将bind任务添加到task任务队列中。</span><br>            doBind0(regFuture, channel, localAddress, promise);<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>在核心注册方法<code>register0()</code>完成<code>safeSetSuccess(promise);</code>的调用之后，会执行<code>pipeline.fireChannelRegistered()</code>方法，这个方法的执行的操作和这个方法的名字一样，依次执行Channel的pipeline中的InboundHandler的ChannelRegistered() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.channel.DefaultChannelPipeline#fireChannelRegistered</span><br><span class="hljs-comment">// 这是DefaultChannelPipeline的fireChannelRegistered方法。</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">fireChannelRegistered</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 使用组合的方式调用HandlerContext的invokeChannelRegistered方法，这里的head</span><br>    <span class="hljs-comment">// 是pipeline的handle链的头节点。</span><br>    AbstractChannelHandlerContext.invokeChannelRegistered(head);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.AbstractChannelHandlerContext#invokeChannelRegistered(io.netty.channel.AbstractChannelHandlerContext)</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeChannelRegistered</span><span class="hljs-params">(<span class="hljs-keyword">final</span> AbstractChannelHandlerContext next)</span> </span>&#123;<br>    EventExecutor executor = next.executor();<br>    <span class="hljs-keyword">if</span> (executor.inEventLoop()) &#123;<br>       	<span class="hljs-comment">// 判断当前线程是否是eventLoop线程</span><br>        next.invokeChannelRegistered();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果不再当前线程使用eventLoop执行。</span><br>        executor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                next.invokeChannelRegistered();<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.AbstractChannelHandlerContext#invokeChannelRegistered()</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeChannelRegistered</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 判断当前handler是否调用过</span><br>    <span class="hljs-keyword">if</span> (invokeHandler()) &#123;<br>        <span class="hljs-comment">// 如果没有调用过，执行channelRegistered调用</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            ((ChannelInboundHandler) handler()).channelRegistered(<span class="hljs-keyword">this</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            invokeExceptionCaught(t);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 调用下一个ChannelRegister</span><br>        fireChannelRegistered();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.AbstractChannelHandlerContext#fireChannelRegistered</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ChannelHandlerContext <span class="hljs-title">fireChannelRegistered</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//MASK_CHANNEL_REGISTERED这是一个标志性掩码，表示某个方法一定会调用，</span><br>    <span class="hljs-comment">// MASK_CHANNEL_REGISTERED 表示REGISTERED方法的handler会被调用。</span><br>    <span class="hljs-comment">// 找到合适的handler之后，执行invokeChannelRegistered(ctx)调用。</span><br>    invokeChannelRegistered(findContextInbound(MASK_CHANNEL_REGISTERED));<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">//顺着pipeline的channelHandler的调用链通过mask掩码找到合适的Handler</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> AbstractChannelHandlerContext <span class="hljs-title">findContextInbound</span><span class="hljs-params">(<span class="hljs-keyword">int</span> mask)</span> </span>&#123;<br>    AbstractChannelHandlerContext ctx = <span class="hljs-keyword">this</span>;<br>    EventExecutor currentExecutor = executor();<br>    <span class="hljs-keyword">do</span> &#123;<br>        ctx = ctx.next;<br>    &#125; <span class="hljs-keyword">while</span> (skipContext(ctx, currentExecutor, mask, MASK_ONLY_INBOUND));<br>    <span class="hljs-keyword">return</span> ctx;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过上面这部分代码，我们就实现了顺着pipeline的channelHandler的调用链，依次执行合适的handler方法即这里的<code>MASK_CHANNEL_REGISTERED</code>所指代的<code>channelRegistered()</code>方法。到此<code>fireChannelRegistered</code>的代码执行逻辑原理我们也就分析完了。我们回到<code>register0</code>方法，简单看下主方法体的最后一段。如果此时的channel已经激活并且是第一次注册，需要调用<code>pipeline.fireChannelActive()</code>，顺着handler调用链依次执行<code>channelActive(ctx)</code>方法，其原理和<code>pipeline.fireChannelRegistered()</code>方法一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (isActive()) &#123;<br>    <span class="hljs-keyword">if</span> (firstRegistration) &#123;<br>        <span class="hljs-comment">// 第一次注册要依次调用触发</span><br>        pipeline.fireChannelActive();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (config().isAutoRead()) &#123;<br>        <span class="hljs-comment">// 如果开启了自动读，直接开始监听accept事件。</span><br>        <span class="hljs-comment">// This channel was registered before and autoRead() is set. This means we need to begin read</span><br>        <span class="hljs-comment">// again so that we process inbound data.</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// See https://github.com/netty/netty/issues/4805</span><br>        beginRead();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>到这里<code>register0</code>的分析完成，我们<code>initAndRegister</code>注册和初始化部分的源码也算是剖析完成了。按照顺序我们应该继续分析启动流程的下一个部分<code>bind</code>端口绑定部分，但是我想再中间插入一个小菜，也是我在看源码中感觉设计精妙的点，这个点就是eventloop。之前我对eventloop的理解只是简单处理连接handler逻辑的线程池结构的组件。但是在启动过程中，我又发现Netty又充分利用eventloop的task队列进行Server的拉起。在开始bind绑定部分之前，我们先一起看看eventloop在这承上启下过程中发挥的作用。</p>
<h2 id="EventLoop启动与Task任务队列"><a href="#EventLoop启动与Task任务队列" class="headerlink" title="EventLoop启动与Task任务队列"></a>EventLoop启动与Task任务队列</h2><p>EventLoop在前面的我们有详细的剖析，但是没有实际的结合执行代码来分析。这个部分我们将结合启动过程中，eventloop通过task队列将启动过程中各个部分解耦拆分的过程，来深入理解eventloop在整个启动过程中所发挥的作用。同时深入我们对eventLoop这个模块的理解。我们回到代码本身来从头看看eventLoop是什么时候参与到Netty服务的启动的。</p>
<h3 id="eventLoop的启动"><a href="#eventLoop的启动" class="headerlink" title="eventLoop的启动"></a>eventLoop的启动</h3><p>我们在整个服务中多次提到了<code>executor.inEventLoop()</code>校验，即判断当前线程是否是eventLoop线程。按照我们代码的执行顺序，第一是出现在调用<code>register0</code>方法时候，由<code>main</code>线程触发。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.channel.AbstractChannel.AbstractUnsafe#register</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(EventLoop eventLoop, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;<br>    ObjectUtil.checkNotNull(eventLoop, <span class="hljs-string">&quot;eventLoop&quot;</span>);<br>    <span class="hljs-keyword">if</span> (isRegistered()) &#123;<br>        promise.setFailure(<span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;registered to an event loop already&quot;</span>));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!isCompatible(eventLoop)) &#123;<br>        promise.setFailure(<br>            <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;incompatible event loop type: &quot;</span> + eventLoop.getClass().getName()));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    AbstractChannel.<span class="hljs-keyword">this</span>.eventLoop = eventLoop;<br><br>    <span class="hljs-comment">// 启动过程中第一次出现eventLoop.inEventLoop()校验。</span><br>    <span class="hljs-keyword">if</span> (eventLoop.inEventLoop()) &#123;<br>        register0(promise);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 在启动过程中，由main线程执行，因此走到这个分支。</span><br>            eventLoop.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    register0(promise);<br>                &#125;<br>            &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            logger.warn(<br>                <span class="hljs-string">&quot;Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;&quot;</span>,<br>                AbstractChannel.<span class="hljs-keyword">this</span>, t);<br>            closeForcibly();<br>            closeFuture.setClosed();<br>            safeSetFailure(promise, t);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>因为这里是main线程触发，所以这里会通过调用<code>eventLoop.execute(runnable)</code>方法启动已经完成初始化的eventLoop。以下是详细的源码剖析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.util.concurrent.SingleThreadEventExecutor#execute(java.lang.Runnable)</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable task)</span> </span>&#123;<br>    ObjectUtil.checkNotNull(task, <span class="hljs-string">&quot;task&quot;</span>);<br>    execute(task, !(task <span class="hljs-keyword">instanceof</span> LazyRunnable) &amp;&amp; wakesUpForTask(task));<br>&#125;<br><br><span class="hljs-comment">//io.netty.util.concurrent.SingleThreadEventExecutor#execute(java.lang.Runnable, boolean)</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable task, <span class="hljs-keyword">boolean</span> immediate)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> inEventLoop = inEventLoop();<br>    <span class="hljs-comment">// 将任务加入到eventloop的taskQueue中。</span><br>    addTask(task);<br>    <span class="hljs-comment">// 判断当前是否eventLoop线程，如果不是启动线程</span><br>    <span class="hljs-keyword">if</span> (!inEventLoop) &#123;<br>        startThread();<br>        <span class="hljs-comment">//是否已经是关闭状态。</span><br>        <span class="hljs-keyword">if</span> (isShutdown()) &#123;<br>            <span class="hljs-keyword">boolean</span> reject = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 将当前任务从当前队列移除</span><br>                <span class="hljs-keyword">if</span> (removeTask(task)) &#123;<br>                    reject = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (UnsupportedOperationException e) &#123;<br>                <span class="hljs-comment">// The task queue does not support removal so the best thing we can do is to just move on and</span><br>                <span class="hljs-comment">// hope we will be able to pick-up the task before its completely terminated.</span><br>                <span class="hljs-comment">// In worst case we will log on termination.</span><br>            &#125;<br>            <span class="hljs-comment">// 移除成功，抛eventLoop terminate 的异常警告。</span><br>            <span class="hljs-keyword">if</span> (reject) &#123;<br>                reject();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!addTaskWakesUp &amp;&amp; immediate) &#123;<br>        <span class="hljs-comment">// 判断当前eventloop是否是活跃状态，并且当前任务是否需要立刻执行。</span><br>        <span class="hljs-comment">// 如果是，唤醒当前eventloop（丢入一个空任务）</span><br>        wakeup(inEventLoop);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// io.netty.util.concurrent.SingleThreadEventExecutor#startThread</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startThread</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (state == ST_NOT_STARTED) &#123;<br>        <span class="hljs-comment">// 校验当前状态为未启动状态，并通过CAS的方式将状态设置为ST_STARTED。</span><br>        <span class="hljs-keyword">if</span> (STATE_UPDATER.compareAndSet(<span class="hljs-keyword">this</span>, ST_NOT_STARTED, ST_STARTED)) &#123;<br>            <span class="hljs-keyword">boolean</span> success = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 真正执行启动线程逻辑</span><br>                doStartThread();<br>                success = <span class="hljs-keyword">true</span>;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 如果启动失败，将状态通过CAS的方式设置ST_NOT_STARTED</span><br>                <span class="hljs-keyword">if</span> (!success) &#123;<br>                    STATE_UPDATER.compareAndSet(<span class="hljs-keyword">this</span>, ST_STARTED, ST_NOT_STARTED);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//io.netty.util.concurrent.SingleThreadEventExecutor#doStartThread</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doStartThread</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">assert</span> thread == <span class="hljs-keyword">null</span>;<br>    <br>    <span class="hljs-comment">// 异步执行启动任务。</span><br>    executor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            thread = Thread.currentThread();<br>            <span class="hljs-keyword">if</span> (interrupted) &#123;<br>                thread.interrupt();<br>            &#125;<br><br>            <span class="hljs-keyword">boolean</span> success = <span class="hljs-keyword">false</span>;<br>            updateLastExecutionTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 在这里启动eventloop线程，这个方法的里面是一个死循环。</span><br>                SingleThreadEventExecutor.<span class="hljs-keyword">this</span>.run();<br>                <span class="hljs-comment">// 执行到这里说明是正常的关闭，而非异常退出。</span><br>                success = <span class="hljs-keyword">true</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                logger.warn(<span class="hljs-string">&quot;Unexpected exception from an event executor: &quot;</span>, t);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 以下的代码是更新状态为ST_SHUTDOWN，ST_TERMINATED并最后清理资源。</span><br>                <span class="hljs-keyword">for</span> (;;) &#123;<br>                    <span class="hljs-keyword">int</span> oldState = state;<br>                    <span class="hljs-keyword">if</span> (oldState &gt;= ST_SHUTTING_DOWN || STATE_UPDATER.compareAndSet(<br>                        SingleThreadEventExecutor.<span class="hljs-keyword">this</span>, oldState, ST_SHUTTING_DOWN)) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-comment">// Check if confirmShutdown() was called at the end of the loop.</span><br>                <span class="hljs-keyword">if</span> (success &amp;&amp; gracefulShutdownStartTime == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (logger.isErrorEnabled()) &#123;<br>                        logger.error(<span class="hljs-string">&quot;Buggy &quot;</span> + EventExecutor.class.getSimpleName() + <span class="hljs-string">&quot; implementation; &quot;</span> +<br>                                     SingleThreadEventExecutor.class.getSimpleName() + <span class="hljs-string">&quot;.confirmShutdown() must &quot;</span> +<br>                                     <span class="hljs-string">&quot;be called before run() implementation terminates.&quot;</span>);<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// Run all remaining tasks and shutdown hooks. At this point the event loop</span><br>                    <span class="hljs-comment">// is in ST_SHUTTING_DOWN state still accepting tasks which is needed for</span><br>                    <span class="hljs-comment">// graceful shutdown with quietPeriod.</span><br>                    <span class="hljs-keyword">for</span> (;;) &#123;<br>                        <span class="hljs-keyword">if</span> (confirmShutdown()) &#123;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br><br>                    <span class="hljs-comment">// Now we want to make sure no more tasks can be added from this point. This is</span><br>                    <span class="hljs-comment">// achieved by switching the state. Any new tasks beyond this point will be rejected.</span><br>                    <span class="hljs-keyword">for</span> (;;) &#123;<br>                        <span class="hljs-keyword">int</span> oldState = state;<br>                        <span class="hljs-keyword">if</span> (oldState &gt;= ST_SHUTDOWN || STATE_UPDATER.compareAndSet(<br>                            SingleThreadEventExecutor.<span class="hljs-keyword">this</span>, oldState, ST_SHUTDOWN)) &#123;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br><br>                    <span class="hljs-comment">// We have the final set of tasks in the queue now, no more can be added, run all remaining.</span><br>                    <span class="hljs-comment">// No need to loop here, this is the final pass.</span><br>                    confirmShutdown();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        cleanup();<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        <span class="hljs-comment">// Lets remove all FastThreadLocals for the Thread as we are about to terminate and notify</span><br>                        <span class="hljs-comment">// the future. The user may block on the future and once it unblocks the JVM may terminate</span><br>                        <span class="hljs-comment">// and start unloading classes.</span><br>                        <span class="hljs-comment">// See https://github.com/netty/netty/issues/6596.</span><br>                        FastThreadLocal.removeAll();<br><br>                        STATE_UPDATER.set(SingleThreadEventExecutor.<span class="hljs-keyword">this</span>, ST_TERMINATED);<br>                        threadLock.countDown();<br>                        <span class="hljs-keyword">int</span> numUserTasks = drainTasks();<br>                        <span class="hljs-keyword">if</span> (numUserTasks &gt; <span class="hljs-number">0</span> &amp;&amp; logger.isWarnEnabled()) &#123;<br>                            logger.warn(<span class="hljs-string">&quot;An event executor terminated with &quot;</span> +<br>                                        <span class="hljs-string">&quot;non-empty task queue (&quot;</span> + numUserTasks + <span class="hljs-string">&#x27;)&#x27;</span>);<br>                        &#125;<br>                        terminationFuture.setSuccess(<span class="hljs-keyword">null</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过这部分代码的执行，我们启动了一个初始化完成的eventloop，我们不难发现，<strong>eventLoop的启动并不是在addTask之前来调用特定的方法实现。而是整合到addTask的过程中，先将task加入队列中，然后判断当前线程是不是eventLoop线程，如果不是则启动eventLoop，否则跳过启动。最后再由后续的eventLoop的pollTask来执行task。这一点设计很巧妙。</strong></p>
<h3 id="task队列任务的执行"><a href="#task队列任务的执行" class="headerlink" title="task队列任务的执行"></a>task队列任务的执行</h3><p>后面的逻辑就是我们前面剖析的NioEventLoop中的run方法剖析了，这里我们再简单的过一下，我们这次着重关注task队列任务的执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.channel.nio.NioEventLoop#run</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> selectCnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">int</span> strategy;<br>            <span class="hljs-keyword">try</span> &#123;<br>                strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());<br>                <span class="hljs-keyword">switch</span> (strategy) &#123;<br>                    <span class="hljs-keyword">case</span> SelectStrategy.CONTINUE:<br>                        <span class="hljs-keyword">continue</span>;<br><br>                    <span class="hljs-keyword">case</span> SelectStrategy.BUSY_WAIT:<br>                        <span class="hljs-comment">// fall-through to SELECT since the busy-wait is not supported with NIO</span><br><br>                    <span class="hljs-keyword">case</span> SelectStrategy.SELECT:<br>                        <span class="hljs-keyword">long</span> curDeadlineNanos = nextScheduledTaskDeadlineNanos();<br>                        <span class="hljs-keyword">if</span> (curDeadlineNanos == -<span class="hljs-number">1L</span>) &#123;<br>                            curDeadlineNanos = NONE; <span class="hljs-comment">// nothing on the calendar</span><br>                        &#125;<br>                        nextWakeupNanos.set(curDeadlineNanos);<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-keyword">if</span> (!hasTasks()) &#123;<br>                                strategy = select(curDeadlineNanos);<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">finally</span> &#123;<br>                            <span class="hljs-comment">// This update is just to help block unnecessary selector wakeups</span><br>                            <span class="hljs-comment">// so use of lazySet is ok (no race condition)</span><br>                            nextWakeupNanos.lazySet(AWAKE);<br>                        &#125;<br>                        <span class="hljs-comment">// fall through</span><br>                    <span class="hljs-keyword">default</span>:<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                <span class="hljs-comment">// If we receive an IOException here its because the Selector is messed up. Let&#x27;s rebuild</span><br>                <span class="hljs-comment">// the selector and retry. https://github.com/netty/netty/issues/8566</span><br>                rebuildSelector0();<br>                selectCnt = <span class="hljs-number">0</span>;<br>                handleLoopException(e);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            selectCnt++;<br>            cancelledKeys = <span class="hljs-number">0</span>;<br>            needsToSelectAgain = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ioRatio = <span class="hljs-keyword">this</span>.ioRatio;<br>            <span class="hljs-keyword">boolean</span> ranTasks;<br>            <span class="hljs-comment">// 下面这段代码可以看到无论ioRatio的值为多少都会执行runAllTasks();方法</span><br>            <span class="hljs-keyword">if</span> (ioRatio == <span class="hljs-number">100</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (strategy &gt; <span class="hljs-number">0</span>) &#123;<br>                        processSelectedKeys();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// Ensure we always run tasks.</span><br>                    ranTasks = runAllTasks();<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (strategy &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ioStartTime = System.nanoTime();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    processSelectedKeys();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// Ensure we always run tasks.</span><br>                    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ioTime = System.nanoTime() - ioStartTime;<br>                    ranTasks = runAllTasks(ioTime * (<span class="hljs-number">100</span> - ioRatio) / ioRatio);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ranTasks = runAllTasks(<span class="hljs-number">0</span>); <span class="hljs-comment">// This will run the minimum number of tasks</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (ranTasks || strategy &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS &amp;&amp; logger.isDebugEnabled()) &#123;<br>                    logger.debug(<span class="hljs-string">&quot;Selector.select() returned prematurely &#123;&#125; times in a row for Selector &#123;&#125;.&quot;</span>,<br>                                 selectCnt - <span class="hljs-number">1</span>, selector);<br>                &#125;<br>                selectCnt = <span class="hljs-number">0</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (unexpectedSelectorWakeup(selectCnt)) &#123; <span class="hljs-comment">// Unexpected wakeup (unusual case)</span><br>                selectCnt = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException e) &#123;<br>            <span class="hljs-comment">// Harmless exception - log anyway</span><br>            <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>                logger.debug(CancelledKeyException.class.getSimpleName() + <span class="hljs-string">&quot; raised by a Selector &#123;&#125; - JDK bug?&quot;</span>,<br>                             selector, e);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Error e) &#123;<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            handleLoopException(t);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// Always handle shutdown even if the loop processing threw an exception.</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (isShuttingDown()) &#123;<br>                    closeAll();<br>                    <span class="hljs-keyword">if</span> (confirmShutdown()) &#123;<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Error e) &#123;<br>                <span class="hljs-keyword">throw</span> e;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                handleLoopException(t);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这段逻辑我们就不重复分析了，这段逻辑大致可以分为<code>select轮询就绪Key</code>、<code>processSelectedKeys处理就绪key</code>、<code>runAllTasks处理队列中的任务</code>、<code>处理空轮询bug</code>这几个部分，其中无论<code>ioRatio</code>的值为多少<code>runAllTasks</code>都会执行。这就保证了我们处于队列中的任务都会被执行。以下是<code>runAllTasks()</code>方法的详细剖析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//执行队列中所有的task</span><br><span class="hljs-comment">// io.netty.util.concurrent.SingleThreadEventExecutor#runAllTasks()</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">runAllTasks</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">assert</span> <span class="hljs-title">inEventLoop</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">boolean</span> fetchedAll;<br>    <span class="hljs-keyword">boolean</span> ranAtLeastOne = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">// 从定时任务队列中取出所有满足条件的任务，并将它们加入到taskQueue中。</span><br>        fetchedAll = fetchFromScheduledTaskQueue();<br>        <span class="hljs-comment">// 执行所有task队列中的任务</span><br>        <span class="hljs-keyword">if</span> (runAllTasksFrom(taskQueue)) &#123;<br>            ranAtLeastOne = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (!fetchedAll); <span class="hljs-comment">// keep on processing until we fetched all scheduled tasks.</span><br><br>    <span class="hljs-keyword">if</span> (ranAtLeastOne) &#123;<br>        lastExecutionTime = ScheduledFutureTask.nanoTime();<br>    &#125;<br>    <span class="hljs-comment">//执行taskTail队列中的任务。</span><br>    afterRunningAllTasks();<br>    <span class="hljs-keyword">return</span> ranAtLeastOne;<br>&#125;<br><br><span class="hljs-comment">// 一个简单的“近实时”的延时队列的实现。</span><br><span class="hljs-comment">//io.netty.util.concurrent.SingleThreadEventExecutor#fetchFromScheduledTaskQueue</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">fetchFromScheduledTaskQueue</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (scheduledTaskQueue == <span class="hljs-keyword">null</span> || scheduledTaskQueue.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">long</span> nanoTime = AbstractScheduledEventExecutor.nanoTime();<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// 循环从cheduledTask取出满足条件的task任务。</span><br>        Runnable scheduledTask = pollScheduledTask(nanoTime);<br>        <span class="hljs-keyword">if</span> (scheduledTask == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 将task加入到任务队列taskQueue中。</span><br>        <span class="hljs-keyword">if</span> (!taskQueue.offer(scheduledTask)) &#123;<br>            <span class="hljs-comment">// No space left in the task queue add it back to the scheduledTaskQueue so we pick it up again.</span><br>            <span class="hljs-comment">// 如果队列满了加入失败，先将其放回scheduledTaskQueue等task队列消费完成后再次加入</span><br>            scheduledTaskQueue.add((ScheduledFutureTask&lt;?&gt;) scheduledTask);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//io.netty.util.concurrent.AbstractScheduledEventExecutor#pollScheduledTask(long)</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Runnable <span class="hljs-title">pollScheduledTask</span><span class="hljs-params">(<span class="hljs-keyword">long</span> nanoTime)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">assert</span> <span class="hljs-title">inEventLoop</span><span class="hljs-params">()</span></span>;<br><br>    ScheduledFutureTask&lt;?&gt; scheduledTask = peekScheduledTask();<br>    <span class="hljs-keyword">if</span> (scheduledTask == <span class="hljs-keyword">null</span> || scheduledTask.deadlineNanos() - nanoTime &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    scheduledTaskQueue.remove();<br>    scheduledTask.setConsumed();<br>    <span class="hljs-keyword">return</span> scheduledTask;<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.SingleThreadEventLoop#afterRunningAllTasks</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterRunningAllTasks</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 执行tailTaskQueue中的所有task。</span><br>    runAllTasksFrom(tailTasks);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在<code>run()</code>方法中除了<code>runAllTasks()</code>方法还有一个重载方法<code>runAllTasks(long timeoutNanos)</code>这个方法则是执行时间长度为 <code>timeoutNanos</code> 纳秒的runAllTask方法。实现的方法也很简单，<strong>每执行64个task检查下时间是否超时</strong>，如果没有超时继续执行，否则退出方法。如果<code>runAllTasks(0)</code>则是执行最小单位的runAllTask方法（即64个task）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.util.concurrent.SingleThreadEventExecutor#runAllTasks(long)</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">runAllTasks</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeoutNanos)</span> </span>&#123;<br>    <span class="hljs-comment">// 从schedule任务队列中取出任务加入到taskQueue中</span><br>    fetchFromScheduledTaskQueue();<br>    <span class="hljs-comment">// 取出第一个任务</span><br>    Runnable task = pollTask();<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-keyword">null</span>) &#123;<br>        afterRunningAllTasks();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算得出这批次执行的deadline</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> deadline = timeoutNanos &gt; <span class="hljs-number">0</span> ? ScheduledFutureTask.nanoTime() + timeoutNanos : <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">long</span> runTasks = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">long</span> lastExecutionTime;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// 执行runnable任务即执行run方法。</span><br>        safeExecute(task);<br><br>        runTasks ++;<br><br>        <span class="hljs-comment">// 因为nanoTime()方法是一个开销较大的方法，所以这里满64个任务才校验一次。</span><br>        <span class="hljs-comment">// Check timeout every 64 tasks because nanoTime() is relatively expensive.</span><br>        <span class="hljs-comment">// <span class="hljs-doctag">XXX:</span> Hard-coded value - will make it configurable if it is really a problem.</span><br>        <span class="hljs-keyword">if</span> ((runTasks &amp; <span class="hljs-number">0x3F</span>) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 执行满64个校验当前是否超过deadline</span><br>            lastExecutionTime = ScheduledFutureTask.nanoTime();<br>            <span class="hljs-keyword">if</span> (lastExecutionTime &gt;= deadline) &#123;<br>                <span class="hljs-comment">//如果是，退出循环执行后续逻辑。</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>		<span class="hljs-comment">// 否则取出下一个任务继续循环执行。</span><br>        task = pollTask();<br>        <span class="hljs-keyword">if</span> (task == <span class="hljs-keyword">null</span>) &#123;<br>            lastExecutionTime = ScheduledFutureTask.nanoTime();<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//执行taskTail队列中的任务。</span><br>    afterRunningAllTasks();<br>    <span class="hljs-keyword">this</span>.lastExecutionTime = lastExecutionTime;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="承上启下的task队列"><a href="#承上启下的task队列" class="headerlink" title="承上启下的task队列"></a>承上启下的task队列</h3><p>以上就是eventLoop启动与task队列的源码剖析，而结合我们前面的<code>initAndRegister</code>部分的源码分析，我们知道我们将<code>register</code>、<code>addServerBootstrapAcceptor</code>和<code>bind</code>操作放入了task队列中。也就是下面这些代码片段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// register</span><br><span class="hljs-keyword">if</span> (eventLoop.inEventLoop()) &#123;<br>    register0(promise);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        eventLoop.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                register0(promise);<br>            &#125;<br>        &#125;);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        logger.warn(<br>            <span class="hljs-string">&quot;Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;&quot;</span>,<br>            AbstractChannel.<span class="hljs-keyword">this</span>, t);<br>        closeForcibly();<br>        closeFuture.setClosed();<br>        safeSetFailure(promise, t);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// addServerBootstrapAcceptor</span><br>ch.eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        pipeline.addLast(<span class="hljs-keyword">new</span> ServerBootstrapAcceptor(<br>            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>在initAndRegister的部分，taskQueue中有以下的几个任务，并且这几个任务之间是有明确的先后顺序的。其中register部分是main线程加进去的，其余的都是由eventLoop线程加入到taskQueue中。</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20220211005119.png" srcset="/img/loading.gif"></p>
<p>那么main线程是在什么时候退出的呢？main线程在执行完<code>bind(PORT)</code>方法之后，就阻塞在下面这段EchoServer中的这段<code>f.channel().closeFuture().sync();</code>代码上。后续的<code>bind</code>和<code>active</code>等操作都将以eventLoop的task的方式执行。</p>
<h2 id="bind（端口绑定）和active操作源码剖析"><a href="#bind（端口绑定）和active操作源码剖析" class="headerlink" title="bind（端口绑定）和active操作源码剖析"></a>bind（端口绑定）和active操作源码剖析</h2><p>上面我们分析了整个启动的流程是通过evetLoop的Task的方式执行，而<code>register</code>、<code>addAcceptor</code>和<code>bind</code>等操作都是作为一个个task任务加入到taskQueue中，最后在eventLoop的run方法中调用<code>runAllTasks</code>方法执行这些task任务。在前面的initAndRegister的解析中，我们分析到register方法返回了一个<code>promise</code>，我们在promise添加了一个<code>Listener</code>（监听器），监听器加入的是<strong>bind端口绑定</strong>的逻辑，并且这段逻辑是<strong>通过eventLoop的Task方式</strong>执行的。</p>
<h3 id="bind端口绑定操作源码剖析"><a href="#bind端口绑定操作源码剖析" class="headerlink" title="bind端口绑定操作源码剖析"></a>bind端口绑定操作源码剖析</h3><p>接下来，我们继续分析bind端口绑定操作的源码。整个流程前面<code>pipeline.channelRegistered()</code>是类似的，只不过<code>channelRegistered()</code>是inboundHandler里面的方法，而<code>bind()</code>是outBoundHandler里的方法。以下是bind部分的源码剖析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.bootstrap.AbstractBootstrap#doBind0</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBind0</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">final</span> ChannelFuture regFuture, <span class="hljs-keyword">final</span> Channel channel,</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;<br><br>    <span class="hljs-comment">// This method is invoked before channelRegistered() is triggered.  Give user handlers a chance to set up</span><br>    <span class="hljs-comment">// the pipeline in its channelRegistered() implementation.</span><br>    <span class="hljs-comment">//通过eventLoop的task任务方式异步执行。</span><br>    channel.eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">// 注册成功执行。</span><br>            <span class="hljs-keyword">if</span> (regFuture.isSuccess()) &#123;<br>                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                promise.setFailure(regFuture.cause());<br>            &#125;<br>        &#125;<br>    &#125;);<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.AbstractChannel#bind(java.net.SocketAddress, io.netty.channel.ChannelPromise)</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title">bind</span><span class="hljs-params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;<br>    <span class="hljs-comment">// 调用pipeline的bind方法，其实绑定端口方法是在channelHandler上的。</span><br>    <span class="hljs-keyword">return</span> pipeline.bind(localAddress, promise);<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.DefaultChannelPipeline#bind(java.net.SocketAddress, io.netty.channel.ChannelPromise)</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">bind</span><span class="hljs-params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;<br>    <span class="hljs-comment">// bind方法是从pipeline的handler链的尾开始向头执行的。</span><br>    <span class="hljs-comment">// 这里准确的描述应该是outBoundHandler都是从尾向头执行的，bind方法是outBound的方法。</span><br>    <span class="hljs-keyword">return</span> tail.bind(localAddress, promise);<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.AbstractChannelHandlerContext#bind(java.net.SocketAddress, io.netty.channel.ChannelPromise)</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;<br>    ObjectUtil.checkNotNull(localAddress, <span class="hljs-string">&quot;localAddress&quot;</span>);<br>    <span class="hljs-keyword">if</span> (isNotValidPromise(promise, <span class="hljs-keyword">false</span>)) &#123;<br>        <span class="hljs-comment">// cancelled</span><br>        <span class="hljs-keyword">return</span> promise;<br>    &#125;<br><br>    <span class="hljs-comment">// 找到outboundHandler中包含bind方法的handler下一个handler即LoggingHandler</span><br>    <span class="hljs-keyword">final</span> AbstractChannelHandlerContext next = findContextOutbound(MASK_BIND);<br>    EventExecutor executor = next.executor();<br>    <span class="hljs-comment">//调用bind方法</span><br>    <span class="hljs-keyword">if</span> (executor.inEventLoop()) &#123;<br>        next.invokeBind(localAddress, promise);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        safeExecute(executor, <span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                next.invokeBind(localAddress, promise);<br>            &#125;<br>        &#125;, promise, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> promise;<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.AbstractChannelHandlerContext#invokeBind</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeBind</span><span class="hljs-params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;<br>    <span class="hljs-comment">//调用绑定方法，此时的handler是LoggingHandler。</span><br>    <span class="hljs-keyword">if</span> (invokeHandler()) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ((ChannelOutboundHandler) handler()).bind(<span class="hljs-keyword">this</span>, localAddress, promise);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            notifyOutboundHandlerException(t, promise);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        bind(localAddress, promise);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//io.netty.handler.logging.LoggingHandler#bind</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bind</span><span class="hljs-params">(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">if</span> (logger.isEnabled(internalLevel)) &#123;<br>        logger.log(internalLevel, format(ctx, <span class="hljs-string">&quot;BIND&quot;</span>, localAddress));<br>    &#125;<br>    <span class="hljs-comment">// 继续调用前一个handler的bind方法</span><br>    ctx.bind(localAddress, promise);<br>&#125;<br><br><span class="hljs-comment">// 我们又回到了bind方法，找到前一个handler并调用</span><br><span class="hljs-comment">//io.netty.channel.AbstractChannelHandlerContext#bind(java.net.SocketAddress, io.netty.channel.ChannelPromise)</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;<br>    ObjectUtil.checkNotNull(localAddress, <span class="hljs-string">&quot;localAddress&quot;</span>);<br>    <span class="hljs-keyword">if</span> (isNotValidPromise(promise, <span class="hljs-keyword">false</span>)) &#123;<br>        <span class="hljs-comment">// cancelled</span><br>        <span class="hljs-keyword">return</span> promise;<br>    &#125;<br><br>    <span class="hljs-comment">// 找到outboundHandler中包含bind方法的handler下一个handler即HeadContext头Handler</span><br>    <span class="hljs-keyword">final</span> AbstractChannelHandlerContext next = findContextOutbound(MASK_BIND);<br>    EventExecutor executor = next.executor();<br>    <span class="hljs-comment">//调用bind方法</span><br>    <span class="hljs-keyword">if</span> (executor.inEventLoop()) &#123;<br>        next.invokeBind(localAddress, promise);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        safeExecute(executor, <span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                next.invokeBind(localAddress, promise);<br>            &#125;<br>        &#125;, promise, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> promise;<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.DefaultChannelPipeline.HeadContext#bind</span><br> <span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bind</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;<br>    <span class="hljs-comment">// 调用unsafe的bind方法，</span><br>    unsafe.bind(localAddress, promise);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其实，我们的bind操作和channelRegistered操作基本是类似的，只不过bind方法是<code>outBoundHandler</code>中的方法，<code>outBoundHandler</code>的方法不再想<code>inBoundHandler</code>里的方法一样从头到尾节点依次执行handler的方法，<code>outBoundHandler</code><strong>执行顺序反过来，从尾节点开始向前遍历到头节点依次执行对应的handler方法</strong>。所以上面这段代码，从调用<code>pipeline.bind(localAddress, promise);</code>方法开始，<strong>从后向前依次调用</strong>outboundHandler的<code>bind</code>方法。以上的代码逻辑就是这个调用过程，方法调用最后的bind方法就是头节点即HeadContext中的额bind方法，这个方法里面的bind操作是调用unsafe方法，也就是我们的channel与端口的绑定，以及后续讲active操作添加到eventLoop的Task队列中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.channel.AbstractChannel.AbstractUnsafe#bind</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;<br>  assertEventLoop();<br>	<br>  <span class="hljs-comment">// 确保当前promise不可取消并且当前channel还没有open</span><br>  <span class="hljs-keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// See: https://github.com/netty/netty/issues/576</span><br>  <span class="hljs-keyword">if</span> (Boolean.TRUE.equals(config().getOption(ChannelOption.SO_BROADCAST)) &amp;&amp;<br>      localAddress <span class="hljs-keyword">instanceof</span> InetSocketAddress &amp;&amp;<br>      !((InetSocketAddress) localAddress).getAddress().isAnyLocalAddress() &amp;&amp;<br>      !PlatformDependent.isWindows() &amp;&amp; !PlatformDependent.maybeSuperUser()) &#123;<br>    <span class="hljs-comment">// Warn a user about the fact that a non-root user can&#x27;t receive a</span><br>    <span class="hljs-comment">// broadcast packet on *nix if the socket is bound on non-wildcard address.</span><br>    logger.warn(<br>      <span class="hljs-string">&quot;A non-root user can&#x27;t receive a broadcast packet if the socket &quot;</span> +<br>      <span class="hljs-string">&quot;is not bound to a wildcard address; binding to a non-wildcard &quot;</span> +<br>      <span class="hljs-string">&quot;address (&quot;</span> + localAddress + <span class="hljs-string">&quot;) anyway as requested.&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">boolean</span> wasActive = isActive();<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 绑定操作</span><br>    doBind(localAddress);<br>  &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>    <span class="hljs-comment">// 如果捕捉到异常，promise设置失败</span><br>    safeSetFailure(promise, t);<br>    closeIfClosed();<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;<br>    <span class="hljs-comment">// 如果当前调用active操作，将pipeline.fireChannelActive();加入到eventLoop的task队列中</span><br>    invokeLater(<span class="hljs-keyword">new</span> Runnable() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        pipeline.fireChannelActive();<br>      &#125;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-comment">// promise设置调用成功</span><br>  safeSetSuccess(promise);<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.socket.nio.NioServerSocketChannel#doBind</span><br><span class="hljs-meta">@SuppressJava6Requirement(reason = &quot;Usage guarded by java version check&quot;)</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBind</span><span class="hljs-params">(SocketAddress localAddress)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>  <span class="hljs-comment">// channel与端口绑定</span><br>  <span class="hljs-keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="hljs-number">7</span>) &#123;<br>    javaChannel().bind(localAddress, config.getBacklog());<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    javaChannel().socket().bind(localAddress, config.getBacklog());<br>  &#125;<br>&#125;	<br></code></pre></td></tr></table></figure>

<h3 id="active部分方法调用源码剖析"><a href="#active部分方法调用源码剖析" class="headerlink" title="active部分方法调用源码剖析"></a>active部分方法调用源码剖析</h3><p>active部分并不是需要激活什么，本质上是调用pipelineChannelHandler的<code>channelActive(ctx)</code>方法，<code>channelActive</code>和<code>channelRegistered</code>一样都是inboundHandler里面的方法，因此调用过程和channelRegistered的过程一致。在前面的bind端口绑定部分的解析，我们看到bind方法内通过调用invokeLater方法，将<code>pipeline.fireChannelActive();</code>加入到eventLoop的task队列中。因此我们从<code>pipeline.fireChannelActive();</code>方法开始继续我们的源码剖析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// io.netty.channel.DefaultChannelPipeline#fireChannelActive</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">fireChannelActive</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 对比bind方法，这里我们可以发现inbound方法都是从head开始执行的。</span><br>    AbstractChannelHandlerContext.invokeChannelActive(head);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// io.netty.channel.AbstractChannelHandlerContext#invokeChannelActive(io.netty.channel.AbstractChannelHandlerContext)</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeChannelActive</span><span class="hljs-params">(<span class="hljs-keyword">final</span> AbstractChannelHandlerContext next)</span> </span>&#123;<br>    EventExecutor executor = next.executor();<br>    <span class="hljs-keyword">if</span> (executor.inEventLoop()) &#123;<br>        <span class="hljs-comment">// 直接执行invokeChannelActive方法。</span><br>        next.invokeChannelActive();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        executor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                next.invokeChannelActive();<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 这个方法和前面的invokeBind和invokeChannelRegistered方法类似。</span><br><span class="hljs-comment">// io.netty.channel.AbstractChannelHandlerContext#invokeChannelActive()</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeChannelActive</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (invokeHandler()) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 调用目标handler的channelActive，这里的对象是HeadContext也就是headHandler</span><br>            ((ChannelInboundHandler) handler()).channelActive(<span class="hljs-keyword">this</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            invokeExceptionCaught(t);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fireChannelActive();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// io.netty.channel.DefaultChannelPipeline.HeadContext#channelActive</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;<br>    <span class="hljs-comment">//触发调用下一个handler的channelActive的方法。</span><br>    ctx.fireChannelActive();<br>    <span class="hljs-comment">// 开启监听连接事件</span><br>    readIfIsAutoRead();<br>&#125;<br><br><span class="hljs-comment">// 找寻下一个channelActive的inboundHandler</span><br><span class="hljs-comment">//io.netty.channel.AbstractChannelHandlerContext#fireChannelActive</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ChannelHandlerContext <span class="hljs-title">fireChannelActive</span><span class="hljs-params">()</span> </span>&#123;<br>    invokeChannelActive(findContextInbound(MASK_CHANNEL_ACTIVE));<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><br><br><span class="hljs-comment">// io.netty.channel.AbstractChannelHandlerContext#invokeChannelActive()</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeChannelActive</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (invokeHandler()) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 此时的Handler对象是LoggingHandler对象</span><br>            ((ChannelInboundHandler) handler()).channelActive(<span class="hljs-keyword">this</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            invokeExceptionCaught(t);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fireChannelActive();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//io.netty.handler.logging.LoggingHandler#channelActive</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">if</span> (logger.isEnabled(internalLevel)) &#123;<br>        logger.log(internalLevel, format(ctx, <span class="hljs-string">&quot;ACTIVE&quot;</span>));<br>    &#125;<br>    ctx.fireChannelActive();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>结合上面分析的channelActive、bind和channelRegistered方法的调用，大体上都是相同的。我们再次结合复习下pipelineChannelHandler中的调用过程。</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20220217235410.png" srcset="/img/loading.gif"></p>
<p>上面的图简单的表述了这个调用的代码实现过程，本质上<code>channelActive</code>、<code>bind</code>和<code>channelRegistered</code>的调用过程本质上都是一样的， 唯一不同的点就是channelActive和channelRegistered是<code>inboundHandler</code>的方法，所以这两个方法的调用是从头向后依次向后执行即从headContext向tailContext执行。而bind方法是<code>outboundHandler</code>的方法，所以是执行顺序是反过来的，也就是从tailContext向前执行，即下面这张图的逻辑。</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20210921211125.png" srcset="/img/loading.gif"></p>
<p>在完成了pipelineChannelHandler的channleActive的调用之后，Netty将开始启动过程的最后一步，对ACCEPT时间的监听。即调用<code>readIfIsAutoRead();</code>设置<code>interestOps</code>为<code>OP_ACCEPT</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// io.netty.channel.DefaultChannelPipeline.HeadContext#channelActive</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;<br>    <span class="hljs-comment">//触发调用下一个handler的channelActive的方法。</span><br>    ctx.fireChannelActive();<br>    <span class="hljs-comment">// 开启监听连接事件</span><br>    readIfIsAutoRead();<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.DefaultChannelPipeline.HeadContext#readIfIsAutoRead</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readIfIsAutoRead</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (channel.config().isAutoRead()) &#123;<br>        <span class="hljs-comment">// 开启读</span><br>        channel.read();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.AbstractChannel#read</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Channel <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 调用pipeline的read方法</span><br>    pipeline.read();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.DefaultChannelPipeline#read</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// read方法是outBoundHandler的方法， 从尾向头执行，因此从tail开始。</span><br>    tail.read();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.DefaultChannelPipeline.HeadContext#read</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;<br>    <span class="hljs-comment">// headContext的read方法是调用链中最后一个执行方法</span><br>    unsafe.beginRead();<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.AbstractChannel.AbstractUnsafe#beginRead</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beginRead</span><span class="hljs-params">()</span> </span>&#123;<br>    assertEventLoop();<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 实际执行的read方法。</span><br>        doBeginRead();<br>    &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> Exception e) &#123;<br>        <span class="hljs-comment">// 如果出现异常，使用eventLoop的task方式执行</span><br>        invokeLater(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                pipeline.fireExceptionCaught(e);<br>            &#125;<br>        &#125;);<br>        close(voidPromise());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// io.netty.channel.nio.AbstractNioChannel#doBeginRead</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBeginRead</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">// Channel.read() or ChannelHandlerContext.read() was called</span><br>    <span class="hljs-keyword">final</span> SelectionKey selectionKey = <span class="hljs-keyword">this</span>.selectionKey;<br>    <span class="hljs-keyword">if</span> (!selectionKey.isValid()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    readPending = <span class="hljs-keyword">true</span>;<br>	<span class="hljs-comment">// 当前Channel的实例是NioServerSocketChannel，</span><br>    <span class="hljs-comment">//所以这里selectionKey.interestOps() 为 SelectionKey.OP_ACCEPT</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> interestOps = selectionKey.interestOps();<br>    <span class="hljs-comment">// readInterestOp的值为0, 0&amp;n = 0</span><br>    <span class="hljs-keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 0|n = n, 设置interestOps为SelectionKey.OP_ACCEPT，即设置监听事件为Accept</span><br>        selectionKey.interestOps(interestOps | readInterestOp);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// OP_ACCEPT 的值为 16</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> OP_ACCEPT = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure>

<p>完成上面代码的调用，Netty的服务也基本上启动完成即完成了服务的初始化，完成了服务基础初始化，将channelHandler加入到pipeline中，并调用handler的channelRegistered，bind，channelActive和read方法等。通过这些方法的调用，完成了channel的注册，端口的绑定，channelActive的调用和最后对Channel的Accpet事件的监听，整个过程中都依赖EventLoop的Task进行任务的调度执行。在上面这个调用过程中，我发现一个有意思的代码设计即ctx.executeMask的设计逻辑，这也是我们熟悉的二进制标识的应用。以下是这个部分的详细代码剖析。</p>
<h3 id="一个小细节-ctx-executeMask"><a href="#一个小细节-ctx-executeMask" class="headerlink" title="一个小细节 ctx.executeMask"></a>一个小细节 ctx.executeMask</h3><p>在看源码过程中，我翻了一些资料和一些博客，在之前的pipelineChannelHandler的版本中，都有标识当前handler是inBoundHandler还是outBoundHandler，但是在我看的这版本源码中并有有关的变量，那它是怎么标识，当前handler是inBound还是outBoundHandler的呢？在一条调用链上，当前handler是否包含了当前的方法呢？答案就是<code>executeMask</code>。但是我debug源码的时候，executeMask的值只是一个普通的常数啊，随着对源码的深入，我发现<strong>executMask使用二进制的方式标识重载方法</strong>，这又是一个使用二进制位标识状态的应用。我们一起深入源码看看，它是怎么玩的吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.channel.AbstractChannelHandlerContext#skipContext</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">skipContext</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    AbstractChannelHandlerContext ctx, EventExecutor currentExecutor, <span class="hljs-keyword">int</span> mask, <span class="hljs-keyword">int</span> onlyMask)</span> </span>&#123;<br>    <span class="hljs-comment">// Ensure we correctly handle MASK_EXCEPTION_CAUGHT which is not included in the MASK_EXCEPTION_CAUGHT</span><br>    <br>    <span class="hljs-comment">// 因为每个executionMask上标识了当前handler可以执行的方法，通过和mask比较的结果</span><br>    <span class="hljs-comment">// 即可知道当前handler是否是合适的可以执行的handler</span><br>    <span class="hljs-keyword">return</span> (ctx.executionMask &amp; (onlyMask | mask)) == <span class="hljs-number">0</span> ||<br>        <span class="hljs-comment">// We can only skip if the EventExecutor is the same as otherwise we need to ensure we offload</span><br>        <span class="hljs-comment">// everything to preserve ordering.</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// See https://github.com/netty/netty/issues/10067</span><br>        (ctx.executor() == currentExecutor &amp;&amp; (ctx.executionMask &amp; mask) == <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上是在寻找下个合适的Handler时，使用executeMask进行handler的过滤，二进制的方式进行判断效率很高。下面这段代码则是构建ChannelContextHandler时对executeMask进行赋值的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// io.netty.channel.AbstractChannelHandlerContext#AbstractChannelHandlerContext</span><br>AbstractChannelHandlerContext(DefaultChannelPipeline pipeline, EventExecutor executor,<br>                              String name, Class&lt;? extends ChannelHandler&gt; handlerClass) &#123;<br>    <span class="hljs-keyword">this</span>.name = ObjectUtil.checkNotNull(name, <span class="hljs-string">&quot;name&quot;</span>);<br>    <span class="hljs-keyword">this</span>.pipeline = pipeline;<br>    <span class="hljs-keyword">this</span>.executor = executor;<br>    <span class="hljs-keyword">this</span>.executionMask = mask(handlerClass);<br>    <span class="hljs-comment">// Its ordered if its driven by the EventLoop or the given Executor is an instanceof OrderedEventExecutor.</span><br>    ordered = executor == <span class="hljs-keyword">null</span> || executor <span class="hljs-keyword">instanceof</span> OrderedEventExecutor;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Return the &#123;<span class="hljs-doctag">@code</span> executionMask&#125;.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//io.netty.channel.ChannelHandlerMask#mask</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">mask</span><span class="hljs-params">(Class&lt;? extends ChannelHandler&gt; clazz)</span> </span>&#123;<br>    <span class="hljs-comment">// Try to obtain the mask from the cache first. If this fails calculate it and put it in the cache for fast</span><br>    <span class="hljs-comment">// lookup in the future.</span><br>    <span class="hljs-comment">// 加一层缓存和生成executeMask的逻辑</span><br>    Map&lt;Class&lt;? extends ChannelHandler&gt;, Integer&gt; cache = MASKS.get();<br>    Integer mask = cache.get(clazz);<br>    <span class="hljs-keyword">if</span> (mask == <span class="hljs-keyword">null</span>) &#123;<br>        mask = mask0(clazz);<br>        cache.put(clazz, mask);<br>    &#125;<br>    <span class="hljs-keyword">return</span> mask;<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.ChannelHandlerMask#mask0</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">mask0</span><span class="hljs-params">(Class&lt;? extends ChannelHandler&gt; handlerType)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> mask = MASK_EXCEPTION_CAUGHT;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 使用反射来判断当前类中是否包含某个方法，如果包含则标识对应的标识位。</span><br>        <span class="hljs-keyword">if</span> (ChannelInboundHandler.class.isAssignableFrom(handlerType)) &#123;<br>            mask |= MASK_ALL_INBOUND;<br><br>            <span class="hljs-keyword">if</span> (isSkippable(handlerType, <span class="hljs-string">&quot;channelRegistered&quot;</span>, ChannelHandlerContext.class)) &#123;<br>                mask &amp;= ~MASK_CHANNEL_REGISTERED;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (isSkippable(handlerType, <span class="hljs-string">&quot;channelUnregistered&quot;</span>, ChannelHandlerContext.class)) &#123;<br>                mask &amp;= ~MASK_CHANNEL_UNREGISTERED;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (isSkippable(handlerType, <span class="hljs-string">&quot;channelActive&quot;</span>, ChannelHandlerContext.class)) &#123;<br>                mask &amp;= ~MASK_CHANNEL_ACTIVE;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (isSkippable(handlerType, <span class="hljs-string">&quot;channelInactive&quot;</span>, ChannelHandlerContext.class)) &#123;<br>                mask &amp;= ~MASK_CHANNEL_INACTIVE;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (isSkippable(handlerType, <span class="hljs-string">&quot;channelRead&quot;</span>, ChannelHandlerContext.class, Object.class)) &#123;<br>                mask &amp;= ~MASK_CHANNEL_READ;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (isSkippable(handlerType, <span class="hljs-string">&quot;channelReadComplete&quot;</span>, ChannelHandlerContext.class)) &#123;<br>                mask &amp;= ~MASK_CHANNEL_READ_COMPLETE;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (isSkippable(handlerType, <span class="hljs-string">&quot;channelWritabilityChanged&quot;</span>, ChannelHandlerContext.class)) &#123;<br>                mask &amp;= ~MASK_CHANNEL_WRITABILITY_CHANGED;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (isSkippable(handlerType, <span class="hljs-string">&quot;userEventTriggered&quot;</span>, ChannelHandlerContext.class, Object.class)) &#123;<br>                mask &amp;= ~MASK_USER_EVENT_TRIGGERED;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (ChannelOutboundHandler.class.isAssignableFrom(handlerType)) &#123;<br>            mask |= MASK_ALL_OUTBOUND;<br><br>            <span class="hljs-keyword">if</span> (isSkippable(handlerType, <span class="hljs-string">&quot;bind&quot;</span>, ChannelHandlerContext.class,<br>                            SocketAddress.class, ChannelPromise.class)) &#123;<br>                mask &amp;= ~MASK_BIND;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (isSkippable(handlerType, <span class="hljs-string">&quot;connect&quot;</span>, ChannelHandlerContext.class, SocketAddress.class,<br>                            SocketAddress.class, ChannelPromise.class)) &#123;<br>                mask &amp;= ~MASK_CONNECT;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (isSkippable(handlerType, <span class="hljs-string">&quot;disconnect&quot;</span>, ChannelHandlerContext.class, ChannelPromise.class)) &#123;<br>                mask &amp;= ~MASK_DISCONNECT;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (isSkippable(handlerType, <span class="hljs-string">&quot;close&quot;</span>, ChannelHandlerContext.class, ChannelPromise.class)) &#123;<br>                mask &amp;= ~MASK_CLOSE;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (isSkippable(handlerType, <span class="hljs-string">&quot;deregister&quot;</span>, ChannelHandlerContext.class, ChannelPromise.class)) &#123;<br>                mask &amp;= ~MASK_DEREGISTER;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (isSkippable(handlerType, <span class="hljs-string">&quot;read&quot;</span>, ChannelHandlerContext.class)) &#123;<br>                mask &amp;= ~MASK_READ;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (isSkippable(handlerType, <span class="hljs-string">&quot;write&quot;</span>, ChannelHandlerContext.class,<br>                            Object.class, ChannelPromise.class)) &#123;<br>                mask &amp;= ~MASK_WRITE;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (isSkippable(handlerType, <span class="hljs-string">&quot;flush&quot;</span>, ChannelHandlerContext.class)) &#123;<br>                mask &amp;= ~MASK_FLUSH;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (isSkippable(handlerType, <span class="hljs-string">&quot;exceptionCaught&quot;</span>, ChannelHandlerContext.class, Throwable.class)) &#123;<br>            mask &amp;= ~MASK_EXCEPTION_CAUGHT;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-comment">// Should never reach here.</span><br>        PlatformDependent.throwException(e);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> mask;<br>&#125;<br><br><span class="hljs-comment">// io.netty.channel.ChannelHandlerMask#isSkippable</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSkippable</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    		<span class="hljs-keyword">final</span> Class&lt;?&gt; handlerType, <span class="hljs-keyword">final</span> String methodName, <span class="hljs-keyword">final</span> Class&lt;?&gt;... paramTypes)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">return</span> AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedExceptionAction&lt;Boolean&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>            Method m;<br>            <span class="hljs-keyword">try</span> &#123;<br>                m = handlerType.getMethod(methodName, paramTypes);<br>            &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;<br>                <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>                    logger.debug(<br>                        <span class="hljs-string">&quot;Class &#123;&#125; missing method &#123;&#125;, assume we can not skip execution&quot;</span>, handlerType, methodName, e);<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> m.isAnnotationPresent(Skip.class);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面的源码代码里面可以看到，netty也是用了比较”笨”的方式去生成了executeMask，生成的主要性能开销集中在启动阶段并且添加了一个简单的缓存，所以整体的性能还是很可观的。使用二进制标识多个状态的示例还是很多的例如对象头中的对象状态，有赞权限系统的权限标识等。这里的executeMask也是一个优秀的实现案例。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这一小节，我们深入剖析了Netty的启动源码，我们从NIO服务的基本设计思路入手，分析了组成服务的一些基本要素。随后我们从ServerBootstrap开始，在创建ServerBootstrap阶段配置一些如eventLoop、handler等核心的参数。在最后的bind方法即绑定端口的方法开始真正的服务启动操作，启动的过程主要分为 initAndRegister初始化、bind端口绑定和active操作。其中，initAndRegister主要包括服务初始化、将handler加入到pipeline中、调用pipelineChannelHander的channelRegistered。bind端口绑定即将channel绑定相应的端口，最后就是active操作，active操作包括调用pipelineChannelHandler的channelActive方法和调用read方法完成OP_ACCEPT方法的监听。这些操作都是通过eventLoop的task方式实现。</p>
<blockquote>
<p>在分析源码之前我们提出了下面两个问题，我并没有直接给出答案。看到这里，你是否已经有了答案呢？</p>
<p>NioServerSocketChannel的Handle管道DefaultChannelPipeline是如何添加Handler并触发各种事件的？</p>
<p>在服务启动的过程中，register、bind、active操作是通过EventLoopTask的形式执行的，那他们是如何保证有序的？</p>
</blockquote>
<p>本来这一小节准备是准备I/O就绪操作一起梳理掉，但是这一小节洋洋洒洒已经写了这么多🤣，而且源码这种需要结合代码反复的理解才能消化吃透。因此我就准备把I/O就绪处理放到下一小节，下一小节，我们将开始对连接监听读写操作进行深入剖析。</p>
<h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/35246428/">Netty源码剖析与应用</a></li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/NIO%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">NIO与网络编程</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Java%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84%E6%A2%B3%E7%90%86/">Java知识结构梳理</a>
                    
                      <a class="hover-with-bg" href="/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">学习总结</a>
                    
                      <a class="hover-with-bg" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
                    
                      <a class="hover-with-bg" href="/tags/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">源码剖析</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/12/25/netty-source-code-bytebuf/">
                        <span class="hidden-mobile">Netty核心组件源码剖析 — ByteBuf</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
