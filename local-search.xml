<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JVM GC篇 — 垃圾收集器（上）</title>
    <link href="/2021/06/11/garbage-collector-1/"/>
    <url>/2021/06/11/garbage-collector-1/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面一小节我们介绍了介绍了GC的一般性原理和垃圾回收算法，通过对前面知识的学习，我们基本掌握了垃圾收集的一般理论知识。但是理论终究知识在之上，距离真正的实践还有一定的差距。前面我们提到了第一个带有内存动态分配和垃圾收集的编程语言并不是 Java 而是1960年诞生的Lisp。当然这一小节中我们并不会梳理 Lisp 实现的垃圾收集器。这一小节我们会先从经典垃圾收集器入手，梳理各个垃圾收集器的特性、优缺点和适用场景。当然随着垃圾收集器的效率的不断提升其实现的复杂度也在不断提升。我们会主要的篇幅去介绍CMS和G1原理及部分实现细节，升华对垃圾收集器的理解。今天是六一儿童节，各位朋友坐好来，我们的梳理开始了。😂</p><h2 id="经典垃圾收集器概述"><a href="#经典垃圾收集器概述" class="headerlink" title="经典垃圾收集器概述"></a>经典垃圾收集器概述</h2><p>这里的提到的“经典”并非出于情怀，只是他们的确挺经典，是出于讨论范围的限定。我们这里讨论的是在 JDK 7 Update 4 之后（这个版本中正式提供了商用的 G1 收集器，此前 G1 仍处于实验状态）、JDK 11 正式发布之前，OracleJDK 中提供的 HotSpot 虚拟机所包含的全部可用的垃圾收集器。使用“经典”来描述是为了区分开目前几款正处于实验状态，但执行效果却具有革命性改进的高性能低延迟的垃圾回收器。这些经典的垃圾回收器虽然已经不算是最先进的技术，但是这些经典的垃圾回收器都在生产环境经过千锤百炼，足够成熟，基本上可以认为现在到未来几年内可以在生产环境上放心使用的垃圾收集器，因此掌握他们的特点和配置细节很重要。下图是各个经典垃圾收集器之间的关系。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210602003646.png"></p><p>上面这张图展现了七种作用于不同分代的垃圾回收器，图中垃圾收集器所处的位置则表示他们工作的区域即年轻代或老年代。其中上面<code>Young Generation</code>表示年轻代，下面的<code>Old Generation</code>则代表老年代。如果两个垃圾回收器之间存在连线，则说明他们两个可以搭配使用。</p><blockquote><p>⚠️需要注意的是，这个关系并不是一成不变的，由于维护和兼容性测试的成本，在JDK8时将 Serial+CMS、ParNew+Serial Old这两个组合声明为废弃（JEP173），并在 JDK 9 中完全取消了这些组合的支持（JEP214）。</p></blockquote><p>接下来我们会围绕着这些垃圾回收器的目标、特性、原理和使用场景来了解与分析，并且会着重分析一些CMS和G1的实现细节。这里需要需要先明确一个观点，<strong>目前在 JVM 中没有一个在任何一个场景都表现的很完美的万能垃圾回收器</strong>，如果这样的垃圾回收器存在的话，也就不会出现 HotSpot 中这么多垃圾回收器并存的情况了。 </p><h2 id="Serial收集器（Serial-SerialOld）"><a href="#Serial收集器（Serial-SerialOld）" class="headerlink" title="Serial收集器（Serial + SerialOld）"></a>Serial收集器（Serial + SerialOld）</h2><p>Serial 收集器是最基础、也是历史最悠久的垃圾收集器。<strong>曾经（JDK1.3.1之前）是HotSpot收集器的唯一选择</strong>。从这个名字也不难猜到，这个垃圾收集器是一个<code>单线程工作</code>的垃圾收集器。“单线程”并不仅仅意味着他只会是会用一个处理器或是一个收集线程去完成垃圾收集，它更是要强调<strong>它在进行垃圾回收的时候，必须暂停其他的工作线程（STW）</strong>直到它工作结束。Serial垃圾收集器在年轻代工作使用的<code>标记复制算法（mark-copy）</code>，在工作在老年代的是 SerialOld 垃圾收集器使用<code>标记清除整理算法（mark-sweep-compact）</code>，它的特性和Serial一致都是<code>单线程</code>垃圾收集器。但是这样看似落后的垃圾收集器并没有被废弃。单线程真的就没有优点吗？实际上 Serial 依旧是HotSpot虚拟机运行在客户端模式下的默认垃圾收集器。单线程垃圾收集器虽然和多线程垃圾收集器相比显得低效，但是从另外一个角度来看意味着<strong>简单可靠</strong>，对于内存有限的环境来说<strong>它又是内存消耗最少</strong>的。 对于只有单核的环境活着CPU核心数少的环境来说，减少上下文的切换它又是高效的。因此对于<strong>内存小、CPU核心数少、不会频繁发生垃圾收集的环境，Serial收集器会是一个好的选择。</strong>使用下面的JVM参数即可使用 Serial 垃圾收集器。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-XX:+UseSerialGC</span><br></code></pre></td></tr></table></figure><h2 id="Parallel收集器（Parallel-Scavenge-Parallel-Old）"><a href="#Parallel收集器（Parallel-Scavenge-Parallel-Old）" class="headerlink" title="Parallel收集器（Parallel Scavenge + Parallel Old）"></a>Parallel收集器（Parallel Scavenge + Parallel Old）</h2><p>Parallel 收集器也叫做<code>并行收集器</code>，他能<strong>并行的进行垃圾收集</strong>。<code>Parallel Scavenge</code>是 Parallel 在新生代运行的垃圾收集器，采用的同样也是<code>标记复制算法（mark-copy）</code>，在老年代使用的是 Parallel Old 收集器，使用的也是<code>标记清除整理算法（mark-sweep-compact）</code>。<code>Parallel</code>和<code>Serial</code>一样进行垃圾收集时，<strong>Parallel 在新生代和老年代都会触发STW，但是 Parallel 是采用并行标记，并行垃圾收集，因此STW时间和垃圾收集时间会相较于Serial短很多，垃圾收集速递大幅度提高</strong>。后面我们会介绍 CMS 垃圾收集器，CMS 新生代使用的是 ParNew 这也是一款并行的垃圾收集器，那他们区别是什么呢？Parallel 侧重的更多是可控制<code>吞吐量（Throughput）</code>，而<strong>CMS侧重更短的STW时间</strong>。Parallel也是<code>JDK8的默认垃圾回收器</code></p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210603011802.png"></p><p>Parallel 适用多核心处理处理器，主要目的是增加吞吐量。因为对系统资源的有效使用能达到更高的吞吐量。在GC期间<strong>所有的CPU内核都在并行清理垃圾</strong>，所以总暂停时间更短；在两次GC周期的间隔期，没有GC线程在运行，不会消耗任何系统资源。使用下面的JVM参数即可以开启ParallelGC。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">-XX:+UseParallelGC<br>-XX:+UseParallelOldGC<br>-XX:+UseParallelGC -XX:+UseParallelOldGC<br></code></pre></td></tr></table></figure><p><code>Parallel Scavenge</code>提供了两个参数用于精准控制吞吐量，分别是控制最大垃圾收集时间的<code>-XX:MaxGCPauseMillis</code> 参数，以及直接设置吞吐量大小的 <code>-XX:GCTimeRatio</code>。其中<code>-XX:MaxGCPauseMillis</code> 设置一个大于0的毫秒数，垃圾收集器尽量把垃圾收集时间控制在这个毫秒数内，如果设置过小那么收集器的吞吐量将下降。<code>-XX:GCTimeRatio</code> 这个参数设置一个大于0小于100的整数，<strong>也就是垃圾收集时间占总时间的比率。这个参数设置为N，那么用户代码执行时间与总执行时间之比为</strong><code>N:N+1</code>。例如 <code>—XX:GCTimeRatio=19</code>，那么垃圾收集时间占用总时间的比例为<code>5%(1/(1+ 19))</code>。默认值为99，即1%垃圾回收时间占用。Parallel垃圾收集器是一款高吞吐的垃圾收集器，那它有什么缺点吗？Parallel垃圾收集器工作期间必须暂停其他的工作线程（STW），多个垃圾回收工作线程同时工作，虽然垃圾清理效率很高，但是和其他追求短暂STW的垃圾收集器（CMS、G1、ZGC、Shenandoah）相比还是偏长。并且Parallel收集器的清理速度会随着堆的增大而变慢。</p><blockquote><p>什么是并行和什么又是并发，他们之间有什么区别？</p><p>并行是指利用多个处理器或者多核心处理器同时处理多个不同的任务。</p><p>并发是指一个处理器线程在多个不同的任务之间来回切换来实现“同时执行”。</p></blockquote><h2 id="CMS（ParNew-CMS）"><a href="#CMS（ParNew-CMS）" class="headerlink" title="CMS（ParNew + CMS）"></a>CMS（ParNew + CMS）</h2><p>CMS GC的官方名称为“<strong>Mostly Concurrent Mark and Sweep Garbage Collector</strong>”（最大并发标记清理垃圾收集器）。其中对年轻代使用的是并行的STW方式的标记复制算法（mark-copy），对老年代使用的是并发标记清除算法（标记-清除）。其中CMS的核心是放在老年代，而年轻代使用的 ParNew 垃圾收集器。<strong>ParNew 收集器实质上就是 Serial 收集器的多线程版本</strong>，除了使用多条线程进行垃圾收集之外，其余的行为包括 Serial 垃圾收集器的所有的控制参数、收集算法、STW、对象分配规则、回收策略等都和Serial收集器完全一致。虽然ParNew在不少运行在服务端HotSpot在新生代垃圾收集器的首选。其中一个非常重要的重要的原因就是，<strong>ParNew 是唯一一个除了Serial 之外能和CMS搭配工作的垃圾收集器</strong>。使用下面的JVM参数即可启用CMS：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">+XX:+UseConcMarkSweepGC <span class="hljs-meta">#同时新生代使用ParNew垃圾收集器。</span><br></code></pre></td></tr></table></figure><p>CMS的设计目标<strong>是为了避免在老年代进行垃圾收集时出现长时间卡顿</strong>。</p><blockquote><p>之前我考虑过一个问题，CMS 减少的是老年代的卡顿，但是并没有减少新生代的垃圾收集的卡顿。老年代的GC次数远远少于新生代，为了减少老年代设计的CMS是否有意义？</p><p>当然是有意义的。因为新生代使用的标记复制算法并且存活对象少，在标记和复制阶段的耗时都非常的短，这个时间基本上可以忽略不计。但是在之前的算法中，老年代使用的是标记清除整理算法，并且存活对象很多。这样会有大量的时间浪费在整理上。所以这个阶段的STW时间是很长的。</p></blockquote><p>避免老年代收集器长时间的卡顿，通过两种手段来达成此目标。</p><ul><li><strong>不对老年代进行整理，而是使用空闲列表（free-list）来管理内存空间的回收。</strong></li><li><strong>在标记清理阶段的大部分工作和并发线程一起完成。</strong></li></ul><p>在并发标记阶段并没有明显的应用线程暂停，但是值得注意的是它仍然和应用线程争抢 CPU 时间。默认情况下，<strong>CMS使用的是并发线程数等于 (CPU 核心数 + 3)/4。</strong></p><blockquote><p>这两个手段很好理解。不对老年代进行整理，也就避免了老年代整理带来的长时间STW。对于之前垃圾收集器不管是 Serial 还是 Parallel，在标记阶段或者清理整理阶段都会进行STW，CMS 采用的手段是通过一起并发执行来消除这个阶段的 STW。在解决问题的思路上可以说是很切中要点了。</p></blockquote><p>如果服务器是多核CPU，并且主要调优目标是降低 GC 停顿导致的系统延迟，那么使用 CMS是一个很明知的选择。通过减少每一次GC停顿的时间，能很大程度上改善用户体验。但是<strong>如果CPU资源不是很充足或是受限制的情况下，CMS的吞吐量会出现比较明显的问题</strong>。对于绝大部分系统，CMS 和 Parallel 的吞吐和延迟的差别并不大。</p><h3 id="CMS-垃圾收集阶段过程"><a href="#CMS-垃圾收集阶段过程" class="headerlink" title="CMS 垃圾收集阶段过程"></a>CMS 垃圾收集阶段过程</h3><p>上面提到通过两个主要的手段来达成垃圾收集时的长时间卡顿的目标。但是我们前面提到如果老年代只标记清理不整理这样会产生很多不可用的碎片空间。我们前面还提到并发清理的时候，为了避免引用的变化，其他工作线程都需要进入安全点等待直至垃圾收集结束。那 CMS 是怎样巧妙地处理这些矛盾点呢？我们一起来看看 CMS GC 的几个阶段。</p><h4 id="阶段1：初始标记阶段（inital-mark）（STW）"><a href="#阶段1：初始标记阶段（inital-mark）（STW）" class="headerlink" title="阶段1：初始标记阶段（inital mark）（STW）"></a>阶段1：初始标记阶段（inital mark）（STW）</h4><p>这个阶段<strong>伴随STW暂停</strong>。初始标记的目标是标记所有的根对象，包括根对象直接引用的对象，以及被新生代中所有存活对象所引用的对象（老年代单独回收）。</p><blockquote><p>我们前面提到对新生代进行垃圾收集标记阶段，会把脏卡中的对象（老年代指向新生代引用的对象）加入GC Roots，这里也是类似的处理方向，只不过方向反过来了，把新生代中指向老年代的对象加入GC Roots。</p></blockquote><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210605163034.png"></p><h4 id="阶段2：并发标记（Concurrent-Mark）"><a href="#阶段2：并发标记（Concurrent-Mark）" class="headerlink" title="阶段2：并发标记（Concurrent Mark）"></a>阶段2：并发标记（Concurrent Mark）</h4><p>在这个阶段，CMS GC遍历老年代，标记所有的存活对象，从前一阶段的“Initial Mark”找到的根对象开始算起。“并发标记阶段，就是与应用程序同时运行，不用暂停的阶段（这个阶段没有STW）。⚠️请注意并非所有的老年代中存活的对象都在此阶段被标记，因为在<strong>标记过程中对象的引用关系还在发生这变化。</strong></p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210605164135.png"></p><p>在上面的图中，<code>当前处理对象</code>的一个引用被应用程序给断开了，即这个对象的应用关系发生了变化。那我们要怎么处理这种变化的引用关系呢？先<code>标记脏卡</code>。</p><h4 id="阶段3：并发预处理（Concurrent-Preclean）"><a href="#阶段3：并发预处理（Concurrent-Preclean）" class="headerlink" title="阶段3：并发预处理（Concurrent Preclean）"></a>阶段3：并发预处理（Concurrent Preclean）</h4><p>在这个阶段不需要STW停顿，因为前面一个阶段<code>并发标记</code>与程序一起运行，可能有一些对象的引用关系已经发生了变化。如果在并发标记中引用发生了变化，那么JVM 将通过 Card 的方式将发生改变的区域标记为“脏”卡，这是老年代清理过程中的<code>卡片标记</code>，并发标记在前面一小节有详细的介绍。 <strong>这个阶段还会处理在执行并发标记阶段新进入老年代的对象（新晋升的对象）。</strong></p><blockquote><p>这里的脏卡和我们前面在一般原理和垃圾收集中讲到的脏卡有一些不一样，前面<code>年轻代标记阶段</code>提到的脏卡，是为了避免每次新生代标记的时候避免扫描整个老年代，而是通过每次复制之后修改地址时，顺带标记出老年代对新生代有引用的对象所在的“卡”为脏卡。下次新生代GC时，将脏卡中的对象加入 GC Roots即可。</p><p>这里的<code>CMS中的脏卡</code>是指在CMS 并发标记的过程中引用发生变化卡，在后续垃圾收集过程中进行特别处理。</p><p><code>共同点</code>都是都是JVM老年代的卡片标记技术，标记某个内存块，为后续垃圾收集操作提供标识。</p></blockquote><p>​        <img src="https://gitee.com/realDaiwei/img/raw/master/20210605173345.png">                                       </p><p>在预清理阶段，这些<strong>脏对象会被统计出来，他们所引用的对象也会被标记</strong>，此阶段完成后，用以标记的 card 也会被清空。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210605231002.png"></p><p>这个阶段还会进行一些必要的细节处理，还会为<code>Final Remark</code>做一些准备工作。</p><h4 id="阶段4：可取消的并发预清理（Concurrent-Abortable-Preclean）"><a href="#阶段4：可取消的并发预清理（Concurrent-Abortable-Preclean）" class="headerlink" title="阶段4：可取消的并发预清理（Concurrent Abortable Preclean）"></a>阶段4：可取消的并发预清理（Concurrent Abortable Preclean）</h4><p>这个阶段也不会STW，这个阶段在 STW的Final Remark 之前尽可能地多做一些工作。这个阶段可显著影响STW停顿持续时间。</p><h4 id="阶段5：最终标记阶段（Final-Remark）（STW）"><a href="#阶段5：最终标记阶段（Final-Remark）（STW）" class="headerlink" title="阶段5：最终标记阶段（Final Remark）（STW）"></a>阶段5：最终标记阶段（Final Remark）（<strong>STW</strong>）</h4><p>最终标记阶段是本次GC时间中的第二次（也是最后一次）<strong>STW停顿</strong>。本阶段的目标是完成老年代中所有存活对象的标记。因为之前的预清理阶段是并发执行的，有可能GC线程跟不上应用程序的修改速度。所以需要一次STW暂停来说处理各种复杂的情况。通常 CMS 会尝试在年轻代尽可能空的情况下执行 Final Remark，以免连续触发多次 STW事件。在以上5个阶段完成之后，老年代中的所有存活对象都被标记了，然后GC将清除所有不使用的对象来回收老年代空间。 </p><h4 id="阶段6：并发清除（Concurrent-Sweep）"><a href="#阶段6：并发清除（Concurrent-Sweep）" class="headerlink" title="阶段6：并发清除（Concurrent Sweep）"></a>阶段6：并发清除（Concurrent Sweep）</h4><p>这个阶段不需要 STW停顿，JVM在此阶段清理不再使用的对象，并回收他们占用的内存空间。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210605235328.png"></p><h4 id="阶段7：并发重置（Concurrent-Reset）"><a href="#阶段7：并发重置（Concurrent-Reset）" class="headerlink" title="阶段7：并发重置（Concurrent Reset）"></a>阶段7：并发重置（Concurrent Reset）</h4><p>这个阶段与应用程序并发执行，重置 CMS 算法相关内置数据，并为下次GC循环做好准备。</p><h3 id="汇总四阶段"><a href="#汇总四阶段" class="headerlink" title="汇总四阶段"></a>汇总四阶段</h3><p>有的书上我看介绍 CMS 的垃圾回收步骤只有5步甚至是4步，书中梳理出来的4步分别为：</p><ul><li>初始标记：仅仅标识 GC Root 能直接关联到的对象。（STW）</li><li>并发标记：由初始标记的关联对象遍历标记整个对象图的过程。</li><li>重新标记：修正因为应用线程并发执行，导致的部分标记产生变动的对象的标记。（STW）</li><li>并发清理：清理删除标记阶段判断已经“死亡”的对象。</li><li>（并发重置：重置内部设置）。</li></ul><p>其实这上面的4（5）个阶段和我们前面梳理的七个步骤是差不多的，只是7个阶段多了2个并发预处理的过程，这两个流程都没有进行本质上的标记或者清理，要么是处理脏卡，要么是为最终标记做铺垫。还有最后一个书中是没有的提到的并发重置阶段，这3个阶段都没有做本质上的标记或清理。所以从7个阶段缩减到4个也是可以理解的。CMS 整个过程中也是需要STW的只不过STW的时间很短。大多数时间都是都在并发的进行垃圾回收。</p><h3 id="CMS-的缺点"><a href="#CMS-的缺点" class="headerlink" title="CMS 的缺点"></a>CMS 的缺点</h3><p>CMS是一款优秀的垃圾收集器，但是的优点也很明显并发收集、低停顿。在一些官方文档中也称之为“并发低停顿收集器”，CMS是HotSpot虚拟机追求低停顿的一次成功尝试，但是它还远远达不到成功的程度，至少它有下面三个缺点：</p><ol><li>对处理器资源非常敏感。面向并发设计的程序对处理器都很敏感。</li><li>无法处理<code>“浮动垃圾”（floating garbage）</code>，有可能会出现“Concurrent Mode failed”并发失败进而导致一次完整STW的Serail FullGC。</li></ol><blockquote><p>浮动垃圾指的是在 CMS 并发标记和清理期间，由于应用程序并没有停止运行，这个过程中会有垃圾不断的产生，但这一部分垃圾是出现在标记过程中之后的，因此 CMS 在当轮垃圾回收的过程中没法处理它们，所以这些垃圾只有到下一次垃圾收集时才能处理。这一部分垃圾就成为“浮动垃圾”（floating garbage）因此 CMS 不能等到老年代被填满了才进行垃圾收集，必须为可能产生的浮动垃圾预留一些空间。如果浮动垃圾堆满了预留的空间那就会出现并发失败的问题了。可以通过下面的参数设置当已经使用的空间达到多少时触发 CMS。你可以思考这个参数设置不当会造成什么后果😏。</p></blockquote><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haml">-<span class="ruby"><span class="hljs-symbol">XX:</span>CMSInitiatingOccupancyFraction=<span class="hljs-number">70</span> <span class="hljs-comment">#总使用空间达到70%触发CMS</span></span><br></code></pre></td></tr></table></figure><ol><li>内存碎片，因为CMS采用的是标记清除算法。内存碎片不可避免。内存碎片过多是将给大对象的分配带来麻烦。时常会会为了给大对象分配空间但由于内存碎片而不得不进行一次 FullGC。为了解决这个问题 CMS 提供了两个JVM 参数，但是在 JDK9开始废弃。</li></ol><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haml">-<span class="ruby"><span class="hljs-symbol">XX:</span>UseCMSCompactAtFullCollection <span class="hljs-comment">#默认开启，在CMS不得不FullGC的时候开启内存合并整理。</span></span><br><span class="ruby">-<span class="hljs-symbol">XX:</span>CMSFullGCsBeforeCompaction=n <span class="hljs-comment">#n次FullGC之后，下次FullGC前进行内存碎片整理，默认值0，每次进入FullGC都会进行内存碎片整理。</span></span><br></code></pre></td></tr></table></figure><h2 id="Garbage-First（G1）"><a href="#Garbage-First（G1）" class="headerlink" title="Garbage First（G1）"></a>Garbage First（G1）</h2><p>Garbage First 简称（G1）收集器是垃圾收集技术发展历史上的里程碑的成果，它开创了收集器面向局部收集的思路和<strong>基于Region的内存布局形式</strong>。G1是一款面向服务端的垃圾收集器，HotSpot 开发团队最初赋予它的期望是代替 CMS 垃圾收集器。<strong>在JDK9中G1已经代替 Parallel 收集器成为JDK的默认垃圾收集器</strong>。G1既然作为CMS的挑战者，G1对垃圾收集做出了哪些革命性的变革，G1又是否能很好的解决CMS中存在的问题呢？</p><h3 id="后来者的独门秘籍"><a href="#后来者的独门秘籍" class="headerlink" title="后来者的独门秘籍"></a>后来者的独门秘籍</h3><p>在前面梳理CMS的缺点中，我们发现无法处理<code>浮动垃圾</code>和<code>内存碎片</code>是CMS的硬伤。这些问题G1也要面对，但是G1采用了一种非常巧妙的方式去解决。浮动垃圾，这是与应用线程并发运行的垃圾收集器的通病，这个问题的根本矛盾是<strong>垃圾收集线程在不断进行垃圾收集，与此同时应用线程又在不断产生垃圾，是垃圾生产与垃圾回收之间的不平衡。</strong>这是一个不可调和的矛盾。如果我们用发展的眼光看问题，我们会发现如果浮动<code>垃圾的产生速度&gt;垃圾收集的速度</code>，那么再大的空间都会被迫触发一次FullGC，如果<code>垃圾产生的速度&lt;垃圾收集速度</code>，产生浮动垃圾对整个垃圾收集也不会产生太大的影响。</p><blockquote><p>这就像你妈在打扫房间而你又在一旁制造垃圾，这个时候你妈除了把你胖揍一顿拿你毫无办法。谁让这垃圾收集线程与应用线程之间是要并发的关系呢。解决的办法也很简单，只要你妈打扫卫生的速度大于你生产垃圾的速度，你妈就能把垃圾打扫完并把你胖揍一顿。因此只要<code>内存分配速率 &lt; 垃圾收集速率</code>那么一切都很完美，浮动垃圾随他去吧，。</p></blockquote><p>那么<code>内存碎片的问题</code>，G1是怎么处理的呢？<code>“化整为零”</code>，这个思路很特别，跳出原有的思维束缚。G1的内存结构和传统的内存结构非常的不同，每个内存块还是有Eden区，Survivor区和Old的区的划分。但不再分成年轻代和老年代，而是划分为多个（通常是2048个）可以存放对象的<code>小块内存区域（smaller heap regions）</code>。每一个小块，可能一会被定位为Eden、Survivor或Old区，所有的Eden区拼在一起就是年轻代，所有的Old区拼在一起就是老年代。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210606162329.png"></p><p>除了这些问题上，创新性的解决思路，G1还有一个小目标，<strong>希望能做出一款能够建立起“停顿时间模型”（Pause Prediction Model）的收集器</strong>，停顿时间模型的意思是能够<strong>支持指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集器上的时间大概不会超过N毫秒的这样的目标。</strong></p><p>有了上面的思路的转变对于G1的认知是否有转变呢？面对浮动垃圾的问题，G1没有直面的去解决而是通过提高垃圾回收速率的方式即<code>垃圾回收速率&gt;内存分配速率</code> 的方式来处理。面对前面CMS遇到的内存碎片问题，<strong>G1将整个内存“打碎成块”然后通过整体复制的方式直接避免了内存碎片的产生</strong>。这个解决的方式是不是很巧妙。通过上述的解决方案，再来看G1的小目标。希望能做出一款能够建立起“停顿时间模型”（Pause Prediction Model）的收集器，是不是就有了思路呢？</p><p><strong>只要每次垃圾收集的周期只要收集的垃圾的速率&gt;内存分配速率是不是就可以了呢？是的！每个内存块又是独立的。这样每次GC周期目标就很明确了，只要收集全部的新生代和部分老年代的内存块，并且保证每次GC周期垃圾收集速率 &gt; 内存分配速率。</strong>每次GC周期不用完成所有内存块的垃圾收集工作，停顿时间模型也可以基于G1建立起来，这同时也呼应了这款垃圾收集器的名字 Garbage First。这种设计思路从工程实现上来看是从 G1 上开始兴起，所以说 G1 是收集器发展的一个里程碑。</p><h3 id="G1-遇到的困难及解决方案"><a href="#G1-遇到的困难及解决方案" class="headerlink" title="G1 遇到的困难及解决方案"></a>G1 遇到的困难及解决方案</h3><p>虽然G1提出了前面的很多解决 CMS 遇到问题的理论，但是理论到实现之间还隔着很长一段路。G1从理论走线实践至少有一下三个关键细节问题需要妥善解决。</p><ul><li><strong>跨 Region 之间的引用问题。</strong>根据前面的学习，我们可以知道使用记忆集Remember Set（也就是我们前面提到的Card Table），通过记忆集的方式，可以避免全堆作为 GC Roots 进行扫描。在之前的技术中，不管新生代垃圾收集时用到还是CMS并发标记标记引用变动时用到记忆集，都是简单老年代的标记。但是G1在记忆集中的运用则复杂的多，每一个Region都需要维护着自己的记忆集。里面记录着<strong>别的Region指向自己的指针，并标记着这些指针在哪些范围卡页之内。</strong>Remeber Set 本质的集合是一种 Hash 表，Key 是别的Region的起始地址，Value是一个集合，里面存储的元素卡表的索引号，这种结构不同于卡表，卡表记录的是“我指向谁”，而这种结构记录的更多的是“谁指向我”。这种结构比卡表实现起来更加的复杂，同时Region的数量又比传统收集器分代数量多得多，<strong>因此G1收集器相比其他的传统垃圾收集器有着更高的内存占用负担</strong>，更具经验这个<strong>额外开销大致相当于堆容量的10%～20%。</strong></li></ul><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210606230603.png"></p><ul><li><strong>并发标记阶段如何保证收集线程和用户线程互不干扰的运行。</strong>这里要解决的两个问题，一个是并发的进行标记，用户线程改变对象引用关系时，必须保证其不能打破原本的对象图结构，导致标记结果出现问题。我们可以采用三色标记法解决这个问题，三色标记法在前面一小节《JVM GC篇 — 一般原理与垃圾收集算法》中有详细介绍。此外<strong>垃圾收集对应用线程的影响还体现在回收过程中对象的分配上</strong>，程序要继续运行就要在垃圾回收的过程中创建对象分配内存空间。G1为每个Region设计了<strong>两个名为TAMS（Top at Mark Start）的指针，把一部分空间划分出来用于并发回收过程中新的对象分配</strong>。G1在这个地址上的对象是隐式标记过的，即默认它们是“存活”的，不纳入回收范围。在G1中也有 CMS 中“Concurrent Mode failed”的类似场景，如果<strong>垃圾回收速度赶不上内存分配速度，G1也会被迫进行<code>FullGC</code>，从而导致较长时间的STW。</strong></li><li><strong>如何建立可靠的停顿预测模型。</strong>解决了上面的两个问题还有一个问题怎么建立可靠的停顿预测模型？这是G1设计的小目标，用户通过<code>-XX:MaxGCPauseMillis</code> 参数指定停顿时间只意味着垃圾收集发生之前的期望，但是G1是怎么在垃圾收集时，满足用户的期望值的呢？G1 使用的停顿预测模型是以<code>衰减均值（Decaying Average）</code>，为理论基础来实现的。在垃圾收集的过程中，G1收集器会记录每个 Region 的回收耗时、每个 Region 记忆集里面的脏卡数量等各个<strong>可测量的步骤花费的成本，并且分析得出平均值、标准偏差、置信度等统计信息</strong>。这里强调的“<code>衰减平均值</code>”是指的<strong>它会比普通的平均值更容易收到新数据的影响</strong>，平均值代表整体平均状态，但是平均值更准确地代表了“最近的”平均状态。换句话说，<strong>Region的统计状态越新越能决定其回收的价值</strong>。然后通过这些信息进行分析，完成在<strong>不超过期望停顿时间的约束下达到收集收益的最大化。</strong></li></ul><h3 id="G1-的收集流程"><a href="#G1-的收集流程" class="headerlink" title="G1 的收集流程"></a>G1 的收集流程</h3><p>如果不考虑应用线程在运行过程中的动作（用写屏障维护记忆集操作），G1 的垃圾回收过程可以分为下面四个步骤：</p><ul><li><strong>初始化标记（Inital Marking）</strong>：仅仅是标记下<strong>GC Roots能直接关联到的对象</strong>，并且<strong>修改</strong><code>TAMS</code><strong>指针</strong>的位置的值，让下一个阶段用户线程并发运行的时候，能正确地在<strong>可用的Region中分配对象</strong>，这个阶段需要暂停线程，但耗时很短，而且是借用进行的 Minor GC 的时候同步完成的，所以 G1 收集器在这个阶段实际并没有额外的停顿。</li></ul><blockquote><p>“借用进行的 Minor GC 的时候同步完成的” 这里是Mixed模式的GC 即收集<strong>年轻代和部分老年代</strong>，一次Minor GC之后，老年代占据堆内存的百占比超过InitiatingHeapOccupancyPercent（默认45%）时，就会触发一次 MixedGC</p></blockquote><ul><li><strong>并发标记（Concurrent Marking）</strong>：从GC Root开始对堆中的对象进行可达性分析，<strong>递归扫描整个堆里面的对象图，找出要回收的对象</strong>。这个阶段时间比较长的，可与应用线程并发执行。当扫描完成还要并发时的引用变化，为最终的最终标记阶段处理SATB打下基础。</li><li><strong>最终标记（final Marking）：</strong>对应用线程做一个短暂的暂停，用于<strong>处理并发阶段结束后仍然遗留下的少量的SATB</strong>。</li><li><strong>筛选回收（Living Data Counting and Evacuation）：</strong>负责更新Region的统计数据，对各个Region 的回收价值和成本进行排序，<strong>根据用户期望的停顿时间来制定回收计划</strong>，可以选择任意多个Region构成回收集，然后<strong>把回收集中存活的对象复制到空的 Region 中，再清空整个旧Region空间</strong>。因为在复制对象过程中设计的存活对象的移动，所以必须要暂停应用线程，同时由多个收集器线程并行完成复制过程。这个暂停的过程叫做<strong>转移暂停（Evacuation Pause）</strong></li></ul><blockquote><p>写屏障，这里的写屏障和多线程Java 内存模型中的内存模型不一样，这里的写屏障只是在字节码层面，在执行某个写操作时候一个<strong>类似AOP的结构</strong>，可以将一些操作插入在写入前后。</p></blockquote><h3 id="一个细节-—-单个Region垃圾收集与内存分配的并发策略"><a href="#一个细节-—-单个Region垃圾收集与内存分配的并发策略" class="headerlink" title="一个细节 — 单个Region垃圾收集与内存分配的并发策略"></a>一个细节 — 单个Region垃圾收集与内存分配的并发策略</h3><p>我们前面也梳理了一遍G1的垃圾收集过程，大体上有一个清晰明了的认识，但是有一个细节我始终不明白就是在“G1 遇到的问题中的第二个问题，并发标记阶段如何保证收集线程和用户线程互不干扰的运行。”，里面提到了 <code>G1为每个Region设计了两个名为TAMS（Top at Mark Start）的指针，把一部分空间划分出来用于并发回收过程中新的对象分配。</code> <code>TAMS</code>指针到底是什么？为什么需要两个TAMS 指针才能划出一块空间呢？难道不是一个就可以划分两片区域一片垃圾回收一片分配对象空间就可以了吗？这个问题的本质问题就是<strong>单个Region在并发标记阶段垃圾收集与内存分配之间的并发策略是怎样的？</strong>为了让并发的线程操作Region中的区块，我们需要额外的数据结构协助，两个<code>bitmap</code>和两个指针（<code>TAMS指针</code>）。我们先来看看两个bitMap和他们在并发标记过程中的一些行为动作：</p><blockquote><p>bitMap 在 G1 中是用来标记垃圾位置的，垃圾不会直接在 region 中被标记出来，而是使用一个bitMap来标记待回收对象位置。</p></blockquote><ul><li>这两个<code>bitMap</code>分别是 <code>previousBitMap</code>，<code>nextBitMap</code><strong>。</strong></li><li><code>previousBitMap</code>是<strong>上一轮</strong><code>concurrent marking</code>阶段完成标记后的<strong>没有被回收</strong>的垃圾位置。</li><li><code>nextBitMap</code>是当前正在进行的<code>concurrent marking</code>阶段的bitmap。</li><li>当<code>concurrent marking</code>标记完成后，两个<code>bitmap</code>会交换角色。</li></ul><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210610001206.png"></p><p>bitmap 上面的数组结构（<code>RoaringBitMap</code>和<code>redis</code>中的<code>BitMap</code>都是这样的结构），其中<strong>白色的区域是存活对象，灰色的是待回收的垃圾对象</strong>。除了bitmap我们还需要两个<code>TAMS</code>（Top at Mark Start）指针。接下来我们来看看在垃圾回收各个阶段，这两个指针是怎么配合划分线程进行内存来分配和垃圾回收。</p><ul><li><strong>初始标记阶段</strong>，从下面的图中我们不难发现，初始标记阶段<code>PrevTAMS</code>指针和<code>Bottom</code>指针（<strong>region的初始位置</strong>）位置一致，同时第二个<code>NextTAMS</code>的指针和Top指针位置一致，其中<strong>top指针是已分配的内存和未分配内存的切分点。</strong>同时初始化<code>NextBitMap</code>，由于这是一块干净的Region，因此PrevBitMap是空的。</li></ul><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210610003231.png"></p><ul><li><strong>并发标记和最终阶段</strong>，下面的图是标记完成后Region中的情况，其中GC线程在<code>PrevTAMS</code>和<code>NextTAMS</code><strong>之间进行并发标记</strong>，而<strong>新对象的内存分配在<code>NextTAMS</code>和<code>TOP</code>之间进</strong>行，由于是刚分配的对象GC默认这里的对象都是存活状态。这样就巧妙的解决了垃圾收集和对象内存分配的并发问题。</li></ul><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210610003425.png"></p><ul><li><strong>清理阶段</strong>，最终清理阶段，我们将<code>NextBitMap</code>赋值给<code>PrevBitMap</code>。如果<strong>不进行暂停转移并发清理垃圾对象</strong>即可并<strong>继续使用</strong>这个Region。如果进行<strong>对象转移</strong>，那么将<strong>把存活对象复制到一个新的Region</strong>中并<strong>清空</strong>当前Region。</li></ul><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210610004607.png"></p><ul><li><strong>下一轮初始标记</strong>，同样的我们初始化新的<code>NextBitMap</code>，这里还有一个重要的操作就是<strong>把<code>NextTAMS</code>指向<code>TOP</code>的位置</strong>，告诉GC本轮标记的工作空间范围。然后接下来<code>TAMS</code>和<code>bitMap</code>就按照上面的标记和清理阶段不断循环下去。</li></ul><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210611012152.png"></p><p>接下来Region的中的TAMS指针和bitMap的情况如下图所示。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210610005825.png"></p><p>如果有静态图还是有点懵，整个流程的动图如下 😉</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/17093e8bc74d2cb5.gif"></p><blockquote><p>这个问题我也是看书时候看懵了，为什么需要两个TAMS呢？就像彻底搞清楚这个流程，然后在网上发现了《<a href="https://www.cnblogs.com/thisiswhy/p/12388638.html">面试官问我G1回收器怎么知道你是什么时候的垃圾？</a>》这篇文章，这篇文章写的非常有意思，强烈建议看一遍原文。</p></blockquote><h3 id="G1-中常用的参数"><a href="#G1-中常用的参数" class="headerlink" title="G1 中常用的参数"></a>G1 中常用的参数</h3><ul><li><code>-XX:+UseG1GC</code> ：启用G1 GC，JDK7和JDK8要求必须显示申请启动G1 GC；</li><li><code>-XX:G1NewSizePercent</code> ：初始年轻代占整个Java Heap的大小，默认值为5%；</li><li><code>-XX:G1MaxNewSizePercent</code> ：最大年轻代占整个Java Heap的大小，默认值为60%；</li><li><code>-XX:G1HeapRegionSize</code> ：设置每个Region的大小，单位MB，需要为1，2，4，8，16，32中的某个值，默认是堆内存的1/2000。如果这个值设置比较大，那么大对象就可以进入Region了。</li><li><code>-XX:ConcGCThreads</code> ：与Java应用一起执行的GC线程数量，默认是<strong>Java线程的1/4</strong>，减少这个参数的数值可能会提升并行回收的效率，提高系统内部吞吐量。如果这个数值过低，参与回收垃圾的线程不足，也会导致并行回收机制耗时加长。</li><li><code>-XX:+InitiatingHeapOccupancyPercent</code> （简称IHOP）：G1内部并行回收循环启动的阈值，默认为Java Heap的45%。这个可以理解为老年代使用大于等于45%的时候，JVM会启动垃圾回收。这个值非常重要，它决定了在什么时间启动老年代的并行回收。</li><li><code>-XX:G1HeapWastePercent</code> ：G1停止回收的最小内存大小，默认是堆大小的5%。GC会收集所有的Region中的对象，但是如果下降到了5%，就会停下来不再收集了。就是说，不必每次回收就把所有的垃圾都处理完，可以遗留少量的下次处理，这样也降低了单次消耗的时间。</li><li><code>-XX:G1MixedGCCountTarget</code> ：设置并行循环之后需要有多少个混合GC启动，默认值是8个。老年代Regions的回收时间通常比年轻代的收集时间要长一些。所以如果混合收集器比较多，可以允许G1延长老年代的收集时间。</li><li><code>-XX:+G1PrintRegionLivenessInfo</code> ：这个参数需要和 <code>-XX:+UnlockDiagnosticVMOptions</code> 配合启动，打印JVM的调试信息，每个Region里的对象存活信息。</li><li><code>-XX:G1ReservePercent</code> ：G1为了保留一些空间用于年代之间的提升，默认值是堆空间的10%。因为大量执行回收的地方在年轻代（存活时间较短），所以如果你的应用里面有比较大的堆内存空间、比较多的大对象存活，这里需要保留一些内存。</li><li><code>-XX:+G1SummarizeRSetStats</code> ：这也是一个VM的调试信息。如果启用，会在VM退出的时候打印出RSets的详细总结信息。如果启用 <code>-XX:G1SummaryRSetStatsPeriod</code> 参数，就会阶段性地打印RSets信息。</li><li><code>-XX:+G1TraceConcRefinement</code> ：这个也是一个VM的调试信息，如果启用，并行回收阶段的日志就会被详细打印出来。</li><li><code>-XX:+GCTimeRatio</code> ：大家知道，GC的有些阶段是需要Stop-the-World，即停止应用线程的。这个参数就是计算花在Java应用线程上和花在GC线程上的时间比率，默认是9，跟新生代内存的分配比例一致。这个参数主要的目的是让用户可以控制花在应用上的时间，同样的，G1应用线程和GC花费时间比例的计算公式为<code>1/(1+GCTimeRatio)</code>。这样如果参数设置为9，则最多10%的时间会花在GC工作上面。Parallel GC的默认值是99，表示1%的时间被用在GC上面，这是因为Parallel GC贯穿整个GC，而G1则根据Region来进行划分，不需要全局性扫描整个内存堆。</li></ul><blockquote><p>🤔思考，为什么G1会允许最多10%的时间会花在GC工作上面？这个值还会影响堆空间的大小，当超过预期的时间用在GC上时候，GC会通过适当扩大堆空间的方式来降低GC时间占比。从这个角度来看，G1相比之前的垃圾收集器，在堆扩大的策略上并没有那么激进的。这可能也得益于G1内存Region化的设计和可靠的暂停预测模型。</p></blockquote><ul><li><code>-XX:+UseStringDeduplication</code> ：手动开启Java String对象的去重工作，这个是JDK8u20版本之后新增的参数，主要用于相同String避免重复申请内存，节约Region的使用。</li><li><code>-XX:MaxGCPauseMills</code> ：预期G1每次执行GC操作的暂停时间，单位是毫秒，默认值是200毫秒， G1会尽量保证控制在这个范围内。 </li></ul><p>这里面最重要的参数，就是： </p><ol><li><code> -XX:+UseG1GC</code> ：启用G1 GC； </li><li><code>-XX:+InitiatingHeapOccupancyPercent</code> ：决定什么情况下发生G1 GC； </li><li><code>-XX:MaxGCPauseMills</code> ：期望每次GC暂定的时间，比如我们设置为50，则G1 GC会通过调节每次GC的操作时间，尽量让每次系统的GC停顿都在50上下浮动。如果某次GC时间超过50ms， 比如说100ms，那么系统会自动在后面动态调整GC行为，围绕50毫秒浮动。</li></ol><h2 id="GC选择经验"><a href="#GC选择经验" class="headerlink" title="GC选择经验"></a>GC选择经验</h2><table><thead><tr><th>收集器</th><th>串行、并行或并发</th><th>新生代/老年代</th><th>算法</th><th>目标</th><th>适用场景</th></tr></thead><tbody><tr><td>Serial</td><td>串行</td><td>新生代</td><td>复制算法</td><td>响应速度优先</td><td>单机CPU环境下的Client模式</td></tr><tr><td>Serial Old</td><td>串行</td><td>老年代</td><td>标记-整理</td><td>响应速度优先</td><td>单CPU环境下的Client模式、CMS的后预备方案</td></tr><tr><td>ParNew</td><td>并行</td><td>新生代</td><td>复制算法</td><td>响应速度优先</td><td>多CPU环境下在Server模式下配置CMS使用</td></tr><tr><td>Parallel Scavenge</td><td>并行</td><td>新生代</td><td>复制算法</td><td>吞吐量优先</td><td>在后台计算而不需要太多交互任务</td></tr><tr><td>Parallel Old</td><td>并行</td><td>老年代</td><td>标记-整理</td><td>吞吐量优先</td><td>在后台计算而不需要太多交互任务</td></tr><tr><td>CMS</td><td>并发</td><td>老年代</td><td>标记-清除</td><td>响应速度优先</td><td>集中在互联网或者B/S系统服务端上的Java应用</td></tr><tr><td>G1</td><td>并发</td><td>both</td><td>标记-清除+复制算法</td><td>响应速度优先</td><td>面向服务端应用，将来替换CMS</td></tr></tbody></table><p>综合的看下来，G1是HotSpot JVM 中最先进的<strong>准产品级（production-ready）</strong>垃圾收集器，并且HotSpot 工程师的主要精力都放在不断改进 G1 上，在更新的JDK版本中，将会带来更加强大的功能和优化。作为CMS的替代者，G1弥补了CMS中各种不足，包括暂停时间可预测，并彻底解决了堆内存的碎片化问题。<strong>对于单业务延迟非常敏感的系统来说，如果CPU资源不受限制，G1 是HotSpot 中最好的选择</strong>。当然这些优化和延迟也是要付出代价的。由于G1额外的写屏障和守护线程，G1运行也会消耗比其他垃圾收集器多得多的CPU和内存资源。因此在<strong>小内存，CPU资源比较宽裕，且服务响应速度优先</strong>的应用上，CMS是更好的选择。 </p><blockquote><p>G1 适合大内存，需要较低延迟的场景。</p></blockquote><p>具体场景适合什么样的垃圾收集器，只有尝试了才知道，但是并不是什么时候都能有试的机会，因此我们一般指导原则：</p><ul><li><strong>系统系统吞吐量优先，CPU资源能最大程度处理业务，选择ParallelGC。</strong></li><li><strong>如果系统低延迟优先，每次GC时间尽可能短，但配置资源有限，选择CMS GC。</strong></li><li><strong>如果系统内存大，同时追求整体GC时间可控，选择G1。</strong></li></ul><p>对于内存大小的考量：</p><ul><li>4G以上算比较大的，G1 性价比更高。</li><li>8G以上，非常推荐G1。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>垃圾收集器上篇我写了小两周终于是整理完了。在梳理之前我对CMS和G1内心都是很敬畏的，因为之前对他们的原理和实现的理解都是一知半解模棱两可的。在这次梳理的过程中，我也花了很大的篇幅在介绍说明CMS和G1的原理，我查了很多的资料学习CMS和G1的原理以及部分实现细节，收获非常多。回到总结上，这一小节我们介绍了经典的垃圾收集器，我们先从基础的 Serial（Serial + Serial Old）串行垃圾收集器，Parallel（Parallel Scavenge + Parallel Old）并行垃圾收集器开始，介绍了他们特性、优缺点和适用的场景。开胃菜结束后，我们开始梳理CMS，对CMS的回收过程进行了详细的分析，他们分别是初始标记、并发标记、并发预处理、可取消的并发预处理、最终标记、并发清除、并发重置这7个步骤，总结简化下来4个阶段分别是初始标记、并发标记、最终标记、并发清理。深入理解CMS垃圾收集器的回收流程为G1的回收流程的梳理打下铺垫。我们还介绍了CMS的几个缺点，分别是并发处理对资源敏感、会产生浮动垃圾、标记-清除算法会产生内存碎片。最后一道大菜介绍了我们的G1垃圾收集器，从CMS的痛点入手，分析梳理G1中的解决方案和G1的设计小目标—建立可靠预测暂停模型。随后我们顺着CMS的垃圾回收流程，过了一遍G1的垃圾收集流程，不难发现两者设计一脉相承大同小异。但是梳理了这么多“大”的知识点，没有细节总感觉少了些什么，随后我们梳理了一个细节：单个Region垃圾收集与内存分配的并发策略，来深入理解Region的垃圾回收过程。在G1的最后，我们列出了G1常用的参数以供各位朋友查询配置。在梳理完经典垃圾收集器之后，我们简单聊了聊GC的选择策略，吞吐量选择Parallel，低延迟但内存空间没那么大CMS，内存大GC时间可控选G1。这里插一嘴我个人的看法，我不是很喜欢CMS。它是对低延迟的垃圾收集器的一次成功尝试这不可否认，但是算不上一款成功的垃圾处理器。但是换一个角度想如果没有CMS的尝试，又怎会有后来大成者G1呢？🤔  </p><h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><ul><li>深入理解 Java 虚拟机（第三版）</li><li>常用垃圾收集器的具体实现</li><li><a href="https://www.cnblogs.com/thisiswhy/p/12388638.html">面试官问我G1回收器怎么知道你是什么时候的垃圾？</a></li><li><a href="https://blog.csdn.net/h2604396739/article/details/107957569">G1详解</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>Java知识结构梳理</tag>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM GC篇 — 一般原理与垃圾收集算法</title>
    <link href="/2021/06/01/gc-basic/"/>
    <url>/2021/06/01/gc-basic/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们都知道 Java 程序员不用像 C++ 程序员一样手动申请和释放对象空间，这是因为 JVM 垃圾回收器的存在。为什么需要垃圾回收呢？因为空间是有限的，而我们运行程序完成各种各样的计算需要申请空间。但是空间不是无限的，如果我们的空间不够申请怎么办？这个时候就要释放内存，删除掉一些不用的无效的空间，来腾出空间来创建我们需要的对象。这就像我们的衣柜一样，我们买衣服回来放在衣柜里面，但是衣柜不是无限大的，所以当衣柜放不下的时候，我们就要清理丢掉小了的或者我们不穿的衣服，这样为新的衣服腾出空间。Java 自带GC会自动清理内存空间，而C++这种没有GC的语言，就需要使用手动清理空间了。全自动不用程序员操心的确很好，如果放仍不管也会引起其他的问题，那么怎么清理起来才是正确且高效。这就是一个有意思的问题，这一小节我们将从 GC 的一般原理和垃圾回收算法开始，逐步展开 Java GC 的世界。</p><h2 id="GC一般原理"><a href="#GC一般原理" class="headerlink" title="GC一般原理"></a>GC一般原理</h2><h3 id="手动管理内存"><a href="#手动管理内存" class="headerlink" title="手动管理内存"></a>手动管理内存</h3><p>有C++编程经验或者了解计算机原理的同学很容易就能理解，<code>内存分配</code>和<code>内存释放</code>两个概念，计算机程序在执行过程中，需要有地方存放输入参数、中间变量以及运算结果。通过前面的学习我们知道，这些运行时数据都放在堆栈内存中，栈中的数据的空间会随着栈的创建分配，随着栈空间销毁而释放。但是如果业务处理代码中需要使用到堆内存，这个时候就要注意了。因为空间是有限的，所以使用完的空间要即时释放这样才不会造成内存溢出的问题。因此C++程序员需要手动调用方法完成内存空间的释放。这种内存管理方式我们称为<code>手动内存管理</code>。</p><p>这种管理方式的优点就是<code>简单且高效</code>，因为用完的空间能被立刻释放，直接提高内存空间的使用率。但是缺点也是很明显的，就是如果一旦操作的人多了，容易出现操作不统一，造成<code>内存资源抢占错误</code>或<code>内存错误释放</code>的问题。并且内存空间的管理难度是随着操作方数量地增加而直线上升。在大型复杂的项目中，多线程的内存操作是不避免的，因此手动内存管理的弊端被不断放大。 开发人员就想为什么不设计一个垃圾回收器自动的收集垃圾，这样既可以<strong>减少程序员代码量，也可以尽可能的避免内存溢出</strong>。因此GC顺势而来，其实GC的历史比 Java 还要久远，第一个带有动态分配和GC的语言并不是Java，1960年诞生的Lisp是第一门使用内存动态分配和垃圾收集的编程语言。</p><h3 id="对象已死？"><a href="#对象已死？" class="headerlink" title="对象已死？"></a>对象已死？</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>越是看起来简单的东西，计算机实现起来越是复杂。就比如这个例子，如果判断一个对象已经死亡了。开发小哥哥想到了一个好办法，这个对象我创建的不用了他就死亡了。但是这个方案放在GC上可行么？GC并不知道一个对象什么时候不会在被使用了，所以判断一个对象是否存活，这成为GC设计的第一个困难。遇到困难，正面面对。从对象的引用关系上下手我们很容易想到一个办法。<strong>先创建一个引用计数器，如果这个这个对象有个一地方引用了我们把引用计数器加一，如果不再引用了引用计数器减一</strong>。当某个对象的引用计数器为0的时候就意味着没有地方引用这个对象，即对象已经“死亡”了，可以进行垃圾回收了。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210529164736.png"></p><p>但是这个看似很完美的方案存在弊端嘛？没错就是<code>循环引用</code>的问题，上面这个图是一个对象引用，但是实际中我们创建的对象引用关系可比这个复杂多了。如果对象之间的相互引用，即便其他引用全部移除。引用计数器依旧不为0对象依旧无法回收。如下图其实对象1和对象2已经没有其他的引用了，并且这两个对象相互依赖可以直接进行垃圾回收，但是对象1和对象2的引用不为0，垃圾回收器判断他们还是“存活”状态，从而无法回收这两个对象。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210529171629.png"></p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>引用计数法，虽然乍一看还不错但是有一个很严重的问题<code>循环引用</code>，因此基于引用计数的方式并不准确。那么有没有一个准确且性能也不错的方法来判断对象存活呢？办法不是灵光一线蹦出来的，是基于现实的情况推敲出来的。我们在引用计数法遇到的问题是循环引用。那我们是否可以从对象间互相引用的角度来思考是否能判断对象是否存活呢？答案是可以的。可达性分析，我们可以通过一些列 <code>GC Roots</code>的<strong>根对象作为起始点集合，从这些起始点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某些对象不可达，则证明次对象是不可能在被使用的</strong>。通俗点来说就是通过从一个固定根节点然后遍历所有的关联对象的方式判断某一个对象是否存活。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210530002244.png"></p><p>其中GC Root 包含以下几种：</p><ul><li>在虚拟机栈（栈帧中的本地方法变量表）中引用的对象。</li><li>在方法区中类静态属性引用的对象，譬如Java类中引用类型静态变量。</li><li>在方法去中常量引用的对象，譬如字符串常量池（String table）里的引用。</li><li>在本地方法栈中 JNI（即通常所说的Native方法）引用对象。</li><li>Java 虚拟机内部的引用，如基本数据类型对应的 Class 对象，一些常驻的异常对象等，还有系统类加载器。</li><li>所有被同步锁（synchronzie关键字）持有对象。</li><li>反映Java虚拟机内部情况的 JMXBean，JVMTT中注册的回调、本地代码缓存等。</li></ul><p>除了这些固定的 GC Roots 集合以外，<strong>根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入</strong>，共同构成完整 GC Roots 集合。</p><h4 id="引用与对象生死"><a href="#引用与对象生死" class="headerlink" title="引用与对象生死"></a>引用与对象生死</h4><p>无论前面通过引用计数法判断对象引用数量，还是通过可达性分析算法判对象是否引用链可达来判断对象是否存活，这都和引用离不开关系，在<code>JDK1.2</code>之前的版本中，引用定义非常传统，<strong>如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该 refrence 数据代表某块内存、某个对象的引用。</strong>这种定义并没有什么不对，但是现在看过于狭隘了。引用状态非黑即白，对于一个对象的描述只有两种状态即<code>被引用</code>和<code>未被引用</code>。如果是一种对象在内存充足的时候可以保留，但是在内存紧张的时候可以抛弃的对象，那么这种引用将很难描述，系统中很多缓存对象都符合这种场景。因此在<code>JDK1.2</code>之后，Java对引用的概念进行了扩充，将引用分为<code>强引用（Strongly Refrence）</code>、<code>软引用（Soft Refrence）</code>、<code>弱引用（Week Refrence）</code>、<code>虚引用（Phantom Refrence）</code>，这四种引用关系逐渐减弱。引用的定义通过这四种描述的补充，四种引用关系可以更好的描述引用，更好的协助垃圾回收器判断对象存活状态进行垃圾回收。其中引用与GC动作的描述如下：</p><ul><li><code>强引用</code>是最传统的“引用”的定义，指在程序代码之中普遍存在的引用赋值，<strong>这种引用关系下的对象无论在什么情况下都不会被垃圾回收器回收。</strong></li><li><code>软引用</code>是用来描述一些<code>还有用，但非必须</code>的对象。只被软引用关联着的对象，在系统发生<strong>内存溢出之前，会把这些对象列入到回收范围之中进行第二次回收</strong>。如果这次回收还没有足够的内存，才会抛出OOM异常，<code>JDK1.2版本之后</code>提供<code>SoftRefrence</code>类来实现软引用。 </li><li><code>弱引用</code>也是用来描述那些非必须对象，但是他的强度比软引用要更弱一些。<strong>被软引用关联的对象只能存活到下一次垃圾收集发生为止，不管当前内存是否足够都会被回收。</strong> <code>JDK1.2</code>版本之后提供<code>WeekRefence</code>类来实现弱引用。</li><li><code>虚引用</code>也称为“幽灵引用”和“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在<strong>完全不会对其生存时间构成影响</strong>，也无法通过虚引用来获取一个对象实例。为一个对象设置虚拟引用关联的唯一目的只是为了<strong>能在这个对象被回收时收到一个系统通知</strong>。在<code>JDK1.2</code>版本之后提供了<code>PhantomRefrence</code>类来实现虚引用。</li></ul><p>多种多样引用关系的衍生很像我们平时业务开发过程中，因为某种状态的局限性从而对其进行扩展。从原本的最基本的<code>被引用</code>，拓展为<code>强引用</code>、<code>软引用</code>、<code>弱引用</code>和<code>虚引用</code>四种形式。这四种引用影响垃圾回收器的行为，帮助其高效判断并回收垃圾，从而提高内存空间的利用效率。</p><table><thead><tr><th>引用类型</th><th>对垃圾回收器的影响</th><th>回收时机</th></tr></thead><tbody><tr><td>强引用（strongly refrence）</td><td>无论什么情况下都不会进行回收</td><td>不回收</td></tr><tr><td>软引用（soft refrence）</td><td>内存溢出之前，会把被该引用对象类如回收范围</td><td>内存溢出前回收</td></tr><tr><td>弱引用（week refrence）</td><td>被引用对象存活到下次垃圾回收为止</td><td>下一次垃圾回收时回收</td></tr><tr><td>虚引用（phantom refrence）</td><td>对被引用对象生命周期不产生影响，对象被回收时提供系统通知</td><td>无关联</td></tr></tbody></table><p>前面我们看过了对象的引用关系和引用关系对垃圾回收器的影响。细心的朋友应该发现了上面的引用关系是可达对象。那不可达对象怎么处理呢？直接回收吗？不是的。不可达对象会先被判<code>“死缓”</code>，待回收对象会先判断是否需要执行<code>finalize()</code>方法，如果对象没有重写finalize()方法或者已经执行过finalize()方法，都会视为<code>不需要执行</code>。如果需要执行，对象会被放入一个队列中，依次执行finalize()方法。在执行 finalize() 方法，对象还可以抢救下自己，<strong>只要重新和任何一个引用或者对象建立关联，那么这个对象就会被成功复活</strong>。但是如果在这个阶段没有“成功自救”那就真的被回收了。当然没有 finalize() 方法，那就会被直接被回收。finalize()看似是一个很棒的设计，但是这里也会产生很多的问题。可能会因为队列中对象不能即时处理造成对象没法回收从而造成OOM，甚至如果 finalize() 中有恶性循环，会导致整个内存回收子系统崩溃。<strong>finalize()方法自 JDK9 开始被废弃。</strong></p><blockquote><p>想要深入理解 finalize 机制的可以看这篇文章，虽然是全英文的但看起来压力并没有那么大 <a href="https://plumbr.io/blog/garbage-collection/debugging-to-understand-finalizer">debugging-to-understand-finalizer</a></p></blockquote><h4 id="并发的可达性分析"><a href="#并发的可达性分析" class="headerlink" title="并发的可达性分析"></a>并发的可达性分析</h4><p>很多东西沾上了并发，事情的复杂度也就上去了但是仔细梳理下来也没那么复杂。可达性分析算法理论上要求全过程都是基于能保证一致性的快照中才能进行分析的，这样就意味着需要STW，冻结所有应用线程。在枚举根节点因为GC Roots 是极少数，STW是能接受的。而堆整个堆进行可达性分析时 STW，对于并发的垃圾收集器来说是不能接受的。因此实现并发的可达性分析至关重要。可达性算法归根到底就是图的遍历，那么这个问题可以转化为，<strong>如果在引用处于变化状态下，完成基本准确的遍历。</strong>为什么是基本的呢？因为边是处于变化状态的，基本不可能标记出来的结果百分百准确。在这个场景中，我们要保证一个最基本的原则：<code>可以错标，但是不能漏标记</code>。<strong>如果错标也就会产生一些浮动垃圾，漏标就会导致对象消失会影响应用线程。</strong>那我们要怎么在引用变化的过程中进行动态标记呢？这里我们引入<code>三色标记（Tri-color Marking）</code>，在遍历对象图过程中遇到的对象，我们按照<strong>“是否访问过”</strong>这个条件标记成下面三种颜色。</p><ul><li><strong>白色：</strong>表示尚未被垃圾收集器标访问过。在标记开始时，所有的对象都是白色的，<strong>当标记结束时，如果对象还是白色的那表明对象不可达</strong>。</li><li><strong>黑色</strong>：表示对象已经被垃圾收集器访问过，并且每个这个对象的所有引用都已经扫描过了，如果一个对象是黑色的那它就是<strong>有效的可达对象。</strong>黑色对象不可能直接指向某个白色对象。所以黑色对象不需要重新扫描。</li><li><strong>灰色：</strong>表示对象已经被垃圾收集器扫描过，但是<strong>至少存在一个引用还没有被扫描过。</strong></li></ul><p>在引用关系不变化应用线程冻结的情况下，整个图遍历过程会由几个点开始，然后图会像水波纹一样各个节点从白变成黑。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210607223934.png"></p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210607223854.png"> </p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210607224130.png"></p><p>上面这几张图是在应用线程停止的情况下，如果是在回收线程与应用线程并发，应用线程不断的修改引用关系的情况下，会发生什么情况呢？就像上面我们提到的，我们可以容忍少量的错标（<strong>原本应该回收的对象，但是标记成了黑色</strong>）但不可以容忍漏标（<strong>原本不该被回收的对象，因为没有标记上黑色而被回收</strong>）。来我们一起看看下面两个漏标的情况。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210607230158.png"></p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210607230554.png"></p><p>通过上面的图我们不难发现两种情况都有一个相同问题：<strong>删除了灰色对象到某个白色对象之间的所有引用，并且同时一个标记过的黑色对象指向了这个白色或者这个白色对象所在链上的白色对象</strong>，归纳下来就是两个相同的动作：</p><ul><li><code>赋值器插入了一条或多条从黑色对象到白色对象的新引用。</code></li><li><code>赋值器删除了全部从灰色对象到该白色对象的直接或者间接引用。</code></li></ul><p>当这两个条件同时成立时候，就会产生消失对象。所以只要能破坏两个当中的一个条件问题就解决了。那解决方案有下面两个：</p><ol><li><code>增量更新（Increment Update）</code>：破坏第一个条件，如果发现有从黑色对象指向白色对象的引用，那么就把这个这个引用记录下来，在最后标记STW的时候，以黑色对象为根重新标记一遍，<strong>简单来说就是，黑色对象一旦新插入了白色对象的引用，那么就把这个黑色对象变成灰色，最后在遍历一次。CMS采用的就是这种方式。</strong></li><li><code>原始快照（Snapshot At The Beginning， SATB）</code>：破坏第二个条件，如果发现灰色对象删除指向白色对象的引用，就把这个引用记录下来，并且在最后标记的时候，以当时的灰色对象为根，按照原来的引用关系再标记一次。<strong>简单来说，无论引用关系是否删除，就按照刚开始扫描那一刻的快照进行遍历，G1 采用的是这种方式。</strong></li></ol><blockquote><p>我之前一直在思考一个问题，新分配或新创建的对象怎么办？CMS中在并发标记时候，新晋升的对象刚进入老年代一定是白的，这怎么处理？后来我发现在并发预处理（Concurrent perclean）阶段，会标记一遍晋升对象。G1 的话则采用TAMS（Top at Mark Start）技术默认标记新分配的对象。这样就不会漏标新对象了。</p></blockquote><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p>我们都知道我们对象实例是分配在堆空间中是一块连续的内存，我们会在在创建内存的时候都是在堆空间上分配一个块内存。由于实际情况的不同，每个实例对象的生命周期都不一样。有的对象可能刚分配使用完成就会被回收，有的可能会存在很长一段时间。这样垃圾回收器多次工作下来内存中可能存在多个内存间隙而导致新的对象无法继续分配。这明显不能充分利用有限的堆内存空间装尽可能多的对象。如果将一块完整的堆内存空间切分成多个逻辑空间，每个空间放生命周期不一样的对象，在每个逻辑空间使用不一样的收集策略是否就能尽可能的提高空间的使用率呢？当然是可以的，我们一起往下看。</p><h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><p>当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”（Generational Collection） 的理论进行设计，分代收集虽然是理论，但是实质上是一套符合大多数程序实际运行情况的经验法则，它建立在两代假说的基础之上：</p><ol><li>弱分代假说（Week Generational Hyoothesis）：绝大多数对象那个都是朝生夕灭的。</li><li>强分代假说（Strong Generational Hyoothesis）：熬过多次垃圾回收过程的对象就越难消亡。</li></ol><p>这两个分代假说共同奠定了多款常用的垃圾回收器的一致设计原则：<strong>收集器应该将 Java 划分出不同的区域，然后将回收对象依据其年龄（即熬过的垃圾回收过程的次数）分配到不同的区域之中存储。</strong></p><h3 id="内存区域的划分"><a href="#内存区域的划分" class="headerlink" title="内存区域的划分"></a>内存区域的划分</h3><p>内存的划分也不是一蹴而就的也是慢慢发展来的，在前面的介绍Java 内存结构的小节中我们也简单的介绍了堆中的逻辑划分，这里我们展开聊聊这样划分背后的设计。根据前面的分代收集理论可以按照对象生命周期，将堆空间划分为<code>生命周期短</code>和<code>生命周期长</code>的区域即<code>年轻代</code>和<code>老年代</code>。其中为了更好的提升垃圾回收效率<code>年轻代</code>还划分为<code>伊甸区</code> 和 <code>存活区</code>。为了避免在分配内存空间时线程之间的竞争，伊甸区域为每个线程分配一小块内存空间，确保在线程并发创建对象时空间上的竞争这就是<code>TLAB</code>（Thread Local Allocation Buffer）。大致的内存区域划分图如下。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210530222916.png"></p><h4 id="新生代（Eden-Space）"><a href="#新生代（Eden-Space）" class="headerlink" title="新生代（Eden Space）"></a>新生代（Eden Space）</h4><p>Eden Space，也叫做<code>伊甸区</code>，是内存中的一个区域，用来分配新的对象，通常会有多个线程同时创建多个对象，所以 Eden 区被划分为多个<strong>线程本地分配缓冲区</strong>（Thread Local Allocation Buffer, 简称 TLAB）。通过这种缓冲区划分，大部分对象直接由JVM在对应线程的 TLAB 中分配，避免与其他线程同步操作。如果 TLAB 中没有足够的内存空间，就会在共享 Eden 区（Shared Eden Space）之中进行分配。如果共享的 Eden 区，也没有足够的空间，就会触发一次年轻代的 GC 来释放内存空间，如果 GC 之后 Eden 区依旧没有足够的内存空间，则对象就会被分配到老年代空间（Old Generation）。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210531211459.png"></p><p>当 Eden 区进行垃圾回收的时候，GC 将从 GC Roots 开始把所有的关联的对象都过一遍，并标记为存活对象。<strong>标记完成后会将所有存活的对象都会被复制到存活区（Survivor spaces）</strong>，这个时候就可以认为Eden区域是空的，就可以重新进行对象的分配，这个算法叫做<code>标记复制算法</code>（Mark and Copy）。</p><h4 id="存活区（Survivor-spaces）"><a href="#存活区（Survivor-spaces）" class="headerlink" title="存活区（Survivor spaces）"></a>存活区（Survivor spaces）</h4><p>Eden区旁边两个就是存活区（Survivor space），成为 <code>from空间</code>和 <code>to空间</code>。需要着重强调的是任意一个时刻总有一个存活区是<code>空的（Empty）都是to空间</code>。每次的年轻代的 GC <strong>都会把from区中的存活对象和Eden区中的存活对象复制到</strong><code>to区</code>中，from和to角色切换from变成to，to变成from。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210530235921.png"></p><p>存活的对象会在存活区中来回复制。<strong>复制一次对象存活年龄+1</strong>，按照强分代假设，存活超过一定时间的对象很可能会存活更长时间。这类对象当存活年龄超过<code>当年龄超过提升阈值(tenuring threshold)</code>，就会被<code>提升（Promotion）</code>至老年代区域。当然这个阈值参数是可以调整的，可以通过参数 <code>-XX:+MaxTenuringThreshold</code> 来指定上限。如果设置 <code>-XX:+MaxTenuringThreshold=0</code>，对象不会在存活区之间复制会直接提升到老年代。JVM 中这个阈值的默认值是<code>15个GC周期</code>，如果存活区空间不够存放对象，<code>提升（Promotion）</code>也可能更早地执行。其中<strong>存活区和Eden区的默认比例是 1 : 1 : 8 。</strong></p><h4 id="老年代（Old-Gen）"><a href="#老年代（Old-Gen）" class="headerlink" title="老年代（Old Gen）"></a>老年代（Old Gen）</h4><p>老年代的GC实现要复杂得多。<strong>老年代的内存空间通常会更大，里面的产生垃圾对象的概率也更小，老年代GC发生的频率比年轻代小很多</strong>。同时，因为预期老年代的对象大部分都是存活的，所以不再使用标记和复制（Mark and Copy）算法。而是采用移动对象的方式来实现最小内存碎片。老年代空间的清理算法通常是建立在不同的基础上的。原则上执行以下这些步骤：</p><ul><li>通过标志位（marked bit），标记所有通过 GC Roots 可达对象；</li><li>删除不可达对象；</li><li>整理老年代空间中的内容，方法是所有的存活对象复制，从老年代空间开始的地方依次存放。</li></ul><p>通过上面的描述可知，<strong>老年代GC必须明确地进行整理，以避免内存碎片过多</strong>。这也是<code>标记整理算法</code>。</p><h4 id="永久代（Perm-Gen）"><a href="#永久代（Perm-Gen）" class="headerlink" title="永久代（Perm Gen）"></a>永久代（Perm Gen）</h4><p>在 Java8 之前有一个很特殊的空间，称为“永久代”（Permanent Generation）。这里存储数据（metadata）的地方，比如 class 信息等。此外，这个区域中也保存有其他的数据和信息。包括内部化的字符串（internalized strings）等等。实际上这块内存区域给开发这造成很多的麻烦，因为<strong>很难去计算这块区域到底需要占用多少的空间</strong>，预测失败的结果就是产生<code>java.lang.OutOfMemoryError: Permgen space</code> 这种形式的错误。除非<code>OutOfMemoryError</code> 确实是内存泄漏导致的，否则只能增加 permgen 的大小。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">-XX:MaxPermSize=<span class="hljs-number">256</span>m <span class="hljs-regexp">//</span>permGen 大小设置为<span class="hljs-number">256</span>m，容易发生oom<br></code></pre></td></tr></table></figure><h4 id="元数据区（MataSpace）"><a href="#元数据区（MataSpace）" class="headerlink" title="元数据区（MataSpace）"></a>元数据区（MataSpace）</h4><p>既然估算PermGen需要的空间那么复杂，Java8中索性直接删除了永久代（Permanent Generation）改用<code>MetaSpace</code>他俩本质上还是相同的。从此以后，Java 中很多杂七杂八的东西都放在普通的堆内存中。当然，像类定义（class definitions）之类的信息还是会被加载到 MetaSpace 中。<strong>元数据区域位于本地内存（native memory）</strong>，不再影响到普通的Java对象。<code>默认情况下，MetaSpace 的大小只受限于 Java 进程可用的本地内存。</code>这样的话就避免了 PermGen 因为预测不准确而OOM的尴尬了。但是自由也不是没有限制的，如果 MetaSpace 无限扩张失控，则可能会导致严重的程序性能问题，或者导致本地内存分配失败。为了避免这种事的发生我们还是要限制 MetaSpace 的大小。我们可以通过下面的方式限制其大小。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">-XX:MaxMetaspaceSize=<span class="hljs-number">512</span>m <span class="hljs-regexp">//</span> 设置metaSpace空间大小为<span class="hljs-number">512</span>m<br></code></pre></td></tr></table></figure><h3 id="垃圾收集算法设计与应用"><a href="#垃圾收集算法设计与应用" class="headerlink" title="垃圾收集算法设计与应用"></a>垃圾收集算法设计与应用</h3><p>前面讲了很多的东西都是铺垫，但是空中楼阁不可能腾空而起，没有绿叶又哪来鲜花。我们来一起鸟瞰全局体会垃圾回收算法在设计的精妙之处。我们通过前面的梳理，我们对堆空间进行了逻辑上的划分，分成了<code>年轻代</code>和<code>老年代</code>，而年轻代存放的都是朝生夕死的对象。老年代则存放一些不容易被清理掉生命周期长的对象。年轻代又有两个幸存区配合垃圾回收，我们已经知道了我们内存布局了。接下来我们试着进行垃圾回收。首先我们要标记出已经“死亡”的对象，通过可达性算法分析我们很清楚标记出来的就是不可达的对象。年轻代和老年代根据我们清理目标空间的需要进行标记。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210530223844.png"></p><p>这个标记的过程中，即需要暂停所有应用线程以遍历所有对象的引用关系，因为我们无法追踪不断发生变化的引用关系。等确定这些引用关系后，应用线程又能继续执行。这个暂停的过程叫做<code>Stop The World pause（全线程暂停）</code>，简称为<code>STW</code>。线程也不可能在执行的过程中突然停下来，而是需要运行可以安全停下来的点，这些可以停下来的地方叫做<code>安全点（safe point）</code>，然后标记完成后 JVM 就可以安心处理垃圾了。</p><p>这里有一个有意思的问题：<strong>如果一个新生代的对象有且只被一个老年代的对象引用，我们在年轻代进行GC时，我们该怎么判断该对象是存活的？</strong></p><p>如果我们仅仅扫描年轻代，这个对象一定是一个不可达对象，因为它被有且仅被一个老年代对象引用。难道我们进行一次年轻代GC连老年代也要扫一遍？如果扫，时间消耗太大，不扫，一定会出现这种误判的情况。那该怎么办？我们可以通过<code>找脏卡</code>的方式解决这个问题。什么是脏卡？这是 HotSpot 中一项叫卡表（card table）的技术中的一个名词。该技术<strong>将整个堆划分为一个个大小为 512 字节的卡</strong>，并且维护一个卡表，用来存储每张卡的一个标识位。这个标识位代表对应的卡<strong>是否可能存有指向新生代对象的引用</strong>。如果可能存在，那么我们就认为这张卡是<strong>脏</strong>的<strong>。在进行年轻代GC的时候，我们便可以</strong>不用扫描整个老年代，而是在卡表中寻找脏卡<strong>，并将脏卡中的对象加入到年轻代GC的 GC Roots 里</strong>。<strong>当完成所有</strong>脏卡的扫描之后<strong>，Java 虚拟机便会将所有脏卡的标识位清零</strong>。由于年轻代GC伴随着存活对象的复制，而复制需要更新指向该对象的引用。因此，<strong>在更新引用的同时，我们又会设置引用所在的卡的标识位</strong>。这个时候，我们可以确保脏卡中必定包含指向新生代对象的引用。</p><blockquote><p>脏卡是包含指向新生代引用的卡，年轻代GC，不扫描老年代而是寻找脏卡并加入到年轻代GC Roots中，扫描完脏卡后表示位即脏卡去脏，复制算法后存活对象地址变化，重新老年代中引用变化是同时设置脏卡标志。这个过程随着GC周期不断循环下去。</p></blockquote><h4 id="标记-清除算法（Mark-and-Sweep）"><a href="#标记-清除算法（Mark-and-Sweep）" class="headerlink" title="标记-清除算法（Mark and Sweep）"></a>标记-清除算法（Mark and Sweep）</h4><p>标记完成后我们进行简单的清理可以得到类似下面的图。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210531231800.png"></p><p>可以看到上面图中，在一段连续的内存空间中，我们依次有<code>obj1到obj6</code>这6个对象。这6个对象之间不一定是紧紧靠在一起的，而是部分对象之间是有“间隙”的。在可达性分析算法标记过后，我们发现 obj1，obj2, obj5为对象不可达即“死亡对象”。然后我们对这死亡的对象进行清理。清理完成后就得到了下面这个图（这里不考虑 finalize() 方法对垃圾回收过程产生的影响）。这个其实就是垃圾回收算法中的<code>标记-清除算法（Mark and Sweep）</code> ，这个过程很简单简单分成下面两步：</p><ul><li><strong>通过可达性算法标记出不可达对象即“死亡对象”。</strong></li><li><strong>“清理”不可达对象。</strong></li></ul><p>这里有一个细节，这里的“清理”并不是真正的清理，而是<strong>将死亡对象的内存空间地址记录到空闲表（free-list）上，然后直接使用这块空间进行空间分配。</strong></p><h4 id="清理过程中的一个小问题"><a href="#清理过程中的一个小问题" class="headerlink" title="清理过程中的一个小问题"></a>清理过程中的一个小问题</h4><p>不知道你有没有发现一个问题，这里的空间内存虽然是记录在空闲表<code>free-list</code>上，但是新来一个对象可能不一定能分配的了。因为这个空间不是连续的，来一个对象可能比空间表 free-list 上所有的空闲空间都要大，但是所有的空闲空间加在一起又完全足够让这个对象进行分配，这个问题是不是就很难受？别急还有更难受的，别忘了我们可以通过GC也就是上面这个过程释放空间，GC完成后很顺利，刚好有一个对象被释放，一段连续的内存刚好够放下这个对象。我们放松一口气。这时又来了一个对象，这个对象和上一个对象遇到了同样的问题，这是我们该怎么办？GC？这时刚GC完成，应该是没有空间可以释放的，报OOM让程序员小哥哥解决？明明我们还有空间啊，只不过都是不连续的碎片空间。我们在这个场景中遇到的小问题就是<strong>因为标记清除算法在清除完毕后不对空间进行整理，导致GC之后产生很多的不连续的碎片空间，这些碎片空间无法进行空间分配从而导致OOM的发生。</strong>我们该怎么解决这个办法呢？</p><h4 id="标记-清除-整理算法（Mark-Sweep-Compact）"><a href="#标记-清除-整理算法（Mark-Sweep-Compact）" class="headerlink" title="标记-清除-整理算法（Mark-Sweep-Compact）"></a>标记-清除-整理算法（Mark-Sweep-Compact）</h4><p>面对上面的问题其实最简单的办法就是在清理完成后我们整理下内存空间，把还存活的对象再次排好。有了整理部分的加入后上面的过程变成下面这样：</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210531235410.png"></p><p>这个算法就是垃圾回收算法中的<code>标记-清除-整理算法（Mark-Sweep-Compact）</code>也称作 <code>Compact压缩算法</code>。压缩算法分为下面三步，其中前面两步和标记-清除算法一致。</p><ul><li><strong>通过可达性算法标记出不可达对象即“死亡对象”。</strong></li><li><strong>“清理”不可达对象。</strong></li><li><strong>整理压缩对象空间。</strong></li></ul><p>这个方案很完美，因为这个相较于标记-清理算法多了一步，这一步虽然压缩了对象，空闲空间也变成<strong>连续的空间提升了空间的利用率</strong>。但是多这一步的操作也为<strong>增加了</strong>每次GC复杂度<strong>增加每次的GC耗时。而老年代对象基本上都是存活对象且空间更大，发生GC的概率更低</strong>，因此<strong>压缩算法更多的用在了老年代。</strong></p><h4 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h4><p>上面的压缩算法的弊端是整理空间增加了GC的时间复杂度，有没有优化的方案呢？有的，在算法中我们经常会使用空间换时间的思想增加程序的空间复杂度来降低时间复杂度。这里我们可以直接<strong>将所有的存活对象复制另外一个内存空间中，原本的内存空间直接清空</strong>。复制过去的对象内存空间是连续的，我们还可以在新空出来的空间分配对象，这个复制过去的目标空间就是我们前面提到的<code>存活区（Survivor space）</code>，这个GC算法也就是我们前面提到的<code>标记复制算法</code>（Mark and Copy）</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210530235921.png"></p><p>在实际使用中配合新生代Eden区和来回复制的两个Survivor存活区，实现高效的复制算法。因此复制算法分为以下三步：</p><ul><li><strong>通过可达性算法标记出不可达对象即“死亡对象”。</strong></li><li><strong>复制存活对象到Survivor的to区。</strong></li><li><strong>清空Eden区和Survivor的from区，并且from和to区对换。（逻辑上的清空和对换）</strong></li></ul><p>复制算法的时间复杂度要明显优于压缩算法，因此复制算法更加适合“节奏更快”的年轻代。<strong>复制算法是运用在年轻代的GC算法。</strong></p><blockquote><p>新生代发生的GC 我们一般成为<code>MinorGC</code>或者<code>YoungGC</code>，老年代发生的GC我们一般称为<code>MajorGC</code>或<code>OldGC</code>，而<code>FullGC</code>则是老年代和新生代都触发的GC。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一小节我们从最原始的手动管理内存开始，简单分析其利弊之后，我们逐步开始走向自动的垃圾回收机制，第一个垃圾回收机器并不是诞生在Java语言上，在进行垃圾回收之前我们要做的第一件事不是清理回收，而是判断一个对象是“活着”还是已经“死亡”。这里我们简单介绍了引用计数法。在用计数法解决不了循环引用之后，我们介绍了可达性分析算法，通过一些列GC Roots 判断某个对象是否可达从而判断这个对象是否存活。为了更好的进行垃圾回收，引用的两种状态引用和被引用显然不能很好的描述引用的类型状态，因此我们引入了强引用、软引用、弱引用和虚引用，顺便提了这几种引用对垃圾回收器行为的影响。接下来我们进入垃圾回收算法，在正式介绍算法之前我们聊了聊分代收集理论。为了更高效的进行垃圾回收，JVM依据对象的“存活时间”的长短，分为年轻代、老年代和永生代以及后续替代永生代的元数据区。并为了更好的配合垃圾回收器的工作又将年轻代切分成新生代和存活代。最后我们结合图文简单介绍标记清除、标记整理（压缩算法）和复制算法。简单明了的说明了各种算法的特点和工作的内存区域。我们还提到了一些细节不要忘了哦，我们即将被淘汰的 finalize() 方法对垃圾回收的一丢丢影响和即将在垃圾回收器中大放异彩的卡表设计。</p><p>今天这小节内容很基础但是梳理下来真的很多也画了不少图，按照自己的逻辑走一遍下来真的透彻了很多。九层之台，起于累土。加油～。</p><h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><ul><li>极客时间专栏《深入理解 Java 虚拟机—垃圾回收（上）》</li><li>极客时间专栏《深入理解 Java 虚拟机—垃圾回收（下）》</li><li>常见的的GC算法（GC的背景与原理）</li><li>深入理解 Java 虚拟机（第三版）</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>Java知识结构梳理</tag>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 监控与诊断工具</title>
    <link href="/2021/05/26/jvm-monitor-tool/"/>
    <url>/2021/05/26/jvm-monitor-tool/</url>
    
    <content type="html"><![CDATA[<blockquote><p>😏 前方多图多代码块预警！！！</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java 虚拟机是一个复杂的系统，如果这个复杂的系统是一个黑盒子，那一旦出现了问题那将是非常棘手的，我们将没有任何的方式方法来定位问题，这是不可接受的。因此 JDK 内置了很多的工具去诊断分析问题，这里面不仅包括一些命令行工具还有一些图形化工具，比如命令行有常见的 <code>jps</code>、<code>jinfo</code>、<code>jstat</code>、<code>jmap</code>等，图形化工具也有 <code>jconsole</code>、<code>jvisualvm</code>、<code>jmc</code>等。当然实际上生产上这类工具用的还是比较少的。这些工具了就好比是菜刀队了，而正常情况下我们定位问题都是有机枪大炮的。在工具完备准备充分的情况下，我们通常会使用 Prometheus 配上集成可视化工具 Grafana 或 DataDog。出现问题之后，会使用一些分析工具，如 <code>Eclipse MAT</code>再结合一些在线工具进行数据分析如 GCEasy 和 FastThread。</p><h2 id="为什么需要监控，监控的又是什么？"><a href="#为什么需要监控，监控的又是什么？" class="headerlink" title="为什么需要监控，监控的又是什么？"></a>为什么需要监控，监控的又是什么？</h2><p>我们的重要工作之一就是要保证我们写出来的程序是正确的且健壮的，不能因为一些小小的问题代码就变得不可用，这是不能接受的。但是我们如何发现我们的系统出现了异样呢？很简单就是监控它，类比到人类世界，就是我们的小区保安是如何增强我们的安全感的呢？也是通过监控的手段，只不过保安监控的是小区内部的情况，而我们监控的是JVM的运行指标。这些指标包括一些常见的运行时数据，比如我们前面提到的堆栈的占用数据，以及我们后面会提到的GC有关数据，当然还有我们服务器本身的内存和 CPU 负载情况等。只有有了这些数据，我们才能还原异常情况发生时的系统环境。这就是像是还原凶杀现场一样刺激。分享一个真实的案例，我们公司之前的系统是没有监控的，所有的服务就是一个单体系统并且整体代码质量也不高，有一次上线一个版本然后第二天下午业务高峰的时候，JVM 突然开始宕机所有服务全部挂掉。当时我们是单体服务，JVM 也没有配置任何的可以导出堆栈信息的JVM参数，但是业务是在高峰期不能停，所以我们只有重启，重启完过了10分钟继续挂掉，然后接着重启，服务长时间处于不可用状态。这就像是凶案现场凶手作案后，凶杀现场却一丝痕迹都没留下，不仅杀伤力巨大而且侮辱性极强。 所以再回到这个问题上来，为什么需要监控，<code>因为我们要保证系统的稳定运行、需要对系统进行性能分析、需要在系统出现异常时保留足够的信息，系统的监控必不可少。</code></p><h2 id="JDK-内置工具"><a href="#JDK-内置工具" class="headerlink" title="JDK 内置工具"></a>JDK 内置工具</h2><p>我们这里主要要监控的是JVM，虽然一般第一直觉想到的都是一些高大上的监控工具，但是JDK本身也提供了很多的工具。这里面不仅有命令行工具还有一些图形化工具。</p><h3 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h3><blockquote><p>以下的测试全部基于 jdk11 输出结果，测试使用 jdk8 时基本全部翻车。</p></blockquote><h4 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h4><p>jps 查看当前系统中的 Java 进程。这个命令存在用户权限隔离，也就是 root 用户能看到所有的 Java 进程，其他的用户只能看到自己的 Java 的进程。这里可以看到我启动了 HelloServer 和 CxfDemoApplication 其中前面的数字 5455 和 5350 是他们的<code>pid</code>。</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs fsharp">daiwei@daiweideMacBook-Pro ~ % jps -help<br>usage: jps [-help]<br>       jps [-q] [-mlvV] <span class="hljs-meta">[&lt;hostid&gt;]</span><br><br>Definitions:<br>    &lt;hostid&gt;:      &lt;hostname&gt;[:&lt;port&gt;]<br>    <br>daiwei@daiweideMacBook-Pro ~ % jps<br><span class="hljs-number">5780</span> Jps<br><span class="hljs-number">5350</span> CxfDemoApplication<br><span class="hljs-number">1560</span> RemoteMavenServer36<br><span class="hljs-number">394</span><br><span class="hljs-number">5454</span> Launcher<br><span class="hljs-number">5455</span> HelloServer<br></code></pre></td></tr></table></figure><h4 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h4><p>这个命令的全程是 Java Configuration Info，所以它的主要作用是实时查看和调整JVM配置参数。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs gradle">daiwei@daiweideMacBook-Pro ~ % jinfo -help<br>Usage:<br>    jinfo [option] &lt;pid&gt;<br>        (to connect to running process)<br>    jinfo [option] &lt;executable &lt;core&gt;<br>        (to connect to a core <span class="hljs-keyword">file</span>)<br>    jinfo [option] [server_id@]&lt;remote server IP or hostname&gt;<br>        (to connect to remote debug server)<br><br>where &lt;option&gt; is one of:<br>    -flag &lt;name&gt;         to <span class="hljs-keyword">print</span> the value of the named VM flag<br>    -flag [+|-]&lt;name&gt;    to enable or disable the named VM flag<br>    -flag &lt;name&gt;=&lt;value&gt; to set the named VM flag to the given value<br>    -flags               to <span class="hljs-keyword">print</span> VM flags<br>    -sysprops            to <span class="hljs-keyword">print</span> Java system properties<br>    &lt;no option&gt;          to <span class="hljs-keyword">print</span> both of the above<br>    -h | -help           to <span class="hljs-keyword">print</span> <span class="hljs-keyword">this</span> help message<br>daiwei@daiweideMacBook-Pro ~ % jinfo -flalgs <span class="hljs-number">8386</span><br>Java System Properties:<br>#Thu May <span class="hljs-number">20</span> <span class="hljs-number">23</span>:<span class="hljs-number">25</span>:<span class="hljs-number">31</span> CST <span class="hljs-number">2021</span><br>java.<span class="hljs-keyword">runtime</span>.name=Java(TM) SE <span class="hljs-keyword">Runtime</span> Environment<br>sun.boot.library.path=<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span>jdk1.<span class="hljs-number">8.0</span>_231.jdk<span class="hljs-regexp">/Contents/</span>Home<span class="hljs-regexp">/jre/</span>lib<br>java.vm.version=<span class="hljs-number">25.231</span>-b11<br>gopherProxySet=<span class="hljs-keyword">false</span><br>java.vm.vendor=Oracle Corporation<br>java.vendor.url=http\:<span class="hljs-comment">//java.oracle.com/</span><br>path.separator=\:<br>java.vm.name=Java HotSpot(TM) <span class="hljs-number">64</span>-Bit Server VM<br><span class="hljs-keyword">file</span>.encoding.pkg=sun.io<br>user.country=CN<br>sun.java.launcher=SUN_STANDARD<br>sun.os.patch.level=unknown<br>java.vm.specification.name=Java Virtual Machine Specification<br>user.dir=<span class="hljs-regexp">/Users/</span>daiwei<span class="hljs-regexp">/github/</span>thinking-in-code<br>java.<span class="hljs-keyword">runtime</span>.version=<span class="hljs-number">1.8</span>.<span class="hljs-number">0</span>_231-b11<br>java.awt.graphicsenv=sun.awt.CGraphicsEnvironment<br>java.endorsed.dirs=<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span>jdk1.<span class="hljs-number">8.0</span>_231.jdk<span class="hljs-regexp">/Contents/</span>Home<span class="hljs-regexp">/jre/</span>lib/endorsed<br>os.arch=x86_64<br>java.io.tmpdir=<span class="hljs-regexp">/var/</span>folders<span class="hljs-regexp">/4_/</span>dbqw6z6100535snfk5508v080000gn<span class="hljs-regexp">/T/</span><br>line.separator=\n<br>java.vm.specification.vendor=Oracle Corporation<br>os.name=Mac OS X<br>sun.jnu.encoding=UTF-<span class="hljs-number">8</span><br>java.library.path=<span class="hljs-regexp">/Users/</span>daiwei<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/Extensions\:/</span>Library<span class="hljs-regexp">/Java/</span>Extensions\:<span class="hljs-regexp">/Network/</span>Library<span class="hljs-regexp">/Java/</span>Extensions\:<span class="hljs-regexp">/System/</span>Library<span class="hljs-regexp">/Java/</span>Extensions\:<span class="hljs-regexp">/usr/</span>lib/java\:.<br>sun.nio.ch.bugLevel=<br>java.specification.name=Java Platform API Specification<br>java.<span class="hljs-keyword">class</span>.version=<span class="hljs-number">52.0</span><br>sun.management.compiler=HotSpot <span class="hljs-number">64</span>-Bit Tiered Compilers<br>os.version=<span class="hljs-number">10.16</span><br>user.home=<span class="hljs-regexp">/Users/</span>daiwei<br>user.timezone=Asia/Shanghai<br>java.awt.printerjob=sun.lwawt.macosx.CPrinterJob<br><span class="hljs-keyword">file</span>.encoding=UTF-<span class="hljs-number">8</span><br>java.specification.version=<span class="hljs-number">1.8</span><br>java.<span class="hljs-keyword">class</span>.path=<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span>jdk1.<span class="hljs-number">8.0</span>_231.jdk<span class="hljs-regexp">/Contents/</span>Home<span class="hljs-regexp">/jre/</span>lib<span class="hljs-regexp">/charsets.jar\:/</span>Library<span class="hljs-regexp">/Java/</span>JavaVirtualMachines<span class="hljs-regexp">/jdk1.8.0_231.jdk/</span>Contents<span class="hljs-regexp">/Home/</span>jre<span class="hljs-regexp">/lib/</span>deploy.jar\:<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span>jdk1.<span class="hljs-number">8.0</span>_231.jdk<span class="hljs-regexp">/Contents/</span>Home<span class="hljs-regexp">/jre/</span>lib<span class="hljs-regexp">/ext/</span>cldrdata.jar\:<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span>jdk1.<span class="hljs-number">8.0</span>_231.jdk<span class="hljs-regexp">/Contents/</span>Home<span class="hljs-regexp">/jre/</span>lib<span class="hljs-regexp">/ext/</span>dnsns.jar\:<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span>jdk1.<span class="hljs-number">8.0</span>_231.jdk<span class="hljs-regexp">/Contents/</span>Home<span class="hljs-regexp">/jre/</span>lib<span class="hljs-regexp">/ext/</span>jaccess.jar\:<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span>jdk1.<span class="hljs-number">8.0</span>_231.jdk<span class="hljs-regexp">/Contents/</span>Home<span class="hljs-regexp">/jre/</span>lib<span class="hljs-regexp">/ext/</span>jfxrt.jar\:<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span>jdk1.<span class="hljs-number">8.0</span>_231.jdk<span class="hljs-regexp">/Contents/</span>Home<span class="hljs-regexp">/jre/</span>lib<span class="hljs-regexp">/ext/</span>localedata.jar\:<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span>jdk1.<span class="hljs-number">8.0</span>_231.jdk<span class="hljs-regexp">/Contents/</span>Home<span class="hljs-regexp">/jre/</span>lib<span class="hljs-regexp">/ext/</span>nashorn.jar\:<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span>jdk1.<span class="hljs-number">8.0</span>_231.jdk<span class="hljs-regexp">/Contents/</span>Home<span class="hljs-regexp">/jre/</span>lib<span class="hljs-regexp">/ext/</span>sunec.jar\:<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span>jdk1.<span class="hljs-number">8.0</span>_231.jdk<span class="hljs-regexp">/Contents/</span>Home<span class="hljs-regexp">/jre/</span>lib<span class="hljs-regexp">/ext/</span>sunjce_provider.jar\:<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span>jdk1.<span class="hljs-number">8.0</span>_231.jdk<span class="hljs-regexp">/Contents/</span>Home<span class="hljs-regexp">/jre/</span>lib<span class="hljs-regexp">/ext/</span>sunpkcs11.jar\:<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span>jdk1.<span class="hljs-number">8.0</span>_231.jdk<span class="hljs-regexp">/Contents/</span>Home<span class="hljs-regexp">/jre/</span>lib<span class="hljs-regexp">/ext/</span>zipfs.jar\:<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span>jdk1.<span class="hljs-number">8.0</span>_231.jdk<span class="hljs-regexp">/Contents/</span>Home<span class="hljs-regexp">/jre/</span>lib<span class="hljs-regexp">/javaws.jar\:/</span>Library<span class="hljs-regexp">/Java/</span>JavaVirtualMachines<span class="hljs-regexp">/jdk1.8.0_231.jdk/</span>Contents<span class="hljs-regexp">/Home/</span>jre<span class="hljs-regexp">/lib/</span>jce.jar\:<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span>jdk1.<span class="hljs-number">8.0</span>_231.jdk<span class="hljs-regexp">/Contents/</span>Home<span class="hljs-regexp">/jre/</span>lib<span class="hljs-regexp">/jfr.jar\:/</span>Library<span class="hljs-regexp">/Java/</span>JavaVirtualMachines<span class="hljs-regexp">/jdk1.8.0_231.jdk/</span>Contents<span class="hljs-regexp">/Home/</span>jre<span class="hljs-regexp">/lib/</span>jfxswt.jar\:<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span>jdk1.<span class="hljs-number">8.0</span>_231.jdk<span class="hljs-regexp">/Contents/</span>Home<span class="hljs-regexp">/jre/</span>lib<span class="hljs-regexp">/jsse.jar\:/</span>Library<span class="hljs-regexp">/Java/</span>JavaVirtualMachines<span class="hljs-regexp">/jdk1.8.0_231.jdk/</span>Contents<span class="hljs-regexp">/Home/</span>jre<span class="hljs-regexp">/lib/m</span>anagement-agent.jar\:<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span>jdk1.<span class="hljs-number">8.0</span>_231.jdk<span class="hljs-regexp">/Contents/</span>Home<span class="hljs-regexp">/jre/</span>lib<span class="hljs-regexp">/plugin.jar\:/</span>Library<span class="hljs-regexp">/Java/</span>JavaVirtualMachines<span class="hljs-regexp">/jdk1.8.0_231.jdk/</span>Contents<span class="hljs-regexp">/Home/</span>jre<span class="hljs-regexp">/lib/</span>resources.jar\:<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span>jdk1.<span class="hljs-number">8.0</span>_231.jdk<span class="hljs-regexp">/Contents/</span>Home<span class="hljs-regexp">/jre/</span>lib<span class="hljs-regexp">/rt.jar\:/</span>Library<span class="hljs-regexp">/Java/</span>JavaVirtualMachines<span class="hljs-regexp">/jdk1.8.0_231.jdk/</span>Contents<span class="hljs-regexp">/Home/</span>lib<span class="hljs-regexp">/ant-javafx.jar\:/</span>Library<span class="hljs-regexp">/Java/</span>JavaVirtualMachines<span class="hljs-regexp">/jdk1.8.0_231.jdk/</span>Contents<span class="hljs-regexp">/Home/</span>lib<span class="hljs-regexp">/dt.jar\:/</span>Library<span class="hljs-regexp">/Java/</span>JavaVirtualMachines<span class="hljs-regexp">/jdk1.8.0_231.jdk/</span>Contents<span class="hljs-regexp">/Home/</span>lib<span class="hljs-regexp">/javafx-mx.jar\:/</span>Library<span class="hljs-regexp">/Java/</span>JavaVirtualMachines<span class="hljs-regexp">/jdk1.8.0_231.jdk/</span>Contents<span class="hljs-regexp">/Home/</span>lib<span class="hljs-regexp">/jconsole.jar\:/</span>Library<span class="hljs-regexp">/Java/</span>JavaVirtualMachines<span class="hljs-regexp">/jdk1.8.0_231.jdk/</span>Contents<span class="hljs-regexp">/Home/</span>lib<span class="hljs-regexp">/packager.jar\:/</span>Library<span class="hljs-regexp">/Java/</span>JavaVirtualMachines<span class="hljs-regexp">/jdk1.8.0_231.jdk/</span>Contents<span class="hljs-regexp">/Home/</span>lib<span class="hljs-regexp">/sa-jdi.jar\:/</span>Library<span class="hljs-regexp">/Java/</span>JavaVirtualMachines<span class="hljs-regexp">/jdk1.8.0_231.jdk/</span>Contents<span class="hljs-regexp">/Home/</span>lib<span class="hljs-regexp">/tools.jar\:/U</span>sers<span class="hljs-regexp">/daiwei/gi</span>thub<span class="hljs-regexp">/thinking-in-code/</span>thinking-in-grpc<span class="hljs-regexp">/target/</span>classes\:<span class="hljs-regexp">/Users/</span>daiwei<span class="hljs-regexp">/.m2/</span>repository<span class="hljs-regexp">/io/g</span>rpc<span class="hljs-regexp">/grpc-netty-shaded/</span><span class="hljs-number">1.34</span>.<span class="hljs-number">1</span><span class="hljs-regexp">/grpc-netty-shaded-1.34.1.jar\:/U</span>sers<span class="hljs-regexp">/daiwei/</span>.m2<span class="hljs-regexp">/repository/i</span>o<span class="hljs-regexp">/grpc/g</span>rpc-core<span class="hljs-regexp">/1.34.1/g</span>rpc-core-<span class="hljs-number">1.34</span>.<span class="hljs-number">1</span>.jar\:<span class="hljs-regexp">/Users/</span>daiwei<span class="hljs-regexp">/.m2/</span>repository<span class="hljs-regexp">/com/g</span>oogle<span class="hljs-regexp">/android/</span>annotations<span class="hljs-regexp">/4.1.1.4/</span>annotations-<span class="hljs-number">4.1</span>.<span class="hljs-number">1.4</span>.jar\:<span class="hljs-regexp">/Users/</span>daiwei<span class="hljs-regexp">/.m2/</span>repository<span class="hljs-regexp">/io/</span>perfmark<span class="hljs-regexp">/perfmark-api/</span><span class="hljs-number">0.19</span>.<span class="hljs-number">0</span><span class="hljs-regexp">/perfmark-api-0.19.0.jar\:/U</span>sers<span class="hljs-regexp">/daiwei/</span>.m2<span class="hljs-regexp">/repository/i</span>o<span class="hljs-regexp">/grpc/g</span>rpc-protobuf<span class="hljs-regexp">/1.34.1/g</span>rpc-protobuf-<span class="hljs-number">1.34</span>.<span class="hljs-number">1</span>.jar\:<span class="hljs-regexp">/Users/</span>daiwei<span class="hljs-regexp">/.m2/</span>repository<span class="hljs-regexp">/io/g</span>rpc<span class="hljs-regexp">/grpc-api/</span><span class="hljs-number">1.34</span>.<span class="hljs-number">1</span><span class="hljs-regexp">/grpc-api-1.34.1.jar\:/U</span>sers<span class="hljs-regexp">/daiwei/</span>.m2<span class="hljs-regexp">/repository/i</span>o<span class="hljs-regexp">/grpc/g</span>rpc-context<span class="hljs-regexp">/1.34.1/g</span>rpc-context-<span class="hljs-number">1.34</span>.<span class="hljs-number">1</span>.jar\:<span class="hljs-regexp">/Users/</span>daiwei<span class="hljs-regexp">/.m2/</span>repository<span class="hljs-regexp">/com/g</span>oogle<span class="hljs-regexp">/code/</span>findbugs<span class="hljs-regexp">/jsr305/</span><span class="hljs-number">3.0</span>.<span class="hljs-number">2</span><span class="hljs-regexp">/jsr305-3.0.2.jar\:/U</span>sers<span class="hljs-regexp">/daiwei/</span>.m2<span class="hljs-regexp">/repository/</span>com<span class="hljs-regexp">/google/</span>protobuf<span class="hljs-regexp">/protobuf-java/</span><span class="hljs-number">3.14</span>.<span class="hljs-number">0</span><span class="hljs-regexp">/protobuf-java-3.14.0.jar\:/U</span>sers<span class="hljs-regexp">/daiwei/</span>.m2<span class="hljs-regexp">/repository/</span>com<span class="hljs-regexp">/google/</span>api<span class="hljs-regexp">/grpc/</span>proto-google-common-protos<span class="hljs-regexp">/1.17.0/</span>proto-google-common-protos-<span class="hljs-number">1.17</span>.<span class="hljs-number">0</span>.jar\:<span class="hljs-regexp">/Users/</span>daiwei<span class="hljs-regexp">/.m2/</span>repository<span class="hljs-regexp">/io/g</span>rpc<span class="hljs-regexp">/grpc-protobuf-lite/</span><span class="hljs-number">1.34</span>.<span class="hljs-number">1</span><span class="hljs-regexp">/grpc-protobuf-lite-1.34.1.jar\:/U</span>sers<span class="hljs-regexp">/daiwei/</span>.m2<span class="hljs-regexp">/repository/</span>com<span class="hljs-regexp">/google/gu</span>ava<span class="hljs-regexp">/guava/</span><span class="hljs-number">29.0</span>-android<span class="hljs-regexp">/guava-29.0-android.jar\:/U</span>sers<span class="hljs-regexp">/daiwei/</span>.m2<span class="hljs-regexp">/repository/</span>com<span class="hljs-regexp">/google/gu</span>ava<span class="hljs-regexp">/failureaccess/</span><span class="hljs-number">1.0</span>.<span class="hljs-number">1</span><span class="hljs-regexp">/failureaccess-1.0.1.jar\:/U</span>sers<span class="hljs-regexp">/daiwei/</span>.m2<span class="hljs-regexp">/repository/</span>com<span class="hljs-regexp">/google/gu</span>ava<span class="hljs-regexp">/listenablefuture/</span><span class="hljs-number">9999.0</span>-empty-to-avoid-conflict-with-guava<span class="hljs-regexp">/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar\:/U</span>sers<span class="hljs-regexp">/daiwei/</span>.m2<span class="hljs-regexp">/repository/</span>org<span class="hljs-regexp">/checkerframework/</span>checker-compat-qual<span class="hljs-regexp">/2.5.5/</span>checker-compat-qual-<span class="hljs-number">2.5</span>.<span class="hljs-number">5</span>.jar\:<span class="hljs-regexp">/Users/</span>daiwei<span class="hljs-regexp">/.m2/</span>repository<span class="hljs-regexp">/com/g</span>oogle<span class="hljs-regexp">/j2objc/</span>j2objc-annotations<span class="hljs-regexp">/1.3/</span>j2objc-annotations-<span class="hljs-number">1.3</span>.jar\:<span class="hljs-regexp">/Users/</span>daiwei<span class="hljs-regexp">/.m2/</span>repository<span class="hljs-regexp">/com/g</span>oogle<span class="hljs-regexp">/errorprone/</span>error_prone_annotations<span class="hljs-regexp">/2.3.4/</span>error_prone_annotations-<span class="hljs-number">2.3</span>.<span class="hljs-number">4</span>.jar\:<span class="hljs-regexp">/Users/</span>daiwei<span class="hljs-regexp">/.m2/</span>repository<span class="hljs-regexp">/org/</span>codehaus<span class="hljs-regexp">/mojo/</span>animal-sniffer-annotations<span class="hljs-regexp">/1.18/</span>animal-sniffer-annotations-<span class="hljs-number">1.18</span>.jar\:<span class="hljs-regexp">/Users/</span>daiwei<span class="hljs-regexp">/.m2/</span>repository<span class="hljs-regexp">/io/g</span>rpc<span class="hljs-regexp">/grpc-stub/</span><span class="hljs-number">1.34</span>.<span class="hljs-number">1</span><span class="hljs-regexp">/grpc-stub-1.34.1.jar\:/U</span>sers<span class="hljs-regexp">/daiwei/</span>.m2<span class="hljs-regexp">/repository/</span>com<span class="hljs-regexp">/google/</span>protobuf<span class="hljs-regexp">/protobuf-java-util/</span><span class="hljs-number">3.12</span>.<span class="hljs-number">0</span><span class="hljs-regexp">/protobuf-java-util-3.12.0.jar\:/U</span>sers<span class="hljs-regexp">/daiwei/</span>.m2<span class="hljs-regexp">/repository/</span>com<span class="hljs-regexp">/google/</span>code<span class="hljs-regexp">/gson/g</span>son<span class="hljs-regexp">/2.8.6/g</span>son-<span class="hljs-number">2.8</span>.<span class="hljs-number">6</span>.jar\:<span class="hljs-regexp">/Applications/I</span>ntelliJ IDEA.app<span class="hljs-regexp">/Contents/</span>lib/idea_rt.jar<br>user.name=daiwei<br>java.vm.specification.version=<span class="hljs-number">1.8</span><br>sun.java.command=io.daiwei.grpc.HelloServer<br>java.home=<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span>jdk1.<span class="hljs-number">8.0</span>_231.jdk<span class="hljs-regexp">/Contents/</span>Home/jre<br>sun.arch.data.model=<span class="hljs-number">64</span><br>user.language=zh<br>java.specification.vendor=Oracle Corporation<br>awt.toolkit=sun.lwawt.macosx.LWCToolkit<br>java.vm.info=mixed mode<br>java.version=<span class="hljs-number">1.8</span>.<span class="hljs-number">0</span>_231<br>java.ext.dirs=<span class="hljs-regexp">/Users/</span>daiwei<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/Extensions\:/</span>Library<span class="hljs-regexp">/Java/</span>JavaVirtualMachines<span class="hljs-regexp">/jdk1.8.0_231.jdk/</span>Contents<span class="hljs-regexp">/Home/</span>jre<span class="hljs-regexp">/lib/</span>ext\:<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/Extensions\:/</span>Network<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/Extensions\:/</span>System<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/Extensions\:/u</span>sr<span class="hljs-regexp">/lib/</span>java<br>sun.boot.<span class="hljs-keyword">class</span>.path=<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span>jdk1.<span class="hljs-number">8.0</span>_231.jdk<span class="hljs-regexp">/Contents/</span>Home<span class="hljs-regexp">/jre/</span>lib<span class="hljs-regexp">/resources.jar\:/</span>Library<span class="hljs-regexp">/Java/</span>JavaVirtualMachines<span class="hljs-regexp">/jdk1.8.0_231.jdk/</span>Contents<span class="hljs-regexp">/Home/</span>jre<span class="hljs-regexp">/lib/</span>rt.jar\:<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span>jdk1.<span class="hljs-number">8.0</span>_231.jdk<span class="hljs-regexp">/Contents/</span>Home<span class="hljs-regexp">/jre/</span>lib<span class="hljs-regexp">/sunrsasign.jar\:/</span>Library<span class="hljs-regexp">/Java/</span>JavaVirtualMachines<span class="hljs-regexp">/jdk1.8.0_231.jdk/</span>Contents<span class="hljs-regexp">/Home/</span>jre<span class="hljs-regexp">/lib/</span>jsse.jar\:<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span>jdk1.<span class="hljs-number">8.0</span>_231.jdk<span class="hljs-regexp">/Contents/</span>Home<span class="hljs-regexp">/jre/</span>lib<span class="hljs-regexp">/jce.jar\:/</span>Library<span class="hljs-regexp">/Java/</span>JavaVirtualMachines<span class="hljs-regexp">/jdk1.8.0_231.jdk/</span>Contents<span class="hljs-regexp">/Home/</span>jre<span class="hljs-regexp">/lib/</span>charsets.jar\:<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span>jdk1.<span class="hljs-number">8.0</span>_231.jdk<span class="hljs-regexp">/Contents/</span>Home<span class="hljs-regexp">/jre/</span>lib<span class="hljs-regexp">/jfr.jar\:/</span>Library<span class="hljs-regexp">/Java/</span>JavaVirtualMachines<span class="hljs-regexp">/jdk1.8.0_231.jdk/</span>Contents<span class="hljs-regexp">/Home/</span>jre/classes<br>java.vendor=Oracle Corporation<br><span class="hljs-keyword">file</span>.separator=/<br>java.vendor.url.bug=http\:<span class="hljs-comment">//bugreport.sun.com/bugreport/</span><br>sun.io.unicode.encoding=UnicodeBig<br>sun.cpu.endian=little<br>sun.cpu.isalist=<br><br>VM Flags:<br>-XX:CICompilerCount=<span class="hljs-number">4</span> -XX:InitialHeapSize=<span class="hljs-number">268435456</span> -XX:MaxHeapSize=<span class="hljs-number">4294967296</span> -XX:MaxNewSize=<span class="hljs-number">1431306240</span> -XX:MinHeapDeltaBytes=<span class="hljs-number">524288</span> -XX:NewSize=<span class="hljs-number">89128960</span> -XX:OldSize=<span class="hljs-number">179306496</span> -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:+UseParallelGC<br><br>VM Arguments:<br>jvm_args: -javaagent:<span class="hljs-regexp">/Applications/I</span>ntelliJ IDEA.app<span class="hljs-regexp">/Contents/</span>lib<span class="hljs-regexp">/idea_rt.jar=51341:/</span>Applications<span class="hljs-regexp">/IntelliJ IDEA.app/</span>Contents/bin -Dfile.encoding=UTF-<span class="hljs-number">8</span><br>java_command: io.daiwei.grpc.HelloServer<br>java_class_path (initial): <span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span>jdk1.<span class="hljs-number">8.0</span>_231.jdk<span class="hljs-regexp">/Contents/</span>Home<span class="hljs-regexp">/jre/</span>lib<span class="hljs-regexp">/charsets.jar:/</span>Library<span class="hljs-regexp">/Java/</span>JavaVirtualMachines<span class="hljs-regexp">/jdk1.8.0_231.jdk/</span>Contents<span class="hljs-regexp">/Home/</span>jre<span class="hljs-regexp">/lib/</span>deploy.jar:<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span>jdk1.<span class="hljs-number">8.0</span>_231.jdk<span class="hljs-regexp">/Contents/</span>Home<span class="hljs-regexp">/jre/</span>lib<span class="hljs-regexp">/ext/</span>cldrdata.jar:<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span>jdk1.<span class="hljs-number">8.0</span>_231.jdk<span class="hljs-regexp">/Contents/</span>Home<span class="hljs-regexp">/jre/</span>lib<span class="hljs-regexp">/ext/</span>dnsns.jar:<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span>jdk1.<span class="hljs-number">8.0</span>_231.jdk<span class="hljs-regexp">/Contents/</span>Home<span class="hljs-regexp">/jre/</span>lib<span class="hljs-regexp">/ext/</span>jaccess.jar:<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span>jdk1.<span class="hljs-number">8.0</span>_231.jdk<span class="hljs-regexp">/Contents/</span>Home<span class="hljs-regexp">/jre/</span>lib<span class="hljs-regexp">/ext/</span>jfxrt.jar:<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span>jdk1.<span class="hljs-number">8.0</span>_231.jdk<span class="hljs-regexp">/Contents/</span>Home<span class="hljs-regexp">/jre/</span>lib<span class="hljs-regexp">/ext/</span>localedata.jar:<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span>jdk1.<span class="hljs-number">8.0</span>_231.jdk<span class="hljs-regexp">/Contents/</span>Home<span class="hljs-regexp">/jre/</span>lib<span class="hljs-regexp">/ext/</span>nashorn.jar:<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span>jdk1.<span class="hljs-number">8.0</span>_231.jdk<span class="hljs-regexp">/Contents/</span>Home<span class="hljs-regexp">/jre/</span>lib<span class="hljs-regexp">/ext/</span>sunec.jar:<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span>jdk1.<span class="hljs-number">8.0</span>_231.jdk<span class="hljs-regexp">/Contents/</span>Home<span class="hljs-regexp">/jre/</span>lib<span class="hljs-regexp">/ext/</span>sunjce_provider.jar:<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span>jdk1.<span class="hljs-number">8.0</span>_231.jdk<span class="hljs-regexp">/Contents/</span>Home<span class="hljs-regexp">/jre/</span>lib<span class="hljs-regexp">/ext/</span>sunpkcs11.jar:<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span>jdk1.<span class="hljs-number">8.0</span>_231.jdk<span class="hljs-regexp">/Contents/</span>Home<span class="hljs-regexp">/jre/</span>lib<span class="hljs-regexp">/ext/</span>zipfs.jar:<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span>jdk1.<span class="hljs-number">8.0</span>_231.jdk<span class="hljs-regexp">/Contents/</span>Home<span class="hljs-regexp">/jre/</span>lib<span class="hljs-regexp">/javaws.jar:/</span>Library<span class="hljs-regexp">/Java/</span>JavaVirtualMachines<span class="hljs-regexp">/jdk1.8.0_231.jdk/</span>Contents<span class="hljs-regexp">/Home/</span>jre<span class="hljs-regexp">/lib/</span>jce.jar:<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span>jdk1.<span class="hljs-number">8.0</span>_231.jdk<span class="hljs-regexp">/Contents/</span>Home<span class="hljs-regexp">/jre/</span>lib<span class="hljs-regexp">/jfr.jar:/</span>Library<span class="hljs-regexp">/Java/</span>JavaVirtualMachines<span class="hljs-regexp">/jdk1.8.0_231.jdk/</span>Contents<span class="hljs-regexp">/Home/</span>jre<span class="hljs-regexp">/lib/</span>jfxswt.jar:<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span>jdk1.<span class="hljs-number">8.0</span>_231.jdk<span class="hljs-regexp">/Contents/</span>Home<span class="hljs-regexp">/jre/</span>lib<span class="hljs-regexp">/jsse.jar:/</span>Library<span class="hljs-regexp">/Java/</span>JavaVirtualMachines<span class="hljs-regexp">/jdk1.8.0_231.jdk/</span>Contents<span class="hljs-regexp">/Home/</span>jre<span class="hljs-regexp">/lib/m</span>anagement-agent.jar:<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span>jdk1.<span class="hljs-number">8.0</span>_231.jdk<span class="hljs-regexp">/Contents/</span>Home<span class="hljs-regexp">/jre/</span>lib<span class="hljs-regexp">/plugin.jar:/</span>Library<span class="hljs-regexp">/Java/</span>JavaVirtualMachines<span class="hljs-regexp">/jdk1.8.0_231.jdk/</span>Contents<span class="hljs-regexp">/Home/</span>jre<span class="hljs-regexp">/lib/</span>resources.jar:<span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span>jdk1.<span class="hljs-number">8.0</span>_231.jdk<span class="hljs-regexp">/Contents/</span>Home<span class="hljs-regexp">/jre/</span>lib<span class="hljs-regexp">/rt.jar:/</span>Library<span class="hljs-regexp">/Java/</span>JavaVirtualMachines<span class="hljs-regexp">/jdk1.8.0_231.jdk/</span>Contents<span class="hljs-regexp">/Home/</span>lib<span class="hljs-regexp">/ant-javafx.jar:/</span>Library<span class="hljs-regexp">/Java/</span>JavaVirtualMachines<span class="hljs-regexp">/jdk1.8.0_231.jdk/</span>Contents/Home<br>Launcher Type: SUN_STANDARD<br></code></pre></td></tr></table></figure><h4 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h4><p>这是我个人比较喜欢的一个命令，也是用的稍微多那么一些的命令，就像这个名字一样，jstat 可以输出一些 jvm 的状态信息。其中主要用它可以实时地输出 GC 有关数据。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs dns">daiwei@daiweideMacBook-Pro ~ % jstat<br>Usage: jstat --help|-options<br>       jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]<br><br>Definitions:<br>  &lt;option&gt;      An option reported by the -options option<br>  &lt;vmid&gt;        Virtual Machine Identifier. <span class="hljs-keyword">A</span> vmid takes the following form:<br>                     &lt;lvmid&gt;[@&lt;hostname&gt;[:&lt;port&gt;]]<br>                Where &lt;lvmid&gt; is the local vm identifier for the target<br>                Java virtual machine, typically a process id<span class="hljs-comment">; &lt;hostname&gt; is</span><br>                the name of the host running the target Java virtual machine<span class="hljs-comment">;</span><br>                and &lt;port&gt; is the port number for the rmiregistry on the<br>                target host. See the jvmstat documentation for a more complete<br>                description of the Virtual Machine Identifier.<br>  &lt;lines&gt;       Number of samples between header lines.<br>  &lt;interval&gt;    Sampling interval. The following forms are allowed:<br>                    &lt;n&gt;[&quot;ms&quot;|&quot;s&quot;]<br>                Where &lt;n&gt; is an integer and the suffix specifies the units as<br>                milliseconds(&quot;ms&quot;) or seconds(&quot;s&quot;). The default units are &quot;ms&quot;.<br>  &lt;count&gt;       Number of samples to take before terminating.<br>  -J&lt;flag&gt;      Pass &lt;flag&gt; directly to the runtime system.<br>  -? -h --help  Prints this help message.<br>  -help         Prints this help message.<br>  <br>daiwei@daiweideMacBook-Pro ~ % jstat -options<br>-class                          # 类加载（Class loader）信息统计<br>-compiler                       # JIT即时编译器相关统计信息<br>-gc                                 # GC相关的堆内存信息，用法 jstat -gc -h <span class="hljs-number">10</span> -t <span class="hljs-number">864</span> <span class="hljs-number">1</span>s <span class="hljs-number">20</span><br>-gccapacity                 # 各个内存池分代空间的容量<br>-gccause                        # 看上次GC，本次GC（如果正在GC中）的原因，其他输出和 -gcutil 的选项一致<br>-gcmetacapacity     # 元数据区大小统计<br>-gcnew                          # 年轻代的统计信息，（NEW = YOUNG = Eden + S0 + S1）<br>-gcnewcapacity          # 年轻代空间大小统计<br>-gcold                          # 老年代和元数据区的行为统计<br>-gcoldcapacity          # 老年代的空间统计<br>-gcutil                         # GC相关区域的使用率（utillization）统计<br>-printcompilation       # 打印JVM编译统计信息 <br><br><br>jstat -gcutil <span class="hljs-number">11064 1000</span> <span class="hljs-number">15</span><br>  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT<br> <span class="hljs-number">37</span>.<span class="hljs-number">50</span>   <span class="hljs-number">0</span>.<span class="hljs-number">00</span>  <span class="hljs-number">26</span>.<span class="hljs-number">20</span>   <span class="hljs-number">5</span>.<span class="hljs-number">81</span>  <span class="hljs-number">97</span>.<span class="hljs-number">40</span>  <span class="hljs-number">94</span>.<span class="hljs-number">92</span>    <span class="hljs-number">156</span>    <span class="hljs-number">0</span>.<span class="hljs-number">200</span>     <span class="hljs-number">0</span>    <span class="hljs-number">0</span>.<span class="hljs-number">000</span>     -        -    <span class="hljs-number">0</span>.<span class="hljs-number">200</span><br> <span class="hljs-number">37</span>.<span class="hljs-number">50</span>   <span class="hljs-number">0</span>.<span class="hljs-number">00</span>  <span class="hljs-number">99</span>.<span class="hljs-number">77</span>   <span class="hljs-number">5</span>.<span class="hljs-number">81</span>  <span class="hljs-number">97</span>.<span class="hljs-number">40</span>  <span class="hljs-number">94</span>.<span class="hljs-number">92</span>    <span class="hljs-number">156</span>    <span class="hljs-number">0</span>.<span class="hljs-number">200</span>     <span class="hljs-number">0</span>    <span class="hljs-number">0</span>.<span class="hljs-number">000</span>     -        -    <span class="hljs-number">0</span>.<span class="hljs-number">200</span><br> <span class="hljs-number">43</span>.<span class="hljs-number">75</span>   <span class="hljs-number">0</span>.<span class="hljs-number">00</span>   <span class="hljs-number">0</span>.<span class="hljs-number">00</span>   <span class="hljs-number">6</span>.<span class="hljs-number">00</span>  <span class="hljs-number">96</span>.<span class="hljs-number">34</span>  <span class="hljs-number">94</span>.<span class="hljs-number">93</span>    <span class="hljs-number">164</span>    <span class="hljs-number">0</span>.<span class="hljs-number">209</span>     <span class="hljs-number">0</span>    <span class="hljs-number">0</span>.<span class="hljs-number">000</span>     -        -    <span class="hljs-number">0</span>.<span class="hljs-number">209</span><br>  <span class="hljs-number">0</span>.<span class="hljs-number">00</span>  <span class="hljs-number">43</span>.<span class="hljs-number">75</span>   <span class="hljs-number">0</span>.<span class="hljs-number">00</span>   <span class="hljs-number">6</span>.<span class="hljs-number">18</span>  <span class="hljs-number">96</span>.<span class="hljs-number">34</span>  <span class="hljs-number">94</span>.<span class="hljs-number">93</span>    <span class="hljs-number">171</span>    <span class="hljs-number">0</span>.<span class="hljs-number">216</span>     <span class="hljs-number">0</span>    <span class="hljs-number">0</span>.<span class="hljs-number">000</span>     -        -    <span class="hljs-number">0</span>.<span class="hljs-number">216</span><br> <span class="hljs-number">50</span>.<span class="hljs-number">00</span>   <span class="hljs-number">0</span>.<span class="hljs-number">00</span>  <span class="hljs-number">49</span>.<span class="hljs-number">84</span>   <span class="hljs-number">6</span>.<span class="hljs-number">34</span>  <span class="hljs-number">96</span>.<span class="hljs-number">34</span>  <span class="hljs-number">94</span>.<span class="hljs-number">93</span>    <span class="hljs-number">178</span>    <span class="hljs-number">0</span>.<span class="hljs-number">223</span>     <span class="hljs-number">0</span>    <span class="hljs-number">0</span>.<span class="hljs-number">000</span>     -        -    <span class="hljs-number">0</span>.<span class="hljs-number">223</span><br>  <span class="hljs-number">0</span>.<span class="hljs-number">00</span>  <span class="hljs-number">37</span>.<span class="hljs-number">50</span>  <span class="hljs-number">53</span>.<span class="hljs-number">75</span>   <span class="hljs-number">6</span>.<span class="hljs-number">49</span>  <span class="hljs-number">96</span>.<span class="hljs-number">34</span>  <span class="hljs-number">94</span>.<span class="hljs-number">93</span>    <span class="hljs-number">185</span>    <span class="hljs-number">0</span>.<span class="hljs-number">231</span>     <span class="hljs-number">0</span>    <span class="hljs-number">0</span>.<span class="hljs-number">000</span>     -        -    <span class="hljs-number">0</span>.<span class="hljs-number">231</span><br>  <span class="hljs-number">0</span>.<span class="hljs-number">00</span>  <span class="hljs-number">50</span>.<span class="hljs-number">00</span>   <span class="hljs-number">0</span>.<span class="hljs-number">00</span>   <span class="hljs-number">6</span>.<span class="hljs-number">69</span>  <span class="hljs-number">96</span>.<span class="hljs-number">34</span>  <span class="hljs-number">94</span>.<span class="hljs-number">93</span>    <span class="hljs-number">193</span>    <span class="hljs-number">0</span>.<span class="hljs-number">239</span>     <span class="hljs-number">0</span>    <span class="hljs-number">0</span>.<span class="hljs-number">000</span>     -        -    <span class="hljs-number">0</span>.<span class="hljs-number">239</span><br> <span class="hljs-number">25</span>.<span class="hljs-number">00</span>   <span class="hljs-number">0</span>.<span class="hljs-number">00</span>  <span class="hljs-number">14</span>.<span class="hljs-number">03</span>   <span class="hljs-number">6</span>.<span class="hljs-number">80</span>  <span class="hljs-number">96</span>.<span class="hljs-number">34</span>  <span class="hljs-number">94</span>.<span class="hljs-number">93</span>    <span class="hljs-number">200</span>    <span class="hljs-number">0</span>.<span class="hljs-number">246</span>     <span class="hljs-number">0</span>    <span class="hljs-number">0</span>.<span class="hljs-number">000</span>     -        -    <span class="hljs-number">0</span>.<span class="hljs-number">246</span><br> <span class="hljs-number">50</span>.<span class="hljs-number">00</span>   <span class="hljs-number">0</span>.<span class="hljs-number">00</span>  <span class="hljs-number">32</span>.<span class="hljs-number">01</span>   <span class="hljs-number">6</span>.<span class="hljs-number">93</span>  <span class="hljs-number">96</span>.<span class="hljs-number">34</span>  <span class="hljs-number">94</span>.<span class="hljs-number">93</span>    <span class="hljs-number">206</span>    <span class="hljs-number">0</span>.<span class="hljs-number">253</span>     <span class="hljs-number">0</span>    <span class="hljs-number">0</span>.<span class="hljs-number">000</span>     -        -    <span class="hljs-number">0</span>.<span class="hljs-number">253</span><br> <span class="hljs-number">50</span>.<span class="hljs-number">00</span>   <span class="hljs-number">0</span>.<span class="hljs-number">00</span>  <span class="hljs-number">47</span>.<span class="hljs-number">99</span>   <span class="hljs-number">7</span>.<span class="hljs-number">08</span>  <span class="hljs-number">96</span>.<span class="hljs-number">34</span>  <span class="hljs-number">94</span>.<span class="hljs-number">93</span>    <span class="hljs-number">212</span>    <span class="hljs-number">0</span>.<span class="hljs-number">259</span>     <span class="hljs-number">0</span>    <span class="hljs-number">0</span>.<span class="hljs-number">000</span>     -        -    <span class="hljs-number">0</span>.<span class="hljs-number">259</span><br> <span class="hljs-number">50</span>.<span class="hljs-number">00</span>   <span class="hljs-number">0</span>.<span class="hljs-number">00</span>  <span class="hljs-number">27</span>.<span class="hljs-number">80</span>   <span class="hljs-number">7</span>.<span class="hljs-number">21</span>  <span class="hljs-number">96</span>.<span class="hljs-number">34</span>  <span class="hljs-number">94</span>.<span class="hljs-number">93</span>    <span class="hljs-number">218</span>    <span class="hljs-number">0</span>.<span class="hljs-number">266</span>     <span class="hljs-number">0</span>    <span class="hljs-number">0</span>.<span class="hljs-number">000</span>     -        -    <span class="hljs-number">0</span>.<span class="hljs-number">266</span><br> <span class="hljs-number">37</span>.<span class="hljs-number">50</span>   <span class="hljs-number">0</span>.<span class="hljs-number">00</span>  <span class="hljs-number">57</span>.<span class="hljs-number">97</span>   <span class="hljs-number">7</span>.<span class="hljs-number">34</span>  <span class="hljs-number">96</span>.<span class="hljs-number">34</span>  <span class="hljs-number">94</span>.<span class="hljs-number">93</span>    <span class="hljs-number">224</span>    <span class="hljs-number">0</span>.<span class="hljs-number">272</span>     <span class="hljs-number">0</span>    <span class="hljs-number">0</span>.<span class="hljs-number">000</span>     -        -    <span class="hljs-number">0</span>.<span class="hljs-number">272</span><br> <span class="hljs-number">37</span>.<span class="hljs-number">50</span>   <span class="hljs-number">0</span>.<span class="hljs-number">00</span>  <span class="hljs-number">57</span>.<span class="hljs-number">97</span>   <span class="hljs-number">7</span>.<span class="hljs-number">34</span>  <span class="hljs-number">96</span>.<span class="hljs-number">34</span>  <span class="hljs-number">94</span>.<span class="hljs-number">93</span>    <span class="hljs-number">224</span>    <span class="hljs-number">0</span>.<span class="hljs-number">272</span>     <span class="hljs-number">0</span>    <span class="hljs-number">0</span>.<span class="hljs-number">000</span>     -        -    <span class="hljs-number">0</span>.<span class="hljs-number">272</span><br> <span class="hljs-number">37</span>.<span class="hljs-number">50</span>   <span class="hljs-number">0</span>.<span class="hljs-number">00</span>  <span class="hljs-number">57</span>.<span class="hljs-number">97</span>   <span class="hljs-number">7</span>.<span class="hljs-number">34</span>  <span class="hljs-number">96</span>.<span class="hljs-number">34</span>  <span class="hljs-number">94</span>.<span class="hljs-number">93</span>    <span class="hljs-number">224</span>    <span class="hljs-number">0</span>.<span class="hljs-number">272</span>     <span class="hljs-number">0</span>    <span class="hljs-number">0</span>.<span class="hljs-number">000</span>     -        -    <span class="hljs-number">0</span>.<span class="hljs-number">272</span><br> <span class="hljs-number">37</span>.<span class="hljs-number">50</span>   <span class="hljs-number">0</span>.<span class="hljs-number">00</span>  <span class="hljs-number">57</span>.<span class="hljs-number">97</span>   <span class="hljs-number">7</span>.<span class="hljs-number">34</span>  <span class="hljs-number">96</span>.<span class="hljs-number">34</span>  <span class="hljs-number">94</span>.<span class="hljs-number">93</span>    <span class="hljs-number">224</span>    <span class="hljs-number">0</span>.<span class="hljs-number">272</span>     <span class="hljs-number">0</span>    <span class="hljs-number">0</span>.<span class="hljs-number">000</span>     -        -    <span class="hljs-number">0</span>.<span class="hljs-number">272</span><br> <br>daiwei@daiweideMacBook-Pro ~ % jstat -gc <span class="hljs-number">11064 1000</span> <span class="hljs-number">15</span><br> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT<br><span class="hljs-number">512</span>.<span class="hljs-number">0</span>  <span class="hljs-number">512</span>.<span class="hljs-number">0</span>  <span class="hljs-number">192</span>.<span class="hljs-number">0</span>   <span class="hljs-number">0</span>.<span class="hljs-number">0</span>   <span class="hljs-number">31232.0</span>  <span class="hljs-number">19405.0</span>   <span class="hljs-number">175104.0</span>   <span class="hljs-number">12854.1</span>   <span class="hljs-number">20736.0</span> <span class="hljs-number">19977.0</span> <span class="hljs-number">2816</span>.<span class="hljs-number">0 2673.3</span>    <span class="hljs-number">224</span>    <span class="hljs-number">0</span>.<span class="hljs-number">272</span>   <span class="hljs-number">0</span>      <span class="hljs-number">0</span>.<span class="hljs-number">000</span>   -          -    <span class="hljs-number">0</span>.<span class="hljs-number">272</span><br><span class="hljs-number">512</span>.<span class="hljs-number">0</span>  <span class="hljs-number">512</span>.<span class="hljs-number">0</span>  <span class="hljs-number">192</span>.<span class="hljs-number">0</span>   <span class="hljs-number">0</span>.<span class="hljs-number">0</span>   <span class="hljs-number">31232.0</span>  <span class="hljs-number">19405.1</span>   <span class="hljs-number">175104.0</span>   <span class="hljs-number">12854.1</span>   <span class="hljs-number">20736.0</span> <span class="hljs-number">19977.0</span> <span class="hljs-number">2816</span>.<span class="hljs-number">0 2673.3</span>    <span class="hljs-number">224</span>    <span class="hljs-number">0</span>.<span class="hljs-number">272</span>   <span class="hljs-number">0</span>      <span class="hljs-number">0</span>.<span class="hljs-number">000</span>   -          -    <span class="hljs-number">0</span>.<span class="hljs-number">272</span><br><span class="hljs-number">512</span>.<span class="hljs-number">0</span>  <span class="hljs-number">512</span>.<span class="hljs-number">0</span>  <span class="hljs-number">192</span>.<span class="hljs-number">0</span>   <span class="hljs-number">0</span>.<span class="hljs-number">0</span>   <span class="hljs-number">31232.0</span>  <span class="hljs-number">19405.1</span>   <span class="hljs-number">175104.0</span>   <span class="hljs-number">12854.1</span>   <span class="hljs-number">20736.0</span> <span class="hljs-number">19977.0</span> <span class="hljs-number">2816</span>.<span class="hljs-number">0 2673.3</span>    <span class="hljs-number">224</span>    <span class="hljs-number">0</span>.<span class="hljs-number">272</span>   <span class="hljs-number">0</span>      <span class="hljs-number">0</span>.<span class="hljs-number">000</span>   -          -    <span class="hljs-number">0</span>.<span class="hljs-number">272</span><br><span class="hljs-number">512</span>.<span class="hljs-number">0</span>  <span class="hljs-number">512</span>.<span class="hljs-number">0</span>  <span class="hljs-number">160</span>.<span class="hljs-number">0</span>   <span class="hljs-number">0</span>.<span class="hljs-number">0</span>   <span class="hljs-number">31232.0</span>   <span class="hljs-number">5617</span>.<span class="hljs-number">8</span>   <span class="hljs-number">175104.0</span>   <span class="hljs-number">13354.2</span>   <span class="hljs-number">20736.0</span> <span class="hljs-number">20071.3</span> <span class="hljs-number">2816</span>.<span class="hljs-number">0 2674.4</span>    <span class="hljs-number">230</span>    <span class="hljs-number">0</span>.<span class="hljs-number">279</span>   <span class="hljs-number">0</span>      <span class="hljs-number">0</span>.<span class="hljs-number">000</span>   -          -    <span class="hljs-number">0</span>.<span class="hljs-number">279</span><br><span class="hljs-number">512</span>.<span class="hljs-number">0</span>  <span class="hljs-number">512</span>.<span class="hljs-number">0</span>   <span class="hljs-number">0</span>.<span class="hljs-number">0</span>   <span class="hljs-number">224</span>.<span class="hljs-number">0</span>  <span class="hljs-number">31232.0</span>  <span class="hljs-number">10477.4</span>   <span class="hljs-number">175104.0</span>   <span class="hljs-number">13674.2</span>   <span class="hljs-number">20736.0</span> <span class="hljs-number">20073.0</span> <span class="hljs-number">2816</span>.<span class="hljs-number">0 2674.4</span>    <span class="hljs-number">237</span>    <span class="hljs-number">0</span>.<span class="hljs-number">286</span>   <span class="hljs-number">0</span>      <span class="hljs-number">0</span>.<span class="hljs-number">000</span>   -          -    <span class="hljs-number">0</span>.<span class="hljs-number">286</span><br><span class="hljs-number">512</span>.<span class="hljs-number">0</span>  <span class="hljs-number">512</span>.<span class="hljs-number">0</span>  <span class="hljs-number">256</span>.<span class="hljs-number">0</span>   <span class="hljs-number">0</span>.<span class="hljs-number">0</span>   <span class="hljs-number">31232.0</span>  <span class="hljs-number">21876.8</span>   <span class="hljs-number">175104.0</span>   <span class="hljs-number">13986.2</span>   <span class="hljs-number">20736.0</span> <span class="hljs-number">20073.0</span> <span class="hljs-number">2816</span>.<span class="hljs-number">0 2674.4</span>    <span class="hljs-number">244</span>    <span class="hljs-number">0</span>.<span class="hljs-number">294</span>   <span class="hljs-number">0</span>      <span class="hljs-number">0</span>.<span class="hljs-number">000</span>   -          -    <span class="hljs-number">0</span>.<span class="hljs-number">294</span><br><span class="hljs-number">512</span>.<span class="hljs-number">0</span>  <span class="hljs-number">512</span>.<span class="hljs-number">0</span>  <span class="hljs-number">224</span>.<span class="hljs-number">0</span>   <span class="hljs-number">0</span>.<span class="hljs-number">0</span>   <span class="hljs-number">31232.0</span>    <span class="hljs-number">0</span>.<span class="hljs-number">0</span>     <span class="hljs-number">175104.0</span>   <span class="hljs-number">14306.2</span>   <span class="hljs-number">20736.0</span> <span class="hljs-number">20073.0</span> <span class="hljs-number">2816</span>.<span class="hljs-number">0 2674.4</span>    <span class="hljs-number">252</span>    <span class="hljs-number">0</span>.<span class="hljs-number">303</span>   <span class="hljs-number">0</span>      <span class="hljs-number">0</span>.<span class="hljs-number">000</span>   -          -    <span class="hljs-number">0</span>.<span class="hljs-number">303</span><br><span class="hljs-number">512</span>.<span class="hljs-number">0</span>  <span class="hljs-number">512</span>.<span class="hljs-number">0</span>   <span class="hljs-number">0</span>.<span class="hljs-number">0</span>   <span class="hljs-number">256</span>.<span class="hljs-number">0</span>  <span class="hljs-number">31232.0</span>  <span class="hljs-number">11824.0</span>   <span class="hljs-number">175104.0</span>   <span class="hljs-number">14658.2</span>   <span class="hljs-number">20736.0</span> <span class="hljs-number">20073.0</span> <span class="hljs-number">2816</span>.<span class="hljs-number">0 2674.4</span>    <span class="hljs-number">259</span>    <span class="hljs-number">0</span>.<span class="hljs-number">310</span>   <span class="hljs-number">0</span>      <span class="hljs-number">0</span>.<span class="hljs-number">000</span>   -          -    <span class="hljs-number">0</span>.<span class="hljs-number">310</span><br><span class="hljs-number">512</span>.<span class="hljs-number">0</span>  <span class="hljs-number">512</span>.<span class="hljs-number">0</span>   <span class="hljs-number">0</span>.<span class="hljs-number">0</span>   <span class="hljs-number">256</span>.<span class="hljs-number">0</span>  <span class="hljs-number">31232.0</span>    <span class="hljs-number">0</span>.<span class="hljs-number">0</span>     <span class="hljs-number">175104.0</span>   <span class="hljs-number">15042.2</span>   <span class="hljs-number">20736.0</span> <span class="hljs-number">20073.8</span> <span class="hljs-number">2816</span>.<span class="hljs-number">0 2674.4</span>    <span class="hljs-number">267</span>    <span class="hljs-number">0</span>.<span class="hljs-number">318</span>   <span class="hljs-number">0</span>      <span class="hljs-number">0</span>.<span class="hljs-number">000</span>   -          -    <span class="hljs-number">0</span>.<span class="hljs-number">318</span><br><span class="hljs-number">512</span>.<span class="hljs-number">0</span>  <span class="hljs-number">512</span>.<span class="hljs-number">0</span>  <span class="hljs-number">256</span>.<span class="hljs-number">0</span>   <span class="hljs-number">0</span>.<span class="hljs-number">0</span>   <span class="hljs-number">31232.0</span>   <span class="hljs-number">6867</span>.<span class="hljs-number">3</span>   <span class="hljs-number">175104.0</span>   <span class="hljs-number">15330.2</span>   <span class="hljs-number">20736.0</span> <span class="hljs-number">20073.8</span> <span class="hljs-number">2816</span>.<span class="hljs-number">0 2674.4</span>    <span class="hljs-number">274</span>    <span class="hljs-number">0</span>.<span class="hljs-number">326</span>   <span class="hljs-number">0</span>      <span class="hljs-number">0</span>.<span class="hljs-number">000</span>   -          -    <span class="hljs-number">0</span>.<span class="hljs-number">326</span><br><span class="hljs-number">512</span>.<span class="hljs-number">0</span>  <span class="hljs-number">512</span>.<span class="hljs-number">0</span>  <span class="hljs-number">224</span>.<span class="hljs-number">0</span>   <span class="hljs-number">0</span>.<span class="hljs-number">0</span>   <span class="hljs-number">31232.0</span>  <span class="hljs-number">15562.0</span>   <span class="hljs-number">175104.0</span>   <span class="hljs-number">15562.2</span>   <span class="hljs-number">20736.0</span> <span class="hljs-number">20073.8</span> <span class="hljs-number">2816</span>.<span class="hljs-number">0 2674.4</span>    <span class="hljs-number">280</span>    <span class="hljs-number">0</span>.<span class="hljs-number">332</span>   <span class="hljs-number">0</span>      <span class="hljs-number">0</span>.<span class="hljs-number">000</span>   -          -    <span class="hljs-number">0</span>.<span class="hljs-number">332</span><br><span class="hljs-number">512</span>.<span class="hljs-number">0</span>  <span class="hljs-number">512</span>.<span class="hljs-number">0</span>   <span class="hljs-number">0</span>.<span class="hljs-number">0</span>   <span class="hljs-number">160</span>.<span class="hljs-number">0</span>  <span class="hljs-number">31232.0</span>    <span class="hljs-number">0</span>.<span class="hljs-number">0</span>     <span class="hljs-number">175104.0</span>   <span class="hljs-number">15842.2</span>   <span class="hljs-number">20736.0</span> <span class="hljs-number">20073.8</span> <span class="hljs-number">2816</span>.<span class="hljs-number">0 2674.4</span>    <span class="hljs-number">287</span>    <span class="hljs-number">0</span>.<span class="hljs-number">340</span>   <span class="hljs-number">0</span>      <span class="hljs-number">0</span>.<span class="hljs-number">000</span>   -          -    <span class="hljs-number">0</span>.<span class="hljs-number">340</span><br><span class="hljs-number">512</span>.<span class="hljs-number">0</span>  <span class="hljs-number">512</span>.<span class="hljs-number">0</span>   <span class="hljs-number">0</span>.<span class="hljs-number">0</span>   <span class="hljs-number">192</span>.<span class="hljs-number">0</span>  <span class="hljs-number">31232.0</span>   <span class="hljs-number">7477</span>.<span class="hljs-number">3</span>   <span class="hljs-number">175104.0</span>   <span class="hljs-number">16090.2</span>   <span class="hljs-number">20736.0</span> <span class="hljs-number">20074.2</span> <span class="hljs-number">2816</span>.<span class="hljs-number">0 2674.4</span>    <span class="hljs-number">293</span>    <span class="hljs-number">0</span>.<span class="hljs-number">346</span>   <span class="hljs-number">0</span>      <span class="hljs-number">0</span>.<span class="hljs-number">000</span>   -          -    <span class="hljs-number">0</span>.<span class="hljs-number">346</span><br><span class="hljs-number">512</span>.<span class="hljs-number">0</span>  <span class="hljs-number">512</span>.<span class="hljs-number">0</span>  <span class="hljs-number">224</span>.<span class="hljs-number">0</span>   <span class="hljs-number">0</span>.<span class="hljs-number">0</span>   <span class="hljs-number">31232.0</span>  <span class="hljs-number">21846.6</span>   <span class="hljs-number">175104.0</span>   <span class="hljs-number">16138.2</span>   <span class="hljs-number">20736.0</span> <span class="hljs-number">20074.2</span> <span class="hljs-number">2816</span>.<span class="hljs-number">0 2674.4</span>    <span class="hljs-number">294</span>    <span class="hljs-number">0</span>.<span class="hljs-number">347</span>   <span class="hljs-number">0</span>      <span class="hljs-number">0</span>.<span class="hljs-number">000</span>   -          -    <span class="hljs-number">0</span>.<span class="hljs-number">347</span><br><span class="hljs-number">512</span>.<span class="hljs-number">0</span>  <span class="hljs-number">512</span>.<span class="hljs-number">0</span>  <span class="hljs-number">224</span>.<span class="hljs-number">0</span>   <span class="hljs-number">0</span>.<span class="hljs-number">0</span>   <span class="hljs-number">31232.0</span>  <span class="hljs-number">21846.6</span>   <span class="hljs-number">175104.0</span>   <span class="hljs-number">16138.2</span>   <span class="hljs-number">20736.0</span> <span class="hljs-number">20074.2</span> <span class="hljs-number">2816</span>.<span class="hljs-number">0 2674.4</span>    <span class="hljs-number">294</span>    <span class="hljs-number">0</span>.<span class="hljs-number">347</span>   <span class="hljs-number">0</span>      <span class="hljs-number">0</span>.<span class="hljs-number">000</span>   -          -    <span class="hljs-number">0</span>.<span class="hljs-number">347</span><br></code></pre></td></tr></table></figure><p>上面是一次持续 10 秒的服务压测，可以看到一些数据持续不断的变化。-gc 和-gcutil 的参数都是一样的 <code>11064</code> 是 pid，<code>1000</code> 是打印时间间隔单位 ms，<code>15</code> 是打印次数，打印15次。</p><p>gcutil 的 输出参数：</p><ul><li><code>S0</code> 0 号 Survivor 区的使用百分比（S0 和 S1 总有一个是空的）。</li><li><code>S1</code> 1 号 Survivor 区的使用百分比。</li><li><code>E</code> Eden 区，也就是新生代的使用百分比。</li><li><code>O</code> Old 区老年代的使用百分比。</li><li><code>M</code> Meta区元数据区的使用百分比。</li><li><code>CSS</code> 压缩class空间（Compress class space）的使用百分比。</li><li><code>YGC</code> youngGC 次数</li><li><code>YGCT</code> youngGC 总耗时，单位秒</li><li><code>FGC</code> fullGC 的次数，可以看到 fullGC 一次都没有。</li><li><code>FGCT</code> fullGC 的总数时间，一次FullGC 都没有，所以FullGC 时间为 0</li><li><code>CGC</code> concurrentGC 并发垃圾收集次数，因为 jdk8 的默认回收器是 parallelGC 没有并发阶段所以这里是 - </li><li><code>CGCT</code> concurrentGC 收集总时间。</li><li><code>GCT</code> 所有 GC 加在一起的时间。</li></ul><p>其实 -gcutil 和 -gc 输出逻辑是一致的，只是 -gc 输出的<code>实际占用的大小单位 kb</code>，并且 -gc 输出的都是 <code>XXU</code>、 <code>XXC</code> 这代表着 <code>XX Usage</code> 和 <code>XX Capacity</code> 的意思。</p><h4 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h4><p>用于输出系统 JVM 堆信息。用的最多的两个命令 <code>-histo</code> 和 <code>-dump</code> 。其中<code>-histo</code>（柱状图）输出当前堆中的对象并按照占用空间从大到小排序。<code>-dump</code> dump 当前堆信息。jmap 在 jdk8 中还有一个 <code>-heap</code> 命令，但是在这一版的 jdk11 中移除了，但是我们还是有办法输出 -heap 的内容，别着急往下看。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">daiwei@daiweideMacBook-Pro ~ % <span class="hljs-keyword">jmap </span>-help<br><span class="hljs-symbol">Usage:</span><br>    <span class="hljs-keyword">jmap </span>-clstats &lt;pid&gt;<br>        to connect to running process <span class="hljs-keyword">and </span>print class loader statistics<br>    <span class="hljs-keyword">jmap </span>-finalizerinfo &lt;pid&gt;<br>        to connect to running process <span class="hljs-keyword">and </span>print information on objects awaiting finalization<br>    <span class="hljs-keyword">jmap </span>-histo[:live] &lt;pid&gt;<br>        to connect to running process <span class="hljs-keyword">and </span>print histogram of <span class="hljs-keyword">java </span>object heap<br>        if the <span class="hljs-string">&quot;live&quot;</span> <span class="hljs-keyword">suboption </span>is specified, only <span class="hljs-built_in">count</span> live objects<br>    <span class="hljs-keyword">jmap </span>-dump:&lt;dump-options&gt; &lt;pid&gt;<br>        to connect to running process <span class="hljs-keyword">and </span>dump <span class="hljs-keyword">java </span>heap<br>    <span class="hljs-keyword">jmap </span>-? -h --help<br>        to print this help message<br><br>    dump-options:<br>      live         dump only live objects<span class="hljs-comment">; if not specified,</span><br>                   all objects in the heap are dumped.<br>      format=<span class="hljs-keyword">b </span>    <span class="hljs-keyword">binary </span>format<br>      file=&lt;file&gt;  dump heap to &lt;file&gt;<br><br><span class="hljs-symbol">    Example:</span> <span class="hljs-keyword">jmap </span>-dump:live,format=<span class="hljs-keyword">b,file=heap.bin </span>&lt;pid&gt;<br>    <br> daiwei@daiweideMacBook-Pro ~ % <span class="hljs-keyword">jmap </span>-histo <span class="hljs-number">33208</span><br><br> num     <span class="hljs-comment">#instances         #bytes  class name</span><br>----------------------------------------------<br><span class="hljs-symbol">   1:</span>        <span class="hljs-number">106522</span>        <span class="hljs-number">4260880</span>  <span class="hljs-keyword">java.lang.ref.Finalizer</span><br><span class="hljs-keyword"> </span>  <span class="hljs-number">2</span>:        <span class="hljs-number">106222</span>        <span class="hljs-number">4248880</span>  <span class="hljs-keyword">java.util.WeakHashMap$Entry</span><br><span class="hljs-keyword"> </span>  <span class="hljs-number">3</span>:        <span class="hljs-number">106200</span>        <span class="hljs-number">3398400</span>  <span class="hljs-keyword">java.lang.ref.WeakReference</span><br><span class="hljs-keyword"> </span>  <span class="hljs-number">4</span>:          <span class="hljs-number">4569</span>        <span class="hljs-number">2491656</span>  [I<br><span class="hljs-symbol">   5:</span>         <span class="hljs-number">67343</span>        <span class="hljs-number">2154976</span>  com.sun.<span class="hljs-keyword">jna.Memory</span><br><span class="hljs-keyword"> </span>  <span class="hljs-number">6</span>:         <span class="hljs-number">46271</span>        <span class="hljs-number">1698896</span>  [Ljava.lang.Object;<br><span class="hljs-symbol">   7:</span>         <span class="hljs-number">28666</span>        <span class="hljs-number">1330904</span>  [C<br><span class="hljs-symbol">   8:</span>         <span class="hljs-number">13698</span>        <span class="hljs-number">1271480</span>  [<span class="hljs-keyword">B</span><br><span class="hljs-keyword"> </span>  <span class="hljs-number">9</span>:         <span class="hljs-number">31081</span>        <span class="hljs-number">1243240</span>  com.sun.<span class="hljs-keyword">jna.NativeString$StringMemory</span><br><span class="hljs-keyword"> </span> <span class="hljs-number">10</span>:         <span class="hljs-number">14391</span>        <span class="hljs-number">1036744</span>  [<span class="hljs-keyword">J</span><br><span class="hljs-keyword"> </span> <span class="hljs-number">11</span>:         <span class="hljs-number">31081</span>         <span class="hljs-number">745944</span>  com.sun.<span class="hljs-keyword">jna.NativeString</span><br><span class="hljs-keyword"> </span> <span class="hljs-number">12</span>:          <span class="hljs-number">7526</span>         <span class="hljs-number">613808</span>  [Ljava.util.HashMap$Node;<br><span class="hljs-symbol">  13:</span>            <span class="hljs-number">46</span>         <span class="hljs-number">527904</span>  [Ljava.util.WeakHashMap$Entry;<br><span class="hljs-symbol">  14:</span>         <span class="hljs-number">20227</span>         <span class="hljs-number">485448</span>  <span class="hljs-keyword">java.lang.String</span><br><span class="hljs-keyword"> </span> <span class="hljs-number">15</span>:          <span class="hljs-number">6157</span>         <span class="hljs-number">443304</span>  <span class="hljs-keyword">java.lang.reflect.Field</span><br><span class="hljs-keyword"> </span> <span class="hljs-number">16</span>:          <span class="hljs-number">7534</span>         <span class="hljs-number">361632</span>  <span class="hljs-keyword">java.util.HashMap</span><br><span class="hljs-keyword"> </span> <span class="hljs-number">17</span>:         <span class="hljs-number">12098</span>         <span class="hljs-number">290352</span>  <span class="hljs-keyword">java.util.ArrayList</span><br><span class="hljs-keyword"> </span> <span class="hljs-number">18</span>:          <span class="hljs-number">7771</span>         <span class="hljs-number">248672</span>  com.sun.<span class="hljs-keyword">jna.Structure$AutoAllocated</span><br><span class="hljs-keyword"> </span> <span class="hljs-number">19</span>:         <span class="hljs-number">15131</span>         <span class="hljs-number">242096</span>  <span class="hljs-keyword">java.lang.Integer</span><br><span class="hljs-keyword"> </span> <span class="hljs-number">20</span>:          <span class="hljs-number">7074</span>         <span class="hljs-number">226368</span>  <span class="hljs-keyword">java.util.HashMap$Node</span><br><span class="hljs-keyword"> </span> <span class="hljs-number">21</span>:          <span class="hljs-number">3969</span>         <span class="hljs-number">190512</span>  [Loshi.hardware.CentralProcessor$TickType;<br><span class="hljs-symbol">  22:</span>          <span class="hljs-number">2987</span>         <span class="hljs-number">167272</span>  <span class="hljs-keyword">java.util.LinkedHashMap</span><br><span class="hljs-keyword"> </span> <span class="hljs-number">23</span>:          <span class="hljs-number">1277</span>         <span class="hljs-number">146176</span>  <span class="hljs-keyword">java.lang.Class</span><br><span class="hljs-keyword"> </span> <span class="hljs-number">24</span>:          <span class="hljs-number">5978</span>         <span class="hljs-number">144200</span>  [Ljava.lang.reflect.Field;<br>  ......<br><span class="hljs-symbol"> 517:</span>             <span class="hljs-number">1</span>             <span class="hljs-number">16</span>  sun.util.resources.LocaleData<br><span class="hljs-symbol"> 518:</span>             <span class="hljs-number">1</span>             <span class="hljs-number">16</span>  sun.util.resources.LocaleData$LocaleDataResourceBundleControl<br>Total        <span class="hljs-number">710496</span>       <span class="hljs-number">29890984</span><br><br>daiwei@daiweideMacBook-Pro ~ % <span class="hljs-keyword">jmap </span>-dump:format=<span class="hljs-keyword">b,file=dump.hprof </span><span class="hljs-number">34471</span><br>Heap dump file created<br></code></pre></td></tr></table></figure><h4 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h4><p>jmap 可以输出堆空间的信息，jstack 就是输出<code>栈空间</code>的信息。最主要使用的<code>-l</code>即打印 jvm 中的锁信息，<code>-e</code>打印 jvm 中的线程信息。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs routeros">daiwei@daiweideMacBook-Pro ~ % jstack -help<br>Usage:<br>    jstack [-l][-e] &lt;pid&gt;<br>        (<span class="hljs-keyword">to</span> connect <span class="hljs-keyword">to</span> running process)<br><br>Options:<br>    -l  long listing. Prints additional information about locks<br>    -e  extended listing. Prints additional information about threads<br>    -? -h --help -help <span class="hljs-keyword">to</span> <span class="hljs-builtin-name">print</span> this help message<br><br>daiwei@daiweideMacBook-Pro ~ % jstack -l 34979<br>2021-05-22 21:49:23<br>Full thread dump Java HotSpot(TM) 64-Bit<span class="hljs-built_in"> Server </span>VM (25.231-b11 mixed mode):<br><br><span class="hljs-string">&quot;Attach Listener&quot;</span> #11 daemon <span class="hljs-attribute">prio</span>=9 <span class="hljs-attribute">os_prio</span>=31 <span class="hljs-attribute">tid</span>=0x00007ff5270d5800 <span class="hljs-attribute">nid</span>=0xa803 waiting on condition [0x0000000000000000]<br>   java.lang.Thread.State: RUNNABLE<br><br>   Locked ownable synchronizers:<br>    - None<br><br><span class="hljs-string">&quot;Service Thread&quot;</span> #10 daemon <span class="hljs-attribute">prio</span>=9 <span class="hljs-attribute">os_prio</span>=31 <span class="hljs-attribute">tid</span>=0x00007ff526079800 <span class="hljs-attribute">nid</span>=0x3e03 runnable [0x0000000000000000]<br>   java.lang.Thread.State: RUNNABLE<br><br>   Locked ownable synchronizers:<br>    - None<br><br><span class="hljs-string">&quot;C1 CompilerThread3&quot;</span> #9 daemon <span class="hljs-attribute">prio</span>=9 <span class="hljs-attribute">os_prio</span>=31 <span class="hljs-attribute">tid</span>=0x00007ff526040800 <span class="hljs-attribute">nid</span>=0x3c03 waiting on condition [0x0000000000000000]<br>   java.lang.Thread.State: RUNNABLE<br><br>   Locked ownable synchronizers:<br>    - None<br><br><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>.<br><br><span class="hljs-string">&quot;main&quot;</span> #1 <span class="hljs-attribute">prio</span>=5 <span class="hljs-attribute">os_prio</span>=31 <span class="hljs-attribute">tid</span>=0x00007ff528809000 <span class="hljs-attribute">nid</span>=0xf03 waiting on condition [0x0000700001c52000]<br>   java.lang.Thread.State: TIMED_WAITING (sleeping)<br>    at java.lang.Thread.sleep(Native Method)<br>    at io.daiwei.TestCPULoadMain.main(TestCPULoadMain.java:21)<br><br>   Locked ownable synchronizers:<br>    - None<br><br><span class="hljs-string">&quot;VM Thread&quot;</span> <span class="hljs-attribute">os_prio</span>=31 <span class="hljs-attribute">tid</span>=0x00007ff528840800 <span class="hljs-attribute">nid</span>=0x5003 runnable<br><br><span class="hljs-string">&quot;GC task thread#0 (ParallelGC)&quot;</span> <span class="hljs-attribute">os_prio</span>=31 <span class="hljs-attribute">tid</span>=0x00007ff52880a800 <span class="hljs-attribute">nid</span>=0x2607 runnable<br><br><span class="hljs-string">&quot;GC task thread#1 (ParallelGC)&quot;</span> <span class="hljs-attribute">os_prio</span>=31 <span class="hljs-attribute">tid</span>=0x00007ff528816000 <span class="hljs-attribute">nid</span>=0x2503 runnable<br><br><span class="hljs-string">&quot;GC task thread#2 (ParallelGC)&quot;</span> <span class="hljs-attribute">os_prio</span>=31 <span class="hljs-attribute">tid</span>=0x00007ff528816800 <span class="hljs-attribute">nid</span>=0x2303 runnable<br><br><span class="hljs-string">&quot;GC task thread#3 (ParallelGC)&quot;</span> <span class="hljs-attribute">os_prio</span>=31 <span class="hljs-attribute">tid</span>=0x00007ff528817000 <span class="hljs-attribute">nid</span>=0x2a03 runnable<br><br><span class="hljs-string">&quot;GC task thread#4 (ParallelGC)&quot;</span> <span class="hljs-attribute">os_prio</span>=31 <span class="hljs-attribute">tid</span>=0x00007ff528817800 <span class="hljs-attribute">nid</span>=0x5403 runnable<br><br><span class="hljs-string">&quot;GC task thread#5 (ParallelGC)&quot;</span> <span class="hljs-attribute">os_prio</span>=31 <span class="hljs-attribute">tid</span>=0x00007ff528818800 <span class="hljs-attribute">nid</span>=0x5203 runnable<br><br><span class="hljs-string">&quot;GC task thread#6 (ParallelGC)&quot;</span> <span class="hljs-attribute">os_prio</span>=31 <span class="hljs-attribute">tid</span>=0x00007ff528819000 <span class="hljs-attribute">nid</span>=0x2c03 runnable<br><br><span class="hljs-string">&quot;GC task thread#7 (ParallelGC)&quot;</span> <span class="hljs-attribute">os_prio</span>=31 <span class="hljs-attribute">tid</span>=0x00007ff528819800 <span class="hljs-attribute">nid</span>=0x2e03 runnable<br><br><span class="hljs-string">&quot;VM Periodic Task Thread&quot;</span> <span class="hljs-attribute">os_prio</span>=31 <span class="hljs-attribute">tid</span>=0x00007ff528875000 <span class="hljs-attribute">nid</span>=0x5503 waiting on condition<br><br>JNI global references: 375<br></code></pre></td></tr></table></figure><h4 id="jcmd"><a href="#jcmd" class="headerlink" title="jcmd"></a>jcmd</h4><p>什么你说命令太多记不住？没关系。jcmd 是一个命令的聚合，里面有很多的 option，基本上前面的命令都可以用 jcmd 输出，来看看下面的例子。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs vim">daiwei@daiweideMacBook-Pro ~ % jcmd -<span class="hljs-keyword">help</span><br>Usage: jcmd &lt;pid | main class&gt; &lt;<span class="hljs-keyword">command</span> ...|PerfCounter.<span class="hljs-keyword">print</span>|-<span class="hljs-keyword">f</span> <span class="hljs-keyword">file</span>&gt;<br>   <span class="hljs-built_in">or</span>: jcmd -<span class="hljs-keyword">l</span><br>   <span class="hljs-built_in">or</span>: jcmd -h<br><br>  <span class="hljs-keyword">command</span> must <span class="hljs-keyword">be</span> <span class="hljs-keyword">a</span> valid jcmd <span class="hljs-keyword">command</span> <span class="hljs-keyword">for</span> the selected jvm.<br>  Use the <span class="hljs-keyword">command</span> <span class="hljs-string">&quot;help&quot;</span> <span class="hljs-keyword">to</span> see which commands are available.<br>  If the pid <span class="hljs-keyword">is</span> <span class="hljs-number">0</span>, commands will <span class="hljs-keyword">be</span> sent <span class="hljs-keyword">to</span> <span class="hljs-keyword">all</span> Java processes.<br>  The main class <span class="hljs-keyword">argument</span> will <span class="hljs-keyword">be</span> used <span class="hljs-keyword">to</span> <span class="hljs-keyword">match</span> (either partially<br>  <span class="hljs-built_in">or</span> fully) the class used <span class="hljs-keyword">to</span> start Java.<br>  If <span class="hljs-keyword">no</span> <span class="hljs-keyword">options</span> are given, lists Java processes (same <span class="hljs-keyword">as</span> -<span class="hljs-keyword">l</span>).<br><br>  PerfCounter.<span class="hljs-keyword">print</span> <span class="hljs-keyword">display</span> the counters exposed by this process<br>  -<span class="hljs-keyword">f</span>  <span class="hljs-keyword">read</span> <span class="hljs-built_in">and</span> <span class="hljs-keyword">execute</span> commands from the <span class="hljs-keyword">file</span><br>  -<span class="hljs-keyword">l</span>  <span class="hljs-keyword">list</span> JVM processes <span class="hljs-keyword">on</span> the local machine<br>  -? -h --<span class="hljs-keyword">help</span> <span class="hljs-keyword">print</span> this <span class="hljs-keyword">help</span> message<br>  <br>daiwei@daiweideMacBook-Pro ~ % jcmd <span class="hljs-number">34979</span><br><span class="hljs-number">34979</span>:<br>The following commands are available:<br>JFR.<span class="hljs-keyword">stop</span><br>JFR.start<br>JFR.dump<br>JFR.check<br>VM.native_memory<br>VM.check_commercial_features<br>VM.unlock_commercial_features<br>ManagementAgent.<span class="hljs-keyword">stop</span><br>ManagementAgent.start_local<br>ManagementAgent.start<br>VM.classloader_stats<br>GC.rotate_log<br>Thread.<span class="hljs-keyword">print</span><br>GC.class_stats<br>GC.class_histogram<br>GC.heap_dump<br>GC.finalizer_info<br>GC.heap_info<br>GC.run_finalization<br>GC.run<br>VM.uptime<br>VM.dynlibs<br>VM.flags<br>VM.system_properties<br>VM.command_line<br>VM.<span class="hljs-keyword">version</span><br><span class="hljs-keyword">help</span><br><br>For more information about <span class="hljs-keyword">a</span> specific <span class="hljs-keyword">command</span> use <span class="hljs-string">&#x27;help &lt;command&gt;&#x27;</span>.<br><br># <span class="hljs-keyword">help</span> 命令<br>daiwei@daiweideMacBook-Pro ~ % jcmd <span class="hljs-number">34979</span> <span class="hljs-keyword">help</span> GC.heap_info<br><span class="hljs-number">34979</span>:<br>GC.heap_info<br>Provide generic Java heap information.<br><br>Impac<span class="hljs-variable">t:</span> Medium<br><br>Permission: java.lang.management.ManagementPermission(monitor)<br><br>Syntax: GC.heap_info<br><br># cmd 命令使用 这里就是前面提到的，jmap 中移除的命令，输出堆内存信息。<br>daiwei@daiweideMacBook-Pro ~ % jcmd <span class="hljs-number">34979</span> GC.heap_info<br><span class="hljs-number">34979</span>:<br> PSYoungGen      total <span class="hljs-number">76288</span>K, used <span class="hljs-number">47314</span>K [<span class="hljs-number">0</span>x000000076ab00000, <span class="hljs-number">0</span>x0000000770000000, <span class="hljs-number">0</span>x00000007c0000000)<br>  eden space <span class="hljs-number">65536</span>K, <span class="hljs-number">55</span>% used [<span class="hljs-number">0</span>x000000076ab00000,<span class="hljs-number">0</span>x000000076cebc930,<span class="hljs-number">0</span>x000000076eb00000)<br>  from space <span class="hljs-number">10752</span>K, <span class="hljs-number">99</span>% used [<span class="hljs-number">0</span>x000000076eb00000,<span class="hljs-number">0</span>x000000076f578010,<span class="hljs-number">0</span>x000000076f580000)<br>  <span class="hljs-keyword">to</span>   space <span class="hljs-number">10752</span>K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0</span>x000000076f580000,<span class="hljs-number">0</span>x000000076f580000,<span class="hljs-number">0</span>x0000000770000000)<br> ParOldGen       total <span class="hljs-number">175104</span>K, used <span class="hljs-number">4582</span>K [<span class="hljs-number">0</span>x00000006c0000000, <span class="hljs-number">0</span>x00000006cab00000, <span class="hljs-number">0</span>x000000076ab00000)<br>  object space <span class="hljs-number">175104</span>K, <span class="hljs-number">2</span>% used [<span class="hljs-number">0</span>x00000006c0000000,<span class="hljs-number">0</span>x00000006c0479a48,<span class="hljs-number">0</span>x00000006cab00000)<br> Metaspace       used <span class="hljs-number">7205</span>K, capacity <span class="hljs-number">7438</span>K, committed <span class="hljs-number">7552</span>K, reserved <span class="hljs-number">1056768</span>K<br>  class space    used <span class="hljs-number">759</span>K, capacity <span class="hljs-number">838</span>K, committed <span class="hljs-number">896</span>K, reserved <span class="hljs-number">1048576</span>K<br></code></pre></td></tr></table></figure><h3 id="图形化工具"><a href="#图形化工具" class="headerlink" title="图形化工具"></a>图形化工具</h3><p>图形化工具可以以图表的形式更直观的把监控数据展现出来，JDK自带的图形化工具主要包括 <code>jconsole</code>、<code>jvisualvm</code>、<code>jmc</code>。这些工具都提供了丰富的功能，方便开发者对 JVM 进行监控。</p><blockquote><p>jmc 在 JDK11 以上版被被移除，独立作为一个程序包提供。 JDK 11 依旧有 jmc 这个命令但是打不开。 jmc 我们下载了独立软件包，进行操作。同时下面的所有栗子都基于 jdk11 进行测试。</p></blockquote><h4 id="jconsole"><a href="#jconsole" class="headerlink" title="jconsole"></a>jconsole</h4><p>在命令行输入<code>jconsole</code>即可打开，打开后可以选择本地 JVM 直接连接也可以选择，JMX 的方式远程连接 JVM。下面这张图就是打开本地 JVM 监控的概览页面，其中图中有6个 tab 页，分别是<code>概览</code>、<code>内存</code>、<code>线程</code>、<code>类</code>、<code>VM概要</code>、<code>Mbean</code>，从概述这个页面上能看到堆内存使用量、线程、类、CPU 占用率的系统指标数据。</p><ul><li><code>堆内存使用量</code> 这里是前面提到的 Java 堆内存的使用情况。</li><li><code>线程</code> 当前 JVM 中活跃的线程数。</li><li><code>类</code> JVM 加载的类的个数。</li><li><code>CPU占用率</code> 当前物理机的 CPU 使用情况。</li></ul><p>图中还有多个时间范围的选项可以选择，包括但不限于 1分钟、5分钟、10分钟、30分钟、1小时、2小时 …… 1天、7天 …… 1个月 …… 1年。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210523105811.png"></p><p>第二个面板是<code>内存</code> 这个部分提供了很多的图表，展示了各个内存部分的使用情况。我这里被监控应用使用的是 jdk8 ，GC是默认的 parallelGC 所以这里展示 PS XXX 内存图表，还有一些 MetaSpace、CodeCache、CCS 非堆部分内存使用量图 。右上角有个<code>执行GC</code>的按钮，这个按钮可以直接触发 JVM 的 <code>fullGC</code>，右下的数据就是整个堆按照堆和非堆逻辑划分后，各个部分内存使用情况的柱状图，我们堆逻辑内存区的命名<code>堆</code>与<code>非堆</code>也是从这来的。左下的详细信息则是堆空间 GC 的简单统计。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210523110244.png"></p><p>第三个面板是<code>线程有关</code>信息，上半部分是一个折线图，展示JVM中活跃和峰值的线程数量，下半部分是活跃的状态以及堆栈追踪。其中面板的下半部分有个<code>死锁检测</code>的按钮，可以用来检测当前JVM 中是否存在死锁。</p><p>  <img src="https://gitee.com/realDaiwei/img/raw/master/20210524154459.png"></p><p>第四个面板是<code>类加载</code>情况，上半部分是类加载数量的折线图，下半部分是详细数据的输出。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210524155552.png"></p><p><code>VM概述</code> 这个部分展示虚拟机内部的一些概要信息，包括线程、堆栈内存、物理机的一些和JVM的参数等。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210524155942.png"></p><p>MBean 的是一些 manage Bean 的一些详情信息。</p><h4 id="jvisualvm"><a href="#jvisualvm" class="headerlink" title="jvisualvm"></a>jvisualvm</h4><p>jvisualvm 和 jconsole 都是 JDK 打包的监控图形化工具。这个监控工具我感觉用下来比 jconsole 更友好一些，jconsole 有个功能他基本都有，并且 jvisualvm 还增加了<code>抽样器</code>和<code>VM dump分析</code>的功能，可以直接对运行的 JVM 进行取样分析。jvisualvm 的左边部分是应用程序的菜单栏，除了本地，我们还可以分析远程的JVM，VM核心 dump等，可以对本地或者取样出的 JVM 数据进行分析。我们这里选择 TestCPULoadMain 的 JVM 实例进行分析。在右边是详情页面，上面有几个tab页面，有<code>概述</code>、<code>监控</code>、<code>线程</code>、<code>抽样器</code>、<code>Profiler</code>，其中抽样器是用来做抽样分析，可以抽样堆空间数据和线程的数据，Profiler 用来进行性能抽样分析。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210524161742.png"></p><p>这里很直接的感受到 jvisualvm 的一个优点，jvisualvm 是彩色的！！jvisualvm在监控页面把<code>CPU</code>、<code>堆/MetaSpace</code>、<code>类</code>、<code>线程</code>这四个的折线图全部展示出来了，而不是像 jconsole 需要一个个选择切换。其中监控的项我们也可以根据需要自定义勾选。这里处理基本的监控数据展示，页面上还有两个按钮分别是<code>执行垃圾回收</code> 和 <code>堆Dump</code>。和jconsole一样，执行垃圾回收可以直接触发 JVM 的<code>fullGC</code>而<code>堆Dump</code>可以直接<code>dump当前堆空间</code>。相比于 jconsole 友好太多。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210524162959.png"></p><p>同时 jvisualvm 对于线程的监控也非常友好，也都是彩色的。同时也提供了<code>线程Dump</code> 的按钮，用于dump 当前的线程。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210524163015.png"></p><p>上面这两个面板都有 Dump 操作，点击 dump 之后可以直接跳转到一个新的面板直接展示 dump 后的数据。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210524170053.png"></p><p>抽样器的顾名思义，在JVM 运行期间，对某个时间段进行抽样，抽样目标的数据信息，抽样的对象包括<code>CPU</code>和<code>内存</code>，抽样完成后点击<code>快照</code>即可生成由抽样的数据生成的分析快照，并且可以进行多次采样或者增量采样来适应不同的抽样需求，同时在抽样过程中也能进行 GC 操作和 Dump 操作。最后的 profiler 和 抽样器功能类似用于 JVM 性能的抽样分析。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210524171625.png"></p><h4 id="jmc（java-mission-controller）"><a href="#jmc（java-mission-controller）" class="headerlink" title="jmc（java mission controller）"></a>jmc（java mission controller）</h4><p>Oracle Java Mission Control（JMC）是一组功能强大的工具，可以在Oracle JDK上运行并与Oracle Java SE Embedded 8虚拟机（VM）进行交互。这套工具提供了对Java SE Embedded 8 VM的高级，简单的Java监视和管理，适用于开发和生产环境。这个工具相较于前面的 jvisualvm 更加强大。有更多的监控项，在 jvisualvm 我们提到了一个抽样的功能，而这个功能在 jmc 直接升级成了 <code>java飞行记录（JFR）</code> 。JMC 在 jdk 8 之后的版本都是以独立软件包的形式提供，传送门 ===&gt;<a href="http://jdk.java.net/jmc/8/">下载地址</a>。</p><blockquote><p>jmc 我之前怎么尝试都是翻车都没有成功的打开，但是这次我打开了。记录下我的环境 （macos BigSur 11.3.1 (20E241) + jdk 1.8.0.231）</p></blockquote><p>jms 的Mbean 概览页面是三个仪表盘，分别是堆内存使用情况， CPU 使用率，最近一次 youngGC 对象存活的比例。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210524185656.png"></p><p><code>JFR</code>JVM 内置的数据收集引擎，正如这个名字一样 JFR（Java flight recoder） 会在运行期间收集JVM和Java 应用的运行数据，帮助开发者诊断分析 Java 应用。使用 JFR 要先进行 jfr 文件的录制，然后 jmc 对 jfr 文件进行分析并以图表的形式展示出来。其中左边的分析结果的菜单树，而右边则是分析结果的图表展示，展示的数据内容非常的详细。jfr 不仅可以通过 jmc 进行录制，还可以通过前面提到的<code>jcmd</code>命令进行录制。录制完成之后导入到 jmc 中进行分析即可。JFR 可以在测试环境和个人电脑上免费使用，但是如果用于生产服务器需要商业许可证，JFR虽然好，但是录制过程对中对性能还是会有一定的影响，大约 2% 左右，这个需要注意。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210524231602.png"></p><h2 id="可视化监控集成工具"><a href="#可视化监控集成工具" class="headerlink" title="可视化监控集成工具"></a>可视化监控集成工具</h2><p>前面介绍了JDK 自带的一些监控工具，其中包括命令行的工具和一些图形化的工具，上面的除了 JFR 我们在生产环境可以使用，其他的基本上都用不上。因为生产环境的服务器不是谁都能连上的，基本上都是运维管理，那我们还有其他的手段去方便地监控吗？有的，我们生产使用的是 grafana + prometheus 的组合。下图是监控的 JVM dashbord 是对 JVM 堆空间和线程的监控。最上面的是CPU 使用率，绿色表示System CPU 使用率，黄色表示JVM 的 CPU 使用率。下面的两个图表则表示堆空间和非堆部分的空间使用情况。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210525005416.png"></p><p>下面这张图主要展示了线上真实的JVM GC的情况，可以看到堆空间曲线随着时间是呈现一个锯齿状的。而非堆部分则是一直都是平直的，这是垃圾回收器在堆中工作的结果。下面的两个折线图则分别是GC次数和GC时长的统计图，但看到这个图的时候我有一点疑惑的地方，堆空间能清楚的看到每次垃圾的回收产生的曲线下降，但是为什么他下面的记录GC次数的图中却没有呢？后来我查了线上的的GC日志，确认是GC count中漏记了。有哪位大神知道这是为什么，帮我答疑解惑一下。这里还有一个细节，就是GC count和GC time图表下面的<code>PS MarkSweep</code>和 <code>PS Scavenge</code> ，这分别代表这 Parallel GC 的老年代回收器和新生代回收器。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210525005443.png"></p><p>JVM dashbord 还有很多的图表，这些都是可以配置的，但是都是对堆栈线程的监控。当然 grafana 还可以集成其他类型的监控，比如主机资源、es和http请求等监控内容非常丰富。但是grafana 或者 datadog 这种监控集成工具也就是只有展示的功能，它并不具备像 JFR 或 jvisualvm 抽样分析的功能。如果真的出现了问题还是要dump内存线程或者开启JFR进行排查分析。</p><h2 id="内存泄漏分析实例"><a href="#内存泄漏分析实例" class="headerlink" title="内存泄漏分析实例"></a>内存泄漏分析实例</h2><p>这里我们使用一段会不断产生垃圾的代码，然后我们设置 JVM 的启动参数为 <code>-Xmx128m -Xms128m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./heap.hprof</code> （jdk8）。这段参数限制的堆空间的大小为<code>128m</code>，并且在堆空间溢出时dump堆内存到<code>./heap.hprof</code>中。垃圾生成代码如下：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> class GCLogAnalysis &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Random <span class="hljs-built_in">random</span> = <span class="hljs-keyword">new</span> Random();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        <span class="hljs-comment">// 当前毫秒时间戳</span><br>        <span class="hljs-keyword">long</span> startMillis = System.currentTimeMillis();<br>        <span class="hljs-comment">// 持续运行毫秒数; 可根据需要进行修改</span><br>        <span class="hljs-keyword">long</span> timeoutMillis = TimeUnit.SECONDS.toMillis(<span class="hljs-number">10</span>);<br>        <span class="hljs-comment">// 结束时间戳</span><br>        <span class="hljs-keyword">long</span> endMillis = startMillis + timeoutMillis;<br>        LongAdder counter = <span class="hljs-keyword">new</span> LongAdder();<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;正在执行...&quot;</span>);<br>        <span class="hljs-comment">// 缓存一部分对象; 进入老年代</span><br>        <span class="hljs-built_in">int</span> cacheSize = <span class="hljs-number">2000</span>;<br>        <span class="hljs-keyword">Object</span>[] cachedGarbage = <span class="hljs-keyword">new</span> <span class="hljs-keyword">Object</span>[cacheSize];<br>        <span class="hljs-comment">// 在此时间范围内,持续循环</span><br>        <span class="hljs-keyword">while</span> (System.currentTimeMillis() &lt; endMillis) &#123;<br>            <span class="hljs-comment">// 生成垃圾对象</span><br>            <span class="hljs-keyword">Object</span> garbage = generateGarbage(<span class="hljs-number">100</span>*<span class="hljs-number">1024</span>);<br>            counter.increment();<br>            <span class="hljs-built_in">int</span> randomIndex = <span class="hljs-built_in">random</span>.nextInt(<span class="hljs-number">2</span> * cacheSize);<br>            <span class="hljs-keyword">if</span> (randomIndex &lt; cacheSize) &#123;<br>                cachedGarbage[randomIndex] = garbage;<br>            &#125;<br>        &#125;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;执行结束!共生成对象次数:&quot;</span> + counter.longValue());<br>    &#125;<br><br>    <span class="hljs-comment">// 生成对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">Object</span> generateGarbage(<span class="hljs-built_in">int</span> <span class="hljs-built_in">max</span>) &#123;<br>        <span class="hljs-built_in">int</span> randomSize = <span class="hljs-built_in">random</span>.nextInt(<span class="hljs-built_in">max</span>);<br>        <span class="hljs-built_in">int</span> type = randomSize % <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">Object</span> result = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">switch</span> (type) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[randomSize];<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[randomSize];<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[randomSize];<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder();<br>                <span class="hljs-keyword">String</span> randomString = <span class="hljs-string">&quot;randomString-Anything&quot;</span>;<br>                <span class="hljs-keyword">while</span> (builder.length() &lt; randomSize) &#123;<br>                    builder.<span class="hljs-built_in">append</span>(randomString);<br>                    builder.<span class="hljs-built_in">append</span>(<span class="hljs-built_in">max</span>);<br>                    builder.<span class="hljs-built_in">append</span>(randomSize);<br>                &#125;<br>                result = builder.toString();<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果一切顺利堆空间溢出就可以在项目根目录下就可以得到一个<code>heap.hprof</code>文件，这就是我们分析的目标文件了。前面我们提到的jmc可以用来分析<code>.hprof</code>文件。这里我们使用<code>Eclipse MAT</code>进行分析。以我们的经验一般堆栈溢出都是内存泄漏，所以我们选择泄漏分析报告。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210525223345.png"></p><p>打开后直接就能看到 MAT 根据内存数据分析推测出的内存泄漏的原因，下图可以看到<code>Problem Suspect 1</code>占到了<code>99.69%</code>的内存，虽然这里只是刚刚打开.hprof 文件但基本上可以推测出内存泄漏的原因了。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210526175246.png"></p><p>在 Suspect Report 中有很多的选项，包括一些<code>线程</code>和<code>堆积对象</code>信息。在这个部分基本可以推断出系统发生内存溢出的原因了。也就是我们垃圾生成类的主线程产生了太多的垃圾，导致较小的内存溢出了。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210525224907.png"></p><p>如果到这里还是不能确定问题发生的根源没关系。MAT 还有一些其他的分析方式，我们一起来看 MAT 的首页信息。首先最上面是一个饼状图，然后下面有各种各样的操作和报告可以选择，这里面包括<code>对象实例的柱状图</code>、<code>对象的树形结构</code>、<code>打印开销最大的几个对象</code>和<code>重复类分析</code>等，还有一些分析报告可以选择。功能方面虽然分析的内容没有 JFR 全面，但是通常来说这么多信息已经足够帮助我们分析出内存泄漏的根源了。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210525225515.png"></p><h2 id="线上分析工具"><a href="#线上分析工具" class="headerlink" title="线上分析工具"></a>线上分析工具</h2><h3 id="FastThread"><a href="#FastThread" class="headerlink" title="FastThread"></a>FastThread</h3><p>fastThread 是一个优秀的Java dump线程分析工具，只要把线程 dump 上传，即可进行在线分析，分析结果都是以图表展示，可展示项非常多并支持结果 pdf 导出，是一个非常优秀的在线分析工具。这里就不具体展开了，感兴趣的同学可以自己动手实操试试。传送门 ==&gt; <a href="https://fastthread.io/">fastThread</a></p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210525233153.png"></p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210525233653.png"></p><h3 id="GCEasy"><a href="#GCEasy" class="headerlink" title="GCEasy"></a>GCEasy</h3><p>GCEasy 是一款优秀可视化的 GC 日志分析工具，使用前需要把日志信息上传然后进行分析，分析结果以图表的方式展示，同样也支持结果 pdf 导出。GCEasy 和 fastThread 是同一家的产品，两者图表风格是一致的。感兴趣的同学可以动手实操试试，很有意思。传送门 ==&gt; <a href="https://www.gceasy.io/">GCEasy</a></p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210525235015.png"></p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210525235015.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我之前都不是很重视 JVM 的监控，但是那次线上事故之后我意识到JVM监控的重要性。这一小节我们一起从JDK自带的监控工具开始梳理，其中命令行工具包括常用的 <code>jps</code>、<code>jstatck</code>、<code>jmap</code>、<code>jstat</code>、<code>jcmd</code> 等，图形化工具包括 <code>jconsole</code>、<code>jvisualvm</code>和后来独立软件包的<code>jmc</code>，其中jmc中的<code>jfr</code>基本可以满足监控的需求。jdk 提供的工具在理想情况下是能够正常监控的，但是有些时候是无法正常使用了，会报无法 attach 的异常，还有我们也平时不会有生产环境服务器的权限。所以仅仅使用 JDK 自带的工具进行监控是不太现实的。那我们要如何进行监控呢？我们使用可视化集成工具，我们演示的是 <code>grafana</code> 通过集成 <code>prometheus</code> 实现对 JVM 基本信息的监控。基本可以满足我们对于线上服务大体运行情况的监控。如果我们线上遇到了问题我们要怎么处理呢？紧接着我们演示了一个内存泄漏的分析案例，使用<code>Eclipse MAT</code>对一个内存溢出的<code>.hprof</code>文件进行简单实例分析。最后我们简单介绍了两个在线分析工具 fastThread 和 GCEasy。JVM 监控还有一个很好用的开源工具<code>Arthas</code>，感兴趣的同学可以动手实践。</p><p>这一小节有大量的动手实践，再加上我最近也挺忙的，这一小节我写了好久好久😅😅。终于要进入 JVM 很精彩的GC模块了，梳理完GC模块什么JVM调优，GC分析就都不是事了。加油，你的努力终究会照亮你的生活，晚安～</p>]]></content>
    
    
    <categories>
      
      <category>Java虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>Java知识结构梳理</tag>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 内存结构与内存模型初步</title>
    <link href="/2021/05/17/java-memory-structure-and-basic-model/"/>
    <url>/2021/05/17/java-memory-structure-and-basic-model/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前面的小节中，总结梳理了 JVM 底层的一些基础的东西，包括 JVM 字节码技术，方法的调用，反射，异常等方法流程，基础的最后一部分梳理了类加载机制和对象的内存布局。有了这一套机制 JVM 能够顺利的读取Java文件，并行执行逻辑。看起来都有了，但是少了一个重要的部分没错，就是内存。这计算机的内存这个部分来的像理所当然一样。其实最原始的计算机是没有内存这个概念的，后来冯诺依曼提出了冯诺依曼结构，冯诺依曼确定了计算机的结构，即确定了计算机的 5 大部件，即<code>运算器</code>、<code>控制器</code>、<code>存储器</code>、<code>输入设备</code>和<code>输出设备</code>。现代计算机的都是遵循冯诺依曼结构的，因此又称为冯诺依曼机。所以作为虚拟机怎么能没有内存呢？Java 内存模型规定了 JVM 应该如何使用计算机内存（RAM）。广义上来讲，Java内存模型分别为两个部分 <code>JVM内存结构</code> 和 <code>JMM与线程规范</code>。</p><h2 id="JVM-内存结构"><a href="#JVM-内存结构" class="headerlink" title="JVM 内存结构"></a>JVM 内存结构</h2><p>JVM 内存结构是 JVM 的底层的实现，它决定了运行时数据的数据区划分。那么如果让你结合我们前面的知识设计一个 JVM 结构模型，你会怎么做呢？</p><h3 id="动手设计一个-JVM-内存结构"><a href="#动手设计一个-JVM-内存结构" class="headerlink" title="动手设计一个 JVM 内存结构"></a>动手设计一个 JVM 内存结构</h3><p>从我们前面梳理的 JVM 方法调用小节中，我们知道方法调用会用到栈，每个正在运行的线程都有自己的线程栈，线程每调用一个方法都会创建一个栈帧。在类加载那一小节我们知道了对象实例存在堆上，然后通过一个存在栈上的引用指向堆中的实例对象的地址。所以我们还需要一个堆空间。所以内存空间我们可以简单划分为栈（stack） + 堆（heap） 的结构（1.0 版本）。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210515190729.png"></p><p>线程栈上是有数据的，包括一些局部方法内部的基础类型变量和一些对象的引用指向堆中实例地址。上面这个图太过于粗略了我们加入一点点细节。就像下图酱紫，每个栈有局部变量和对象引用，对象的引用地址指向堆中。（2.0 版本）</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210515192514.png"></p><p>结合下我们之前梳理的类初始化和实例对象有关内存的部分再次简单过一遍。类加载器加载类并且解析成字节码，字节码中会有会有流程控制方法字节码和常量池等信息。其中方法名和类名都会先用常量代替，然后在类加载的解析阶段替换成引用。最后实例对象的时候，会根据类的 class 的常量信息在堆中创建一个实例对象。实例对象主要有三个部分对象头、实例数据、填充数据。这里面对象头里面又有一个 markWord 和 classPointer，classPointer 指向方法区中实例的 class 对象。这一路梳理下来不难发现，我们少了一个常量池和一个方法区。我们再加入一点点细节。（3.0 版本）</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210515195133.png"></p><p>结合之前的知识我设计的一个简单的 JVM 内存结构就出来了，大家可以按照自己的理解动手设计一个内存结构，一定会有不一样的收获。 </p><h3 id="JVM-内存结构概述"><a href="#JVM-内存结构概述" class="headerlink" title="JVM 内存结构概述"></a>JVM 内存结构概述</h3><p> 前面是结合 JVM 的字节码类加载等机制构想设计出来的 JVM 内存，真正的 JVM 内存可能不长这个样子，那真正的 JVM 内存结构长什么样子呢？因为我在之前还是有接触过一些 JVM 内存结构这块的知识，之前的知识已经给我的设计打下一个大致的方向了，所以我画出来的 JVM 的基本逻辑结构和我们设计的大体的方向上还是一致的。JVM 内存结构逻辑上大体分为：线程栈（stack）和 堆内存（heap）两个部分。也就是 1.0 版本一致。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210515190729.png" alt="image.png"></p><p>JVM 中，真在运行的每个线程都有自己的线程栈。线程栈上包含正在执行的方法链/调用链上的所有方法的状态信息。所有线程栈又被成为<code>方法栈</code>或<code>调用栈</code>（call stack）。线程在执行代码的时候，调用栈中的信息会一直变换。我们抛出异常时打印出的堆栈信息也就是这个方法调用栈。</p><p>线程栈上保存了调用链上的正在执行的所有方法的局部变量。</p><ul><li>每个线程只能访问自己的线程栈。</li><li>每个线程栈都不能访问（看不见）其他的线程的局部变量。</li></ul><p>即时两个线程执行完全相同的代码，他们也看不到彼此的局部变量，因为每个线程都会在自己的线程<code>栈内创建</code>代码中对应的局部变量，也就是说每个线程栈中的数据只是一个<code>副本</code>，线程与线程之间并不共享。</p><ul><li>所有的原生数据变量都存储在线程栈中，因此对其他线程不可见。</li><li>线程栈可以将一个原生变量的副本传给另外一个线程，但不共享原生变量副本本身。</li><li>堆中包含了Java 代码中创建的所有对象，不管是哪个线程创建的，其中也涵盖了包装类型（例如 Byte、Integer、Boolean 等）。</li><li>不管是创建给局部变量，还是创建对象赋给局部变量，创建的对象都会保存在堆中。</li></ul><blockquote><p>简单来说就是，原生数据类型和对象引用在线程栈上，实例对象，对象成员来、类定义和静态变量都在堆上。线程栈上的数据是副本，所以线程之间相互隔离。</p></blockquote><p>堆内存又称为<code>共享堆</code>，<code>堆中的所有对象可以被所有的线程访问到</code>，只要他们能拿到对象的引用地址。</p><ul><li>如果一个线程能访问到某个对象，也就可以访问该对象的成员变量。</li><li>如果两个线程能同时调用同一个方法，则它们它们都可以访问到这个对象的成员变量，但每个线程的局部变量副本都是独立的。（方法传入同一对象，只要是同一引用就都能看见。）</li></ul><p>把上面这些东西落实到图上就是我们的 2.0 版本。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210515192514.png"></p><blockquote><p>简单小总结下：虽然各个线程自己使用的局部变量都在自己的线程栈上，但是大家可以共享堆上的对象。如果不同线程访问同一个对象实例的基础类型的成员变量，并往自己的线程栈上赋值，实例对象会给线程一个变量副本。</p></blockquote><h3 id="栈内存结构"><a href="#栈内存结构" class="headerlink" title="栈内存结构"></a>栈内存结构</h3><p>前面我们自己尝试设计的栈结构非常的简单，就是一个简单栈的数据结构，实际上并不完全是这样。结合前面方法调用部分的知识，栈的逻辑区域里应该有很多的线程栈，毕竟一个线程就会创建一个线程栈（调用 JNI 方法会使用 Native 栈）。而且线程栈里面应该也会有很多的栈帧，因为我们知道每调用一个方法就会创建一个栈帧，就类似下面这样的一个结构。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210516153009.png"></p><p>我们知道调用方法就会创建栈帧，栈帧里面有<code>操作数栈</code>，<code>局部变量表</code>和一个<code>class/method引用</code>，有了这些还不够这些只能保证方法的顺利执行，方法执行之后还要返回。所以还有一个<code>返回地址</code>。所以栈帧内部的图大致是这样的。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210516154106.png"></p><h3 id="堆内存的结构"><a href="#堆内存的结构" class="headerlink" title="堆内存的结构"></a>堆内存的结构</h3><p>在上面的线程的分析图中，我们可以看到在 JVM 进程里面有堆内存和非堆内存，这个非堆又是什么呢？别着急我们慢慢往下看。在前面的概述介绍堆的时候说堆是对所有线程共享的内存区域。大家都知道我们 JVM 是会自动GC的，不会在被引用或者说死掉的对象会被回收，但是所有的对象他们呢生命周期都是一样的吗？会不会存在一些永远不会被回收的对象呢？答案是存在的。在前面的类加载的小节中我们说过，JVM 会把类加载进内存，会创建 Class 对象并且会保存类常量池中的常量。如果我们这部分的数据被 GC 了，那我们遇到所有的需要加载类的场景又将重新加载。这将极大影响 JVM 整体的性能。所以这里的堆也被称为：GC 管理的堆（GC Heap）。如果堆和栈的逻辑划分是建立在线程是否可以共享的纬度逻辑上，那么堆和非堆的逻辑划分就是建立实例对象生命周期的纬度上的。</p><p>为了最高化的提高 GC 的效率，堆也划分除了新生代和老年代的概念，就像这个字面意思一样，新生代都是新创建的对象，这些对象在新生代经历几次GC，如果他们还活着那么它们将进入老年代。但这也不绝对，在某些特定的场景下新创建的对象会直接进入老年代。</p><p>非堆本质上还是堆，但是一般不归 GC 管理。里面大致划分为3个内存池。</p><ul><li><code>Metaspace</code>, 以前叫持久代(永久代, Permanent generation), Java8换了个名字叫 Metaspace.  Java8将方法区移动到了Meta区里面，而方法又是class的一部分。。。和CCS交叉了? </li><li><code>CCS, Compressed Class Space,</code> 存放class信息的，和 Metaspace 有交叉。 </li><li><code>Code Cache</code>, 存放 JIT 编译器编译后的本地机器代码。 </li></ul><h3 id="其他部分和鸟瞰-JVM-内存"><a href="#其他部分和鸟瞰-JVM-内存" class="headerlink" title="其他部分和鸟瞰 JVM 内存"></a>其他部分和鸟瞰 JVM 内存</h3><p>除了栈和堆 JVM 还有一个 <code>PC 计数器</code> 这个计数器类似于 CPU 的寄存器，<code>用于记录下一条指令的位置</code>。在早期的CPU 都是单核的，那如果实现多线程呢？没错，使用切换执行上下文的方式 。所以 PC 计数器记录的就是当前线程执行的位置，让 CPU 切换回来的时候能继续执行下去。还有一个部分就是直接内存。直接内存不是运行时数据的一部分，也不是《Java内存规范》中定义的一部分，它是 JVM 直接向内存申请的空间。一般不会直接操作，但是在Netty中有相关的配置参数。结合上面所有的梳理的点，我们可以试着画出一个大致的 JVM 内存图了。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210516164240.png"></p><h3 id="内存溢出分析"><a href="#内存溢出分析" class="headerlink" title="内存溢出分析"></a>内存溢出分析</h3><p>Java 虽然有全自动的 GC，但是也不能避免内存溢出的问题。那如何解决内存溢出的问题，要想解决这个问题先要搞明白内存溢出是什么？内存溢出（OOM）指的是当程序需要的内存中存在过多无法回收的内存，最终使得<code>内存需要的空间大于系统能提供的最大空间</code>，这时候一般系统会抛出 OOM 异常。</p><blockquote><p>这个类似于很早之前我们内存很小的手机同时打开了很多的后台应用，这个时候你又打开了一个很吃内存的游戏，然后这个游戏突然闪退了。。。这个时候往往通过手动清理后台或者重启手机之后再次打开的方式解决。</p></blockquote><p>前段时间看到一个问题内存溢出和内存泄漏有什么区别。内存泄漏这一听就知道不是一个好词，内存泄漏<code>往往指的是申请了内存资源之后由于某些原因迟迟不能释放</code>。造成系统资源的浪费，减慢程序运行速度，最终可能会内存溢出拖垮整个系统。所以内存泄漏更多的偏向是代码层面造成的资源浪费，内存泄漏有可能会导致OOM。</p><blockquote><p>两者关系 内存泄漏可能会导致内存溢出，内存溢出会抛出异常，内存泄漏不会，并且大多数时候系统看上去像是正常运行的。</p></blockquote><p>所以哪些 JVM 里面哪些区域会内存泄漏呢？在那些区域不会内存溢出呢？在《Java虚拟机规范》中只定义一个地方不会发生内存溢出。那就是 PC 计数器，因为 PC 记录器记录的就是当前线程执行的位置，所以 PC 计数器中只保存一个数。这个内存大小不会随着程序的执行而增加。每申请一个线程就会创建一个 PC 计数器。其他的内存区域随着空间的分配都可能存在 OOM。</p><h2 id="JMM-内存模型介绍"><a href="#JMM-内存模型介绍" class="headerlink" title="JMM 内存模型介绍"></a>JMM 内存模型介绍</h2><h3 id="CPU-指令与乱序执行"><a href="#CPU-指令与乱序执行" class="headerlink" title="CPU 指令与乱序执行"></a>CPU 指令与乱序执行</h3><p>学计算机的都知道，基本上计算机的指令集分为两种，精简指令集和复杂指令集合，其中精简指令集是以 ARM 架构为主，现在的手机芯片和苹果的 m1 都是基于 ARM 架构的，其特点就是功耗低但是性能较弱，但是随着这几年的芯片技术的提升，ARM 架构芯片的性能也在逐步提高，例如苹果的M1芯片也可以吊打 Intel 的CPU。复杂指令集的代表就是 Intel 和 AMD 的 x86 架构的芯片，基于复杂指令集的特点就是功耗比较高，但是性能强。我们都知道 CPU 有很多的指令，实现一个操作有很多的方式，复杂指令集把这些操作封成一个复杂指令，而基于简单指令集的CPU把这个复杂操作拆分多个简单指令去完成。两者都可以完成这个操作，但是，就效率而言还是复杂指令集更高。</p><p>不管是哪一种指令集，CPU 的流水线工作方式都是一致的。如果一个操作的所有的指令都放在一个流水线上，这样很多的流水线就是闲置的，所以聪明的开发者想到一个办法就是，只要保证最后的执行结果是正确的，乱序执行也没关系。所以CPU完全可以根据需要通过内部调度把这些指令打乱了执行，充分利用流水线资源，只要最终结果是等价的那么程序的正确性就没有问题。但这在如今多CPU内核的时代，随着复杂度的提升，并发执行的程序面临了很多问题。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210517004750.png"></p><h3 id="JMM-概述"><a href="#JMM-概述" class="headerlink" title="JMM 概述"></a>JMM 概述</h3><p>随着多核时代的到来和 JVM 多线程并发执行，JVM在不同环境下保证程序执行结果正确性变得越来越复杂。因此 JVM 推出一套 Java  内存模型来统一约束线程之间可见性等一系列规则，来保证最终执行结果的正确性。JMM规范明确定义了不同的线程之间，通过哪些方式，在什么时候可以看见其他线程保存到共享变量中的值；以及在必时如何对共享变量的访问进行同步。这样的好处是屏蔽各种硬件平台和操作系统之间的内存访问差异，实现了Java并发程序真正的跨平台。 其中并发中的很多的关键字包括 synchronzied，volatile 都是 JMM 定义的。这些内容我们将放到多线程实战部分进行梳理。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一小节我们承接之前的学的关于Java运行时数据的一些知识，尝试动手设计一个简单的 Java 内存结构。Java 内存结构包括 堆、栈、PC 计数器，其中栈，每个线程都会创建一个线程栈，栈也分方法栈和 Native 栈，线程栈内又包括很多的栈帧用于存储当前线程方法调用的数据。堆的逻辑内存区也分堆和非堆，堆也称为 GC 管理的堆，因为堆是 GC 工作的区域，堆里面也分新生代和老年代。非堆中主要包括元数据区、Compressed class space 和 code cache ，其中元数据区域主要包括方法区和常量池，CCS 保存的 Class 信息，Code cache 存储 JIT 编译后的机器码。每一个线程都有自己的 PC 计数器，PC 计数器负责记录当前程序执行的位置，方便 CPU 进行上下文切换回来之后能跳到正确的位置继续执行。在这些区域中，除了了PC 计数器所有的内存区域都会发生内存溢出。最后我们简单过了下 JMM 也就是 Java 内存模型，JMM规范明确定义了不同的线程之间的可见性和访问同步，保证 JVM 在不同的环境下都能得到一致且正确的结果。具体的 JMM 的细节我们放在并发编程模块再来细细的梳理。加油，晚安！</p><h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/136748306">三分钟带你了解冯.诺依曼结构</a></li><li>Java内存模型：海不辞水，故能成其深 </li></ul>]]></content>
    
    
    <categories>
      
      <category>Java虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>Java知识结构梳理</tag>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 基础 — 类加载机制和对象内存布局</title>
    <link href="/2021/05/14/class-load-and-jol/"/>
    <url>/2021/05/14/class-load-and-jol/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前面一篇中提到了方法的调用，方法在类加载阶段会由符号引用替换实际引用或者方法表的索引。Java 的类加载机制又是怎么样的呢？这里聊一个小插曲，我记得我刚毕业那会去面中兴，基础的问题都回答的挺好的但是最后面试官问了我这个问题，Java 虚拟机是怎么加载一个类的？我当时脑子懵了，对象怎么加载到内存？对象是 new 出来的的啊，还要加载？我也对这块不太了解，然后面试官也就没深了问。但是现在看来，如果是进阶 Java 的话这是一个基础不能在基础的问题了。类加载了这还不算完，Java 的类是怎么保存的，我相信很多朋友会回答存放在堆里，那其他特殊的类型呢 例如 String 类型又是怎么存储的呢？我们在内存溢出的时候，对象怎么就把我们的堆给堆满了，每个对象占了多大的空间呢？请朋友们慢慢往下看。</p><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>想要知道一处的细节不如先鸟瞰全局，先了解类的声明周期是什么样的先有个大体的概念。在了解的类的声明周期之后才能更好的理解 JVM 是如何加载一个类的</p><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210511003453.png"></p><p>上面这张图是非常经典的一张图，类的生命周期有7个步骤，分别是 <code>加载（Loading）</code>、 <code>验证（Verification）</code>、<code>准备（Preparation）</code>、<code>解析（Resolution）</code>、<code>初始化（Initialization）</code>、<code>使用（Using）</code>、<code>卸载（Unloading）</code>。其中前五个部分（加载、验证、准备、解析、初始化）统称为类加载。</p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>加载阶段也称作”装载”阶段。这个阶段主要的操作是，更具明确知道的 class 完全限定名，来获取类的二进制的 .class 文件</p><p>简单来说就是从文件系统/jar包中/或者网路中，任何地方存在的<code>class文件</code>，如果没找到会抛出 <code>NoClassDefFound</code> 错误。加载阶段不会检查 classfile 的格式和语法问题，只是单纯的加载文件。类加载的整个阶段由 JVM 和类加载器（某一个）共同协作完成。</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证阶段也是链接过程的第一个阶段，这个阶段的操作逻辑也很简单，就是确保 class 文件的字节流数据是符合虚拟机要求的不会危害到虚拟机的安全。简单来说就是一些格式和语法的校验，在这个过程中可能会抛出 <code>VerifyError</code>，<code>ClassFormatError</code> 或 <code>UnsupportedClassVersionError</code>，注意这里排除的 Error 错误，Error 只有虚拟机无法正常执行了才会抛出的异常。</p><p>验证也是链接的一部分，所以在这个部分 JVM 必须加载所有的超类和接口。如果发现类的层次结构有问题 JVM 会抛出 <code>ClassCircularityError</code>。而如果实现接口不是一个 interface，或者声明的超类不是一个 interface 也会抛出 IncompatibleClassChangeError。</p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>在这个阶段会创建静态字段并为其初始化标准默认值（比如 <code>null</code> 或者 0），并分配方法表，及在方法区中分配这些方法的使用的<code>内存空间</code>。⚠️ 请注意，在这个阶段没有执行任何的 Java 代码。</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>然后JVM 会进入可选的解析符号引用阶段。也就是解析类文件里面的常量池，主要有下面四种：类或接口的解析、字段解析、类方法解析、接口方法解析。在解析阶段要做的是就是把符号引用解析为直接引用（相当于直接指向了实际的对象），如果有了直接引用，那么引用的目标对象一定在堆中。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>如果直接赋值的静态字段被 final 所修饰，并且它的类型是基本类型或字符串时，那么该字段便会被 Java 编译器标记成常量值（ConstantValue），其初始化直接由 Java 虚拟机完成。除此之外的直接赋值操作，以及所有静态代码块中的代码则会被 Java 编译器置于同一方法中，并把它命名为<code>&lt;clinit&gt;</code>。</p><p>类只有在首次 “主动使用” 才能执行类的初始化。是 <clinit> 方法不是构造器，只有主动使用才会调用构造器方法。</p><p>类加载的最后一步是初始化，便是为标记为常量值的字段赋值，以及执行 &lt; clinit &gt; 方法的过程。Java 虚拟机会通过加锁来确保类的 &lt; clinit &gt; 方法仅被执行一次。</p><blockquote><p>这个流程应该是每个Java 程序员都应该熟记于胸的，一开始我记忆这个部分也是硬着头皮记，也很容易忘。偶然有一天我在饭，突然发现这个类加载机制像做饭的过程。加载过程就像是买菜，类加载进入JVM 就像把菜买回家。然后菜买回来之后呢，要检查检查，确认买的菜都是对的，不然买错了或者什么漏买了就很尴尬了，这个过程呢就像类加载流程里面的验证，要检查字节码文件符合虚拟机要求不会危害到虚拟机安全。做饭也要需要准备，要洗菜择菜，就像我们的准备阶段为类准备分配内存空间。这部分结束了，我们就可以热锅开始做菜了。这个部分按照菜谱加入各种调味料，把各个食材混合在一起，就像解析，把各个符号引用替换为直接引用，让各个部分关联起来。然后我们菜就做好了，我们就可以装盘出锅了。这个部分就是类的初始化，经过这个部分之后，一个类就可以正常的使用了，我们也可以吃饭了，最后类使用完之后卸载，我们吃完了也就要洗碗了。哈哈是不是很像。</p><p>加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 -&gt; 使用 -&gt; 卸载。</p><p>买菜 -&gt; 检查菜 -&gt; 洗菜 -&gt; 炒菜 -&gt; 装盘 -&gt; 吃饭 -&gt; 洗碗。 </p></blockquote><h3 id="类的加载时机"><a href="#类的加载时机" class="headerlink" title="类的加载时机"></a>类的加载时机</h3><p>类并不是在虚拟机一启动就会全部加载进来，而是会<code>按需加载</code>，那在什么时候才会加载目标类呢？</p><ol><li>当虚拟机启动时，初始化用户指定的主类。</li><li>当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类。</li><li>当遇到调用静态方法的指令时，初始化该静态方法所在的类。</li><li>当遇到访问静态字段的指令时，初始化该静态字段所在的类。</li><li>子类的初始化会触发父类的初始化。</li><li>如果一个接口定义了 deault 方法，那么直接实现偶着间接实现该接口的类初始化，会触发该接口的初始化。</li><li>使用反射 API 对某个类进行反射调用时，初始化这个类。</li><li>当初次调用 MethodHandler 实例，初始该 MethodHandler 指向的方法所在类。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyHolder</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> LazyHolder.INSTANCE;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码是在著名的单例延迟初始化，只有当调用 Singleton.getInstance 时，程序才会访问 LazyHolder.INSTANCE，才会触发对 LazyHolder 的初始化（对应第 4 种情况），继而新建一个 Singleton 的实例。</p><h3 id="类加载器机制"><a href="#类加载器机制" class="headerlink" title="类加载器机制"></a>类加载器机制</h3><p>类的加载过程可以描述为”通过一个类的全限定名 a.b.c.xxx.XXClass 来获取此类的 Class 对象。这个过程由类加载器来完成。这样的好处在于，子类加载器可以复用父加载器加载的类。系统自带的加载器分为三种：</p><ul><li><code>启动类加载器</code>（BootstrapClassLoader）</li><li><code>扩展类加载器</code>（ExtClassLoader）</li><li><code>应用类加载器</code>（AppClassLoader）</li></ul><p>一般启动类加载器是由 JVM 内部实现的，在 Java 的 API 里面是无法拿到了，是用 C++ 实现的，后面两种在 Oracle Hotspot JVM 中，都在 sun.misc.Lanucher 定义的，扩展类加载器和应用类加载器一般都继承自 <code>URLClassLoader</code> 类，这个类也默实现了从不同的源来加载 class 字节码换成的 Class 的方法。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210512000947.png"></p><ol><li>启动类加载器（bootstrap class loader）：它用来加载 Java 的核心类，用原生的 C++ 实现并不继承自 java.lang.Classloader。负责加载 JDK 中 <code>jre/lib/rt.jar</code> 中的所有 class。可以把它看作是 JVM 自带的，同时我们也无法获取它的引用。</li><li>扩展类加载器（extensions class loader）：它用来加载 <code>lib/ext</code> 或者由系统路径 <code>java.ext.dirs</code> 指定的目录中的 Jar 包中的类。</li><li>应用类加载器（application class loader）：它负责在 JVM 启动时加载来自 <code>Java 命令 -classpath</code> 或者 <code>-cp</code> 或者指定系统路径 <code>java.class.path</code> 系统属性指定的 jar 包和类路径。 可以通过 <code>ClassLoader.getSystemClassLoader()</code> 来获取类应用加载器。</li></ol><p>用户可以自定义类加载器，如果自定义类加载器，自定义的类加载器的应该以应用加载器作为父类。下面就是一个自定类加载器。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> HelloXlassLoader extends ClassLoader &#123;<br><br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Object hello = <span class="hljs-keyword">new</span> <span class="hljs-constructor">HelloXlassLoader()</span>.find<span class="hljs-constructor">Class(<span class="hljs-string">&quot;Hello&quot;</span>)</span>.<span class="hljs-keyword">new</span><span class="hljs-constructor">Instance()</span>;<br>            Method <span class="hljs-keyword">method</span> = hello.get<span class="hljs-constructor">Class()</span>.get<span class="hljs-constructor">Method(<span class="hljs-string">&quot;hello&quot;</span>)</span>;<br>            <span class="hljs-keyword">method</span>.invoke(hello);<br>        &#125; catch (Exception e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>        &#125;<br>    &#125;<br><br>    @Override<br>    protected Class&lt;?&gt; find<span class="hljs-constructor">Class(String <span class="hljs-params">name</span>)</span> throws ClassNotFoundException &#123;<br>        byte<span class="hljs-literal">[]</span> <span class="hljs-built_in">bytes</span> = get<span class="hljs-constructor">BytesFromXXX()</span>;<br>        handle<span class="hljs-constructor">Bytes(<span class="hljs-params">bytes</span>)</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bytes</span>.length<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;file load error&quot;</span>);<br>        &#125;<br>        return define<span class="hljs-constructor">Class(<span class="hljs-params">name</span>, <span class="hljs-params">bytes</span>, 0, <span class="hljs-params">bytes</span>.<span class="hljs-params">length</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>类加载器有三个特点：</p><ol><li><code>双亲委派</code>：大名鼎鼎的双亲委派其实很简单，也没有什么所谓的双亲，就是优先给父类加载器加载，如果父类加载不了再自己来加载。例如 String 类型，appClassLoader 看到了不加载，给 extClassLoader，extClassLoader 也不加载，给bootstrapClassLoader 加载，bootstrapClassLoader 一看 java.lang.String 是在 rt 包里的就给加载了。这也不是说加载器懒，这样可以保证，<code>某一个类每次都能被特定的某个加载器加载。</code></li><li><code>负责依赖</code>：如果一个加载器在加载某个类的时候，发现这个类依赖的另外几个类或者接口，也会去是这尝试加载这些依赖。</li><li><code>缓存加载</code>：为了提高效率避免重复加载，一旦某个类被一个加载器加载，那么它就会缓存这个加载结果，不会重复加载。这也是双亲委派的目的。</li></ol><h2 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h2><p>前面的部分我们聊到了，Java 对象是如何加载一个类的，但是我们要真正的使用一个对象，需要根据我们加载的类去创建一个对象。那创建的过程是怎么样的呢？</p><h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><p>我想起来一个段子，把大象放进冰箱需要几步？需要三步！打开冰箱门，把大象放进冰箱，把门关上。其实我们的 Java 创建对象过程也可以大致分为三步，申请内存 —&gt; 初始化数据（代码块和构造）-&gt; 关联引用。</p><ol><li><code>构建对象</code>（申请空间），这个过程首先线程会申请一个栈空间，并且生成栈帧然后执行 new 操作。线程会根据加载的类信息申请一块内存构建对象，并且为成员变量赋默认值。</li><li><code>对象初始化</code>，这个部分就是执行 {} 代码块和构造方法了。</li><li><code>关联引用</code>，我们创建的对象的引用是在栈上面，然而我们创建的对象是在堆中，最后一步就是把栈上的对象引用指向堆中的地址。</li></ol><blockquote><p>打开冰箱 = 申请空间，放入大象 = 对象初始化， 关联引用 = 关上冰箱门 </p></blockquote><h3 id="对象在内存的布局"><a href="#对象在内存的布局" class="headerlink" title="对象在内存的布局"></a>对象在内存的布局</h3><p>我们现在创建好了一个对象，难道一个对象在堆中存的就真的是一堆变量数据就没有其他的东西吗？</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210513231532.png"></p><p>对象在内存的中并不只有实例的数据，而是包含三个部分，<code>对象头</code>、<code>实例数据</code>、<code>内存填充</code>。</p><ul><li>对象头：按照实例对象的不同，对象头也有不同，主要的就是包含<code>Mark word</code>，<code>class pointer</code>，数组对象还包括数组长度。MarkWord 里面包含有对象的哈希码，锁信息，GC 等信息。ClassPointer 这个很明显，这是一个指针指向方法区的 Class 对象 ，在数组实例中还要记录数组的长度，在 64 位的系统中markWord占<code>8</code>个字节，如果开启指针压缩，这个大小可以压缩到 <code>4</code>个字节，也就是如果不开启指针压缩的话，再加上 class pointer 4 个字节，实例对象头 12 个字节，数组对象头占 16 个字节，开启指针压缩后，实例对象 对象头8个字节，数组对象对象头 12 个字节。</li></ul><blockquote><p>对象头 不开启指针压缩 实例 12 字节，数组 16 字节，开启指针压缩 实例 8 字节，数组 12 字节。</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">-XX:+UseCompressedOops  <span class="hljs-regexp">//</span> 开启指针压缩<br>-XX:-UseCompressedOops  <span class="hljs-regexp">//</span> 关闭指针压缩<br></code></pre></td></tr></table></figure><ul><li>实例数据：这个很好理解就是类实例中的数据。</li><li>内存对齐：我们的 CPU 寄存器的位数都是 8 的倍数，所以为了方便 CPU 寄存器高效寻址，64 位 JVM 要求 Java 对象地址要按照 8 字节对齐。这个部分做数据填充保证 8 字节对齐。</li></ul><blockquote><p>⚠️这里有个小知识点，Java 实例被 GC 之后，对象的 Hash 码会变码？那栈中的引用地址会变化吗？我们都知道 Java 对象的 Hash 码和对象地址有关系。如果一个对象被 GC 过后还存活的话，如果在 young 区，那地址大概率会发生变化，那Hash 码是不是也不一样呢？我们通过实验可以很容易验证这个问题，Hash 码不会发生变化，但是地址会发生变化，这是怎么做到的？来，抬头往上看，对象头中是不是有个哈希码信息。在第一次调用对象 hashCode 方法，就会把 hashCode 存在这里，后面的 hashCode 直接来这里取就好了。 </p></blockquote><p>整体的大致的对象存储布局就是酱婶儿的。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210513235300.png"></p><h3 id="JOL-实践"><a href="#JOL-实践" class="headerlink" title="JOL 实践"></a>JOL 实践</h3><p>什么是 JOL ？JOL （Java object layout）Java 对象内存布局，是 openjdk 给我们提供了一个工具包，可以用来获取对象的信息和虚拟机的信息 。我们来引入下 jol-core 的依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.openjdk.jol<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jol-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.15<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>主要会用到的方法：</p><ul><li><code>ClassLayout.parseInstance(object).toPrintable()</code>：查看对象内部信息。</li><li><code>GraphLayout.parseInstance(object).toPrintable()</code>：查看对象外部信息，包括引用的对象。</li><li><code>GraphLayout.parseInstance(object).totalSize()</code>：查看对象总大小。</li></ul><p>我们创建一个普通对象，空对象开开胃。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">A</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>这个对象一个成员变量都没有，那么一个 A 实例占用几个字节呢？我们没有开启指针压缩，markWord 8 个字节， class pointer 4 个字节，8 + 4 = 12 然后 8 个字节对齐 也就是 16 个字节。我们使用 JOL 打印出来看看。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> static <span class="hljs-built_in">void</span> main(String[] args) &#123;<br>    A a = new A();<br>    System.<span class="hljs-keyword">out</span>.println(ClassLayout.parseInstance(a).toPrintable());<br>&#125;<br><br><span class="hljs-comment">// console～</span><br>io.daiwei.jvm.jol.A object <span class="hljs-built_in">int</span>ernals:<br>OFF  SZ   TYPE DESCRIPTION               VALUE<br>  <span class="hljs-number">0</span>   <span class="hljs-number">8</span>        (object header: mark)     <span class="hljs-number">0x0000000000000001</span> (non-biasable; age: <span class="hljs-number">0</span>)<br>  <span class="hljs-number">8</span>   <span class="hljs-number">4</span>        (object header: <span class="hljs-keyword">class</span>)    <span class="hljs-symbol">0xf800c182</span><br> <span class="hljs-symbol">12</span>   <span class="hljs-symbol">4</span>        (<span class="hljs-symbol">object</span> <span class="hljs-symbol">alignment</span> <span class="hljs-symbol">gap</span>)    <br><span class="hljs-symbol">Instance</span> <span class="hljs-symbol">size: <span class="hljs-symbol">16</span></span> <span class="hljs-symbol">bytes</span><br><span class="hljs-symbol">Space</span> <span class="hljs-symbol">losses: <span class="hljs-symbol">0</span></span> <span class="hljs-symbol">bytes</span> <span class="hljs-symbol">internal</span> + <span class="hljs-symbol">4</span> <span class="hljs-symbol">bytes</span> <span class="hljs-symbol">external</span> = <span class="hljs-symbol">4</span> <span class="hljs-symbol">bytes</span> <span class="hljs-symbol">total</span><br></code></pre></td></tr></table></figure><p> 那么一个数组对象呢？我们前面提到数组对象实例对象头中会多一个<code>length field</code>用来存数组的长度。按照我们的计算逻辑，我们没开启指针压缩，markWord 占用 8 个字节，classPonter 占 4 个字节，因为数数组对象多一个 lengthField 4 个字节。也就是 4 + 4 + 8 = 16，刚好对齐 16 个字节。真的是这样吗？没落下什么吗？</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tap">public static void main(String[] args) &#123;<br>    int[] nums = new int[10];<br>    System.out.println(ClassLayout.parseInstance(nums).toPrintable());<br>&#125;<br><br>// console～<br>[I object internals:<br>OFF  SZ   TYPE DESCRIPTION               VALUE<br> <span class="hljs-number"> 0 </span> <span class="hljs-number"> 8 </span>       (object header: mark)     0x0000000000000001 (non-biasable; age: 0)<br> <span class="hljs-number"> 8 </span> <span class="hljs-number"> 4 </span>       (object header: class)    0xf800016d<br><span class="hljs-number"> 12 </span> <span class="hljs-number"> 4 </span>       (array length)            10<br><span class="hljs-number"> 12 </span> <span class="hljs-number"> 4 </span>       (alignment/padding gap)   <br><span class="hljs-number"> 16 </span><span class="hljs-number"> 40 </span>   int [I.&lt;elements&gt;             N/A<br>Instance size:<span class="hljs-number"> 56 </span>bytes<br>Space losses:<span class="hljs-number"> 4 </span>bytes internal +<span class="hljs-number"> 0 </span>bytes external =<span class="hljs-number"> 4 </span>bytes total<br></code></pre></td></tr></table></figure><p> 实际的实例的大小是56，仔细看，打印结果的第13行，多了 40 个字节，这是啥呢？没错是我们长度为10的数组内容，一个 int 类型四个字节就是 40 个字节。所以最终的大小就是 16 + 40 = 56 刚好也不用对齐～。 </p><p>再来看一个例子，一个稍微正常点的对象 B。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">B</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String hello;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> a;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span>ean b;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>B 对象包含，一个 String，一个int 和一个 boolean，我们根据之前的经验可以推出 没有开启指针压缩，对象头12个字节，String 是一个引用4个字节，int  4 个字节，boolean 一个字节，所以 12 + 4 + 4 + 1 =  21 个字节，然后内存对齐，实例大小 24 个字节。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>    B b = <span class="hljs-keyword">new</span> <span class="hljs-constructor">B()</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ClassLayout</span>.</span></span>parse<span class="hljs-constructor">Instance(<span class="hljs-params">b</span>)</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">Printable()</span>);<br>&#125;<br><br><span class="hljs-comment">// console～</span><br>io.daiwei.jvm.jol.B <span class="hljs-keyword">object</span> internals:<br>OFF  SZ               TYPE DESCRIPTION               VALUE<br>  <span class="hljs-number">0</span>   <span class="hljs-number">8</span>                    (<span class="hljs-keyword">object</span> header: mark)     <span class="hljs-number">0x0000000000000001</span> (non-biasable; age: <span class="hljs-number">0</span>)<br>  <span class="hljs-number">8</span>   <span class="hljs-number">4</span>                    (<span class="hljs-keyword">object</span> header: <span class="hljs-keyword">class</span>)    <span class="hljs-number">0xf800c143</span><br> <span class="hljs-number">12</span>   <span class="hljs-number">4</span>                <span class="hljs-built_in">int</span> <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>a                       <span class="hljs-number">0</span><br> <span class="hljs-number">16</span>   <span class="hljs-number">1</span>            boolean <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>b                       <span class="hljs-literal">false</span><br> <span class="hljs-number">17</span>   <span class="hljs-number">3</span>                    (alignment/padding gap)   <br> <span class="hljs-number">20</span>   <span class="hljs-number">4</span>   java.lang.String <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>hello                   null<br>Instance size: <span class="hljs-number">24</span> <span class="hljs-built_in">bytes</span><br>Space losses: <span class="hljs-number">3</span> <span class="hljs-built_in">bytes</span> internal + <span class="hljs-number">0</span> <span class="hljs-built_in">bytes</span> <span class="hljs-keyword">external</span> = <span class="hljs-number">3</span> <span class="hljs-built_in">bytes</span> total<br></code></pre></td></tr></table></figure><p>没毛病，最终实例大小 24 个字节。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一小节呢，我们从类的生命周期入手深入了解了类的加载过程和实例在内存中的对象布局，类的生命周期分为 加载，验证，准备，解析，初始化，使用、卸载。过程可以类比做菜的过程。其中类并不是在 JVM 启动时全部加载而是按需加载的。接下来我们介绍了类加载器，有启动类加载器，拓展类加载器和应用类加载器。他们采用双亲委派的方式，所谓的双亲委派就是先由父类加载，父类如果加载在不了再由子类加载，这样可以保证每个类每次都由某个特定的类加载器加载。我们还可以自定义类加载实现加载逻辑的自定义化，这个自定义类加载器的父类是应用类加载器。聊完类的加载，我们探讨了实例的内存布局，一个实例分为对象头，实例数据和填充数据这三个部分，其中对象头又包括 markWord、klassPointer和数组对象特有的 lengthField，对象头的大小受是否开启指针压缩有关。最后我们使用 openJDK 提供的JOL工具验证了我们的理论对象布局理论。这是JVM基础正式篇的最后一小节，接下来我们会一起探讨 JVM 的内存，GC 和 高效编译的部分。接下来的 JVM 会更加精彩，我们一起来看看，有了这些东西 JVM 会玩出些啥不一样的。哈哈，晚安～</p><h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/142614439">JVM基础（三）一个对象的创建过程</a></li><li><a href="https://www.cnblogs.com/jajian/p/13681781.html">Java 对象的内存布局</a></li><li>Java类加载器：山不辞土，故能成其高 </li></ul>]]></content>
    
    
    <categories>
      
      <category>Java虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>Java知识结构梳理</tag>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 基础 — Java 方法调用、反射调用与异常</title>
    <link href="/2021/05/09/java-method-invoke/"/>
    <url>/2021/05/09/java-method-invoke/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前一篇中简单介绍了Java 字节码中有关方法调用的一些操作码，但是 java 方法的调用往深了讲又有很多的门道，简单的有方法的重写和重载，深入也有方法的动态绑定和静态绑定，那JVM是如果识别和选定方法的呢？还有有些时候我们并不能直接调用某个目标方法，而是要使用一些特别的手段去调用，也就是我们会经常用到的反射，反射不同于常规的方法调用，这货一上来就不走寻常路，一般方法调用都是先 new 一个对象，就像是朋友来家里做客从正门进来，反射是先通过 class 对象找到目标方法然后传入调用实例，这更像是翻墙进来。那这个翻墙进来的它背后的原理又是怎样的呢？假如这个世界是美好的，但一个方法的执行可能没那么顺利，万一发生了异常这个异常又是怎么捕获的呢？</p><h2 id="Java-方法调用原理"><a href="#Java-方法调用原理" class="headerlink" title="Java 方法调用原理"></a>Java 方法调用原理</h2><h3 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h3><p>在 Java 程序里如果一个类出现了多个名字相同且参数类型相同的方法，那么他们是无法通过编译的。在正常情况下，通常会出现方法名相同但是方法参数类型不相同。这种情况称之为<code>重载</code>。</p><p>重载的方法在编译过程中即可完成方法的识别。Java 编译器会根据方法名和传入的参数的<code>声明类型</code>选取重载方法。选取的过程分为三个阶段：</p><ol><li>在不考虑对基本类型自动装拆箱（auto-boxing， auto-unboxing），已经可变长参数的情况下选取重载方法。（<code>不考虑自动装拆箱，不考虑变长参数</code>）</li><li>如果在第 1 个阶段中没有找到适配的方法，那么在允许自动装拆箱，但是不允许可变长参数的情况下选取重载方法。（<code>考虑自动装拆箱，不考虑变长参数</code>）</li><li>如果在第 2 个阶段中没有找到适配方法，那么在允许自动装拆箱以及变长参数的情况下选取重载方法。（<code>考虑自动装拆箱，考虑变长参数</code>）</li></ol><p>如果 Java 编译器在同一阶段找到多个适配方法，它会在其中找到一个最为贴切的。而决定贴切程度的一个关键就是形式参数类型的继承关系。重载也适用子类从父类中继承来的方法，也就是说如果子类中定义了和父类非私有方法中方法名相同且方法的参数类型不同的方法，那么在子类中这两个方法也构成了重载。</p><p>Java 是面向对象的语言，其中有个重要的特性就是多态。而方法的重写就是多态的最重要的一种体现形式。通过对方法的重写，允许子类对于不同的动作有自己独特的行为。 在调用重写的方法的过程中，编译器会更具具体的类型调用目标实际的方法。</p><h3 id="JVM-的静态绑定和动态绑定"><a href="#JVM-的静态绑定和动态绑定" class="headerlink" title="JVM 的静态绑定和动态绑定"></a>JVM 的静态绑定和动态绑定</h3><p>前面说到 Java 编译器通过方法名和方法参数类型识别方法，JVM 是通过方法名和方法描述符去识别方法的，<code>方法描述符</code>包括<code>方法参数类型</code>和<code>返回值</code>，注意在JVM的方法描述符中是包括方法的返回值的。所以在一个类中如果出现多个方法名和方法描述符的JVM在类加载的验证阶段就会报错。</p><p>由于重载方法在编译期已经确定，所以我们可以认定，在 JVM 层面不存在重载这一概念。因为对于 JVM来说这就是两个方法。所以针对JVM来说在<code>编译期可以直接解析</code>识别的目标方法就是<code>静态绑定（static binding）</code>，而<code>动态绑定（dynamic binding）</code>指的是需要在<code>运行期间根据调用者的类型来识别目标方法</code>的情况。所以 Java 编译器会将所有对非私有的实例方法解析为需要动态绑定的类型。</p><p>在上一篇字节码中提到了五种关于方法调用操作码</p><ol><li>invokestatic：用于调用静态方法。</li><li>invokespecial：用于调用私有实例方法、构造器，以及使用 super 关键字调用父类的实例方法或构造器，和所实现接口的默认方法。</li><li>invokevirtual：用于调用非私有实例方法。</li><li>invokeinterface：用于调用接口方法（用接口的去调用）。</li><li>invokedynamic：用于调用动态方法。</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> TestMain &#123;<br><br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        HiClass hiClass = <span class="hljs-keyword">new</span> <span class="hljs-constructor">HiClass()</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(hiClass.hi<span class="hljs-constructor">You(<span class="hljs-string">&quot;daiwei&quot;</span>)</span>);<br>        GoodNight goodNight = (GoodNight) hiClass;<br>        goodNight.good<span class="hljs-constructor">Night(<span class="hljs-string">&quot;daiwei&quot;</span>)</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>stream(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;).reduce(<span class="hljs-number">0</span>, Integer::sum));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>生成的字节码如下（只截取方法部分）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">public</span> <span class="hljs-string">static</span> <span class="hljs-string">void</span> <span class="hljs-string">main(java.lang.String[]);</span><br>    <span class="hljs-attr">descriptor:</span> <span class="hljs-string">([Ljava/lang/String;)V</span><br>    <span class="hljs-attr">flags:</span> <span class="hljs-string">ACC_PUBLIC,</span> <span class="hljs-string">ACC_STATIC</span><br>    <span class="hljs-attr">Code:</span><br>      <span class="hljs-string">stack=5,</span> <span class="hljs-string">locals=3,</span> <span class="hljs-string">args_size=1</span><br>         <span class="hljs-attr">0:</span> <span class="hljs-string">new</span>           <span class="hljs-comment">#2                  // class io/daiwei/jvm/HiClass</span><br>         <span class="hljs-attr">3:</span> <span class="hljs-string">dup</span><br>         <span class="hljs-attr">4:</span> <span class="hljs-string">invokespecial</span> <span class="hljs-comment">#3                  // Method io/daiwei/jvm/HiClass.&quot;&lt;init&gt;&quot;:()V</span><br>         <span class="hljs-attr">7:</span> <span class="hljs-string">astore_1</span><br>         <span class="hljs-attr">8:</span> <span class="hljs-string">getstatic</span>     <span class="hljs-comment">#4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br>        <span class="hljs-attr">11:</span> <span class="hljs-string">aload_1</span><br>        <span class="hljs-attr">12:</span> <span class="hljs-string">ldc</span>           <span class="hljs-comment">#5                  // String daiwei</span><br>        <span class="hljs-attr">14:</span> <span class="hljs-string">invokevirtual</span> <span class="hljs-comment">#6                  // Method io/daiwei/jvm/HiClass.hiYou:(Ljava/lang/String;)Ljava/lang/String;</span><br>        <span class="hljs-attr">17:</span> <span class="hljs-string">invokevirtual</span> <span class="hljs-comment">#7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>        <span class="hljs-attr">20:</span> <span class="hljs-string">aload_1</span><br>        <span class="hljs-attr">21:</span> <span class="hljs-string">astore_2</span><br>        <span class="hljs-attr">22:</span> <span class="hljs-string">aload_2</span><br>        <span class="hljs-attr">23:</span> <span class="hljs-string">ldc</span>           <span class="hljs-comment">#5                  // String daiwei</span><br>        <span class="hljs-attr">25:</span> <span class="hljs-string">invokeinterface</span> <span class="hljs-comment">#8,  2            // InterfaceMethod io/daiwei/jvm/GoodNight.goodNight:(Ljava/lang/String;)V</span><br>        <span class="hljs-attr">30:</span> <span class="hljs-string">getstatic</span>     <span class="hljs-comment">#4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br>        <span class="hljs-attr">33:</span> <span class="hljs-string">iconst_3</span><br>        <span class="hljs-attr">34:</span> <span class="hljs-string">newarray</span>       <span class="hljs-string">int</span><br>        <span class="hljs-attr">36:</span> <span class="hljs-string">dup</span><br>        <span class="hljs-attr">37:</span> <span class="hljs-string">iconst_0</span><br>        <span class="hljs-attr">38:</span> <span class="hljs-string">iconst_1</span><br>        <span class="hljs-attr">39:</span> <span class="hljs-string">iastore</span><br>        <span class="hljs-attr">40:</span> <span class="hljs-string">dup</span><br>        <span class="hljs-attr">41:</span> <span class="hljs-string">iconst_1</span><br>        <span class="hljs-attr">42:</span> <span class="hljs-string">iconst_2</span><br>        <span class="hljs-attr">43:</span> <span class="hljs-string">iastore</span><br>        <span class="hljs-attr">44:</span> <span class="hljs-string">dup</span><br>        <span class="hljs-attr">45:</span> <span class="hljs-string">iconst_2</span><br>        <span class="hljs-attr">46:</span> <span class="hljs-string">iconst_3</span><br>        <span class="hljs-attr">47:</span> <span class="hljs-string">iastore</span><br>        <span class="hljs-attr">48:</span> <span class="hljs-string">invokestatic</span>  <span class="hljs-comment">#9                  // Method java/util/Arrays.stream:([I)Ljava/util/stream/IntStream;</span><br>        <span class="hljs-attr">51:</span> <span class="hljs-string">iconst_0</span><br>        <span class="hljs-attr">52:</span> <span class="hljs-string">invokedynamic</span> <span class="hljs-comment">#10,  0             // InvokeDynamic #0:applyAsInt:()Ljava/util/function/IntBinaryOperator;</span><br>        <span class="hljs-attr">57:</span> <span class="hljs-string">invokeinterface</span> <span class="hljs-comment">#11,  3           // InterfaceMethod java/util/stream/IntStream.reduce:(ILjava/util/function/IntBinaryOperator;)I</span><br>        <span class="hljs-attr">62:</span> <span class="hljs-string">invokevirtual</span> <span class="hljs-comment">#12                 // Method java/io/PrintStream.println:(I)V</span><br>        <span class="hljs-attr">65:</span> <span class="hljs-string">return</span><br></code></pre></td></tr></table></figure><p>结合上一篇字节码的知识，这里的字节码不难分析，<code>4: invokespecial</code> 这里是调用构造函数，<code>14: invokevirtual #6 // Method io/daiwei/jvm/HiClass.hiYou</code> 这里是使用 <code>invokevirutal</code> 调用 hiYou 方法。<code>invokeinterface #8,  2 // InterfaceMethod io/daiwei/jvm/GoodNight.goodNight:(Ljava/lang/String;)V</code> 使用 <code>invokeinterface</code> 调用接口方法。<code>52: invokedynamic #10,  0</code> 这里则是 lambda 表达式的 <code>invokedynamic</code>。</p><p>通常情况下 <code>invokesepcial</code> 和 <code>invokespeical</code>，JVM 能直接识别出目标方法（静态绑定），而 <code>invokevirutal</code> 和 <code>invokeinterface</code> 则需要在运行时，动态判定目标类型从而确定目标方法（动态绑定）。对于 final 方法可以直接确定目标方法。</p><h3 id="调用指令的符号引用"><a href="#调用指令的符号引用" class="headerlink" title="调用指令的符号引用"></a>调用指令的符号引用</h3><p>在编译过程中，我们并不知道调用目标方法的内存地址。编译器会暂时用方法的符号引用代替目标方法，也就是我们方法方法名和方法描述符，也就是这个 <code>io/daiwei/jvm/HiClass.hiYou:(Ljava/lang/String;)Ljava/lang/String;</code></p><ul><li><code>io/daiwei/jvm/HiClass.hiYou</code> 目标类名方法名。</li><li><code>(Ljava/lang/String;)</code> 参数类型，L代表引用类型 ，这里是引用类型 String。</li><li><code>Ljava/lang/String;</code> 返回类型，引用类型 String。</li></ul><p>这些方法描述符作为常量信息存在类的<code>常量池</code>中。在使用这些符号引用字节码之前，JVM 会在类加载阶段把它替换为真正的引用。</p><p>对于<code>非接口</code>符号引用，假定该符号引用指向类C，则 Java 虚拟机会按照如下步骤查找。（C -&gt; C 父类 -&gt; C 间接实现接口）</p><ol><li>在 C 中查找符合名字及描述符的方法。</li><li>如果没找到，在 C 的父亲类中继续搜索，直至 Object 类。</li><li>如果没找到，在 C 直接或者间接实现的接口中搜索。这一步搜索的方法必须是 非私有，非静态的。</li></ol><p>调用<code>接口</code>符号引用，假定该符号引用指向 I ，则 Java 虚拟机会按照如下步骤进行查找。</p><ol><li>在 I 中查找符合名字及描述符的方法。（I -&gt; Object -&gt;I 超类接口）</li><li>如果没有找到，在 Object 类中的公有实例方法中搜索。</li><li>如果没有找到，则在 I 的超接口中搜索。这一步的搜索结果的要求与非接口符号引用步骤 3 的要求一致。</li></ol><p>经过上述的解析之后，静态方法会被解析成一个方法的指针，而需要动态绑定的方法则会被解析成一个方法表的索引。</p><h3 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h3><p>Java 虚拟机通过一种用空间换时间的方法来实现动态绑定。在类加载的准备阶段，不仅会为静态字段分配内存，还会生成类的方法表。方法表的是一个本质上是一个数组。这个数据就是动态绑定实现的关键，调用 <code>invokevirutal</code> 有 <code>虚方法表（virtual method table，vtable）</code></p><p>调用 <code>invokeinterface</code> 有<code>接口方法表（interface method table， itable）</code>，itable 会稍微复杂些，但是原理是一致的。在这个数组中每个元素都指向一个当前类或者父类中的一个非私有的实例方法。这些方法可以是具体的可执行的方法，也可以是抽象的没有方法体的抽象方法。方法表满足下面两个关键的特质：</p><ul><li>子类方法表中包含所有的父类方法表的中的所有方法。</li><li>子类方法表中的索引值与他重写父类方法在方法表中的索引值相同。</li></ul><table><thead><tr><th>Person方法表</th><th>walk()</th><th>share()</th><th>talk()</th><th></th></tr></thead><tbody><tr><td>Chinese方法表</td><td>walk()</td><td>share()</td><td>talk()</td><td>chineseDo()</td></tr></tbody></table><p>在上面这个表中 Chinese 类是 Person 的子类，在类加载阶段生成方法表，静态方法解析方法引用的时候将具体的方法替换具体方法的指针，对于动态绑定的方法而言，替换的引用则是方法表中的索引值（实际上并不只是索引值）。这样的话，在方法运行阶段只要拿到运行时的对象，根据它的方法表拿到具体的要执行的目标方法，这个过程便是动态绑定。</p><p>有了额外的操作，就会有额外的性能消耗，但是在类加载阶段生成方法表，解析方法替换成索引，执行阶段查询目标方法，虽然这个过程的很简单，是否可以看作对JVM 没有太大的影响呢？显然是不能的。所以针对这个情况编译器有两个优化手段内联缓存（inline cache）和方法内联（method inline）。</p><h3 id="内联缓存和方法内联"><a href="#内联缓存和方法内联" class="headerlink" title="内联缓存和方法内联"></a>内联缓存和方法内联</h3><p>内联缓存是一种加快绑定的方法，它能够缓存动态调用的类型以及该类型对应的目标方法，如果在后面的调用中击中已缓存类型，会直接从缓存中获取目标方法执行。如果没有命中调用类型，则退化为方法表动态绑定。这是一个典型的用空间换换时间的操作。</p><p>还有一种优化手段那便是方法内联，简单且高频的方法例如一些 get/set 方法，Java 的即时编译器会直接进行方法内联也就是直接把调用的方法和外面的调用优化成一个完整的方法机器码存储起来。用这种方法来提高执行效率。这里要注意方法内联是真内联，而内联缓存附带内联二字，但是它并没有内联目标方法。这里需要明确的是，任何方法调用除非被内联，否则都会有固定开销。这些开销来源于保存程序在该方法中的执行位置，以及新建、压入和弹出新方法所使用的栈帧，也就是内联缓存是假内联。</p><h2 id="Java-反射调用机制"><a href="#Java-反射调用机制" class="headerlink" title="Java 反射调用机制"></a>Java 反射调用机制</h2><p>Java 的反射机制可以让代码在运行阶段自省，可以让代码知道运行阶段的某个对象的某些字段和方法，并进行调用，那 Java 的方法反射调用是如何实现的呢？</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@CallerSensitive<br>public Object invoke(Object obj, Object... args)<br>    throws IllegalAccessException, IllegalArgumentException,<br>       InvocationTargetException<br>&#123;<br>    <span class="hljs-keyword">if</span> (!override) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Reflection</span>.</span></span>quick<span class="hljs-constructor">CheckMemberAccess(<span class="hljs-params">clazz</span>, <span class="hljs-params">modifiers</span>)</span>) &#123;<br>            Class&lt;?&gt; caller = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Reflection</span>.</span></span>get<span class="hljs-constructor">CallerClass()</span>;<br>            check<span class="hljs-constructor">Access(<span class="hljs-params">caller</span>, <span class="hljs-params">clazz</span>, <span class="hljs-params">obj</span>, <span class="hljs-params">modifiers</span>)</span>;<br>        &#125;<br>    &#125;<br>    MethodAccessor ma = methodAccessor;             <span class="hljs-comment">// read volatile</span><br>    <span class="hljs-keyword">if</span> (ma<span class="hljs-operator"> == </span>null) &#123;<br>        ma = acquire<span class="hljs-constructor">MethodAccessor()</span>;<br>    &#125;<br>    return ma.invoke(obj, args);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到 invoke 方法的源码，method.invoke()，最终是调用 <code>MethodAccessor.invoke()</code>，而MethodAccessor 又有两个实现类 <code>DeleagetingMethodAccessor</code> 和 <code>NativeMethodAccessor</code> ，一个是使用了委派模式实现调用，另一个则是通过 Native 方法实现反射调用。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210509204937.png"></p><p>在执行反射的时候会优先使用<code>NativeMethodAccessor</code> 直接调用 Native 方法，但是调用 Native 方法要切换成 C++ 执行方法，这个成本是大于一般的方法调用。那我们生成代理每次反射调用我们就去调用我们的代理对象，这样是不是就可以更快了呢？这样只是方法调用变快了，但是生成代理对象是很慢的，那生成代理对象的时间成本又怎么计算呢？所以 JVM 采用了折中的办法，<code>设置阈值</code>，当调用次数超过<code>默认的15</code>次JVM 为其生成代理对象，由 Native 方法调用切换为 Delegate 方法调用，来提高整体的执行性能。以为一切都很美好了，突然我们的代码发生了异常，那一起看看异常是怎么JVM异常是怎么处理吧。</p><h2 id="Java-异常处理机制"><a href="#Java-异常处理机制" class="headerlink" title="Java 异常处理机制"></a>Java 异常处理机制</h2><h3 id="Java-异常"><a href="#Java-异常" class="headerlink" title="Java 异常"></a>Java 异常</h3><p>异常处理中主要组成要素：抛出异常和捕获异常。由于 Java 中没有 goto，所以这两大要素配置共同实现程序流程的非正常转移。抛出异常可以分为两种，一种是<code>显式抛出</code>另外一种是另外一种是<code>隐式抛出</code>。显式抛出指的是我们在程序中使用 new threw 的方式抛出异常，而隐式抛出则是 Java 虚拟机执行到异常情况，无法继续抛出的异常。例如数组越界，除0等。异常操作通常分成下面三块：</p><ul><li>try 代码块：用来标记需要异常监测的代码。</li><li>catch 代码块：在异常发生后执行的后续逻辑块。在 Java 中一个 try 块后面可以跟多个 catch 代码块，用来捕捉不同的异常，发生异常后 JVM 会从上到下依次匹配异常处理代码，因此前面的 catch 块不能覆盖后面的 catch 块。</li><li>finally 代码块：在 try 和 catch 后面的代码块，用来声明一段必会执行的逻辑，它的设计初衷是用来避免因为异常跳过的没有执行的一些清理逻辑。</li></ul><p>所以正常流程下来，如果 try 中的异常没有被捕获，会抛出异常并执行 finally 。如果正常流程下来，try 中没有发生异常，而是 finally 代码中出现了异常，那 finally 只能中断并抛出异常。</p><h3 id="Java-虚拟机是如何处理异常的？"><a href="#Java-虚拟机是如何处理异常的？" class="headerlink" title="Java 虚拟机是如何处理异常的？"></a>Java 虚拟机是如何处理异常的？</h3><p>在编译生成的字节码中，每个方法都会带有一个异常表，异常表中的每一条记录代表一个异常处理器，并且由 from 指针、to 指针、target 执政以及所捕获的类型。指针的值是<code>字节码索引</code>（bytecode index，bci），已经定位字节码。其中 from 指针和 to 指针标志了该异常处理器的监控范围，例如 try 代码所覆盖的范围。target 指针则指向异常处理器的起始位置，例如 catch 代码块的起始位置。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RuntimeException</span>(<span class="hljs-string">&quot;test&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-built_in">Exception</span> e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;finally!&quot;</span>);<br>    &#125;<br>&#125;<br><br>java code～～～<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-keyword">void</span> main(java.lang.<span class="hljs-keyword">String</span>[]);<br>    descriptor: ([Ljava/lang/<span class="hljs-keyword">String</span>;)V<br>    flags: ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      stack=<span class="hljs-number">3</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: <span class="hljs-keyword">new</span>           <span class="hljs-comment">#2                  // class java/lang/RuntimeException</span><br>         <span class="hljs-number">3</span>: dup<br>         <span class="hljs-number">4</span>: ldc           <span class="hljs-comment">#3                  // String test</span><br>         <span class="hljs-number">6</span>: invokespecial <span class="hljs-comment">#4                  // Method java/lang/RuntimeException.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br>         <span class="hljs-number">9</span>: athrow<br>        <span class="hljs-number">10</span>: astore_1<br>        <span class="hljs-number">11</span>: aload_1<br>        <span class="hljs-number">12</span>: invokevirtual <span class="hljs-comment">#6                  // Method java/lang/Exception.printStackTrace:()V</span><br>        <span class="hljs-number">15</span>: getstatic     <span class="hljs-comment">#7                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br>        <span class="hljs-number">18</span>: ldc           <span class="hljs-comment">#8                  // String finally!</span><br>        <span class="hljs-number">20</span>: invokevirtual <span class="hljs-comment">#9                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>        <span class="hljs-number">23</span>: <span class="hljs-keyword">goto</span>          <span class="hljs-number">37</span><br>        <span class="hljs-number">26</span>: astore_2<br>        <span class="hljs-number">27</span>: getstatic     <span class="hljs-comment">#7                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br>        <span class="hljs-number">30</span>: ldc           <span class="hljs-comment">#8                  // String finally!</span><br>        <span class="hljs-number">32</span>: invokevirtual <span class="hljs-comment">#9                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>        <span class="hljs-number">35</span>: aload_2<br>        <span class="hljs-number">36</span>: athrow<br>        <span class="hljs-number">37</span>: <span class="hljs-keyword">return</span><br>      <span class="hljs-built_in">Exception</span> table:<br>         <span class="hljs-keyword">from</span>    to  target type<br>             <span class="hljs-number">0</span>    <span class="hljs-number">10</span>    <span class="hljs-number">10</span>   <span class="hljs-class"><span class="hljs-keyword">Class</span> <span class="hljs-title">java</span>/<span class="hljs-title">lang</span>/<span class="hljs-title">Exception</span></span><br><span class="hljs-class">             0    15    26   <span class="hljs-title">any</span></span><br></code></pre></td></tr></table></figure><p>上面的<code>Exception table</code>就是异常表，如果发生了异常会从异常表中招当前位置是在那个异常的返回，如果匹配到多个则从上到下一个个匹配，并跳转到对应的 target 的位置往下执行，前面提到了 target 的位置是 catch 块（异常处理器）开始的位置。在这里可以看到一个<code>0 15 26 any</code> 的异常记录。看到这个我们可能会疑惑，方法中明明只有一个try catch 块，为什么异常表中会有两条记录，而且最后一个异常类型是 any。其实这里的记录的是 finally块，从target 字节码对效应的代表执行的开始位置不难发现这是 finlly 块的位置。</p><p>从上面的字节码还能看到一个细节，就是 finally 块的代码重复了两次。finally 代码块编译比较复杂，当前版本的做法就是在分别在 try 和 catch 的代码出口添加一段 finally 的内容。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210509205200.png"></p><p>那如果在 catch 代码块中还是出现了异常的场景，异常发生的行数还是在 <code>0 15 26 any</code> 的异常记录范围，同样会匹配到 any 也就是 finally 的代码块，这样就保证了不管在什么场景发生了异常都能执行 finally 的内容了，但是如果 finally 里面发生了异常呢？那就没有办法了。finally 会中止，并抛出异常。从字节码分析的角度也符合我们前面的结论。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>接着上一篇的 Java 字节码技术，这一小节我们通过运用字节码技术，分析方法的执行过程，以及方法的静态绑定和动态绑定。以及从算法层面探索了动态绑定的实现原理也就是方法表，以及方法表的优化方案内联缓存。当然除了正常的调用方法，我们还是使用反射的方式去进行方法调用。这一小节还通过源码分析的方式深入了反射的实现细节。最后我们一起看了异常这个让程序员喜忧参半的机制，通过创建异常表来对异常的执行路径进行索引，来保证程序的执行流程。我发现在方法这块JVM 很喜欢用”表”去解决一些问题, 方法表，异常表…</p><p>昨天和一个朋友聊天，聊到所有不了解的东西都会自带一层神秘感，但是我们真正去了解它之后会发现其实也就那样，都是人能想出来的点子。真正要做的是积累，掌握向上的办法，这样我们才能见招拆招并创造属于我们的未来。</p><h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><ul><li>极客时间专栏《深入拆解Java虚拟机》JVM是如何执行方法调用的？（上）</li><li>极客时间专栏《深入拆解Java虚拟机》JVM是如何执行方法调用的？（下）</li><li>极客时间专栏《深入拆解Java虚拟机》JVM是如何实现反射的？</li><li>极客时间专栏《深入拆解Java虚拟机》JVM是如何处理异常的？</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>Java知识结构梳理</tag>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 基础 — Java 字节码</title>
    <link href="/2021/05/07/java-bytecode/"/>
    <url>/2021/05/07/java-bytecode/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们通常表述的 JVM 通常有三种意思，JVM 是 Java virtual machine 即 java 虚拟机的缩写，也就是我们通常所指的 JVM。JVM还是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。因此 JVM 也是图灵完备的。当然 JVM 还可以表示一个虚拟机的实例。Java 一个非常重要的特性就是和平台无关，而 JVM 是实现这一点的关键。JVM 底层使用 C 进行编写，只要平台能执行 C 语言，这也就能启动 JVM 运行 Java 程序。JVM 通过编译 Java 语言生成字节码文件，字节码文件在通过 JVM 进行解释执行。因此只要运行在不同的平台上的JVM 能拿到字节码文件，就能解释执行出相同的结果。这就是 Java 可以 “一次编译，到处执行” 的原因。 </p><p>当然并不是Java 语言是跨平台的语言，拿 C++ 举个例子，C++ 也是一门跨平台的语言，但是和 Java 语言不同的是，C++ 需要到不同的平台生成不同的文件，然后进行执行，也就是源码跨平台，而 Java 是二进制跨平台。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210507003029.png"></p><h2 id="Java-字节码技术"><a href="#Java-字节码技术" class="headerlink" title="Java 字节码技术"></a>Java 字节码技术</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Java 代码通过编译生成 Java 字节码即 .class 文件，不同的 JVM 通过执行 .class 文件实现跨平台。Java bytecode 由但字节 （byte）的指令组成，理论上最多支持 256 个操作码（opencode）。实际上 Java 只用了 200 左右的操作码，还有一些操作码则保留给调试操作。操作码， 下面称为 指令 , 主要由 类型前缀 和 操作名称 两部分组成。 </p><blockquote><p>例如，’ i ‘ 前缀代表 ‘ integer ’，所以，’ iadd ‘ 很容易理解, 表示对整数执行加法运算。</p></blockquote><p>根据指令性质，主要分为 4 个大类：</p><ol><li>栈操作指令， 包括与局部变量交互的指令。</li><li>程序流程控制指令。</li><li>对象操作指令，包括方法调用指令。</li><li>算术运算以及类型转换指令。</li></ol><h3 id="获取字节码"><a href="#获取字节码" class="headerlink" title="获取字节码"></a>获取字节码</h3><p>可以使用 javap 命令来获取 class 文件中的字节码， javap 是 jdk 中内置的用于反编译字节码的工具</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloByteCode</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        HelloByteCode obj = <span class="hljs-keyword">new</span> HelloByteCode();<br>        System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>现使用 javac 命令编译出 .class，在使用 <code>javap -c</code> 命令编译得到字节码文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">daiwei@daiweideMacBook-Pro <span class="hljs-built_in">test</span> % javap -c HelloByteCode.class<br>Compiled from <span class="hljs-string">&quot;HelloByteCode.java&quot;</span><br>public class HelloByteCode &#123;<br>  public HelloByteCode();<br>    Code:<br>       0: aload_0<br>       1: invokespecial <span class="hljs-comment">#1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>       4: <span class="hljs-built_in">return</span><br><br>  public static void main(java.lang.String[]);<br>    Code:<br>       0: new           <span class="hljs-comment">#2                  // class HelloByteCode</span><br>       3: dup<br>       4: invokespecial <span class="hljs-comment">#3                  // Method &quot;&lt;init&gt;&quot;:()V</span><br>       7: astore_1<br>       8: getstatic     <span class="hljs-comment">#4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br>      11: ldc           <span class="hljs-comment">#5                  // String hello</span><br>      13: invokevirtual <span class="hljs-comment">#6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>      16: <span class="hljs-built_in">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上面拉出 java 的字节码清单之后，下面对其进行简单的解读</p><h3 id="解析字节码清单"><a href="#解析字节码清单" class="headerlink" title="解析字节码清单"></a>解析字节码清单</h3><p>在上面的输出信息中，第二行也就是打印出来的字节码的第一行<code>Compiled from &quot;HelloByteCode.java&quot;</code>表示我们是从 HelloByteCode这个类反编译而来的字节码文件。4～8 行是一个构造函数，总所周知，如果我们在编写代码时不编写构造函数，就会生成一个默认的构造方法，这个就是默认的构造方法。而这个构造方法里也只有一条指令就是 <code>invokespecial</code> 这个是调用父类Object 对象的构造方法即 <code>super()</code> 方法。</p><p>如果想要看到更多的信息则需要使用<code>javap -c -verbose</code> 命令输出更多信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs bash">daiwei@daiweideMacBook-Pro <span class="hljs-built_in">test</span> % javap -c -verbose HelloByteCode.class<br>Classfile /Users/daiwei/study/java-course/JVM/<span class="hljs-built_in">test</span>/HelloByteCode.class<br>  Last modified 2021-1-7; size 442 bytes<br>  MD5 checksum 8e2a795fb147ef48ba63f55886005f32<br>  Compiled from <span class="hljs-string">&quot;HelloByteCode.java&quot;</span><br>public class HelloByteCode<br>  minor version: 0<br>  major version: 52<br>  flags: ACC_PUBLIC, ACC_SUPER<br>Constant pool:<br>   <span class="hljs-comment">#1 = Methodref          #7.#16         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>   <span class="hljs-comment">#2 = Class              #17            // HelloByteCode</span><br>   <span class="hljs-comment">#3 = Methodref          #2.#16         // HelloByteCode.&quot;&lt;init&gt;&quot;:()V</span><br>   <span class="hljs-comment">#4 = Fieldref           #18.#19        // java/lang/System.out:Ljava/io/PrintStream;</span><br>   <span class="hljs-comment">#5 = String             #20            // hello</span><br>   <span class="hljs-comment">#6 = Methodref          #21.#22        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>   <span class="hljs-comment">#7 = Class              #23            // java/lang/Object</span><br>   <span class="hljs-comment">#8 = Utf8               &lt;init&gt;</span><br>   <span class="hljs-comment">#9 = Utf8               ()V</span><br>  <span class="hljs-comment">#10 = Utf8               Code</span><br>  <span class="hljs-comment">#11 = Utf8               LineNumberTable</span><br>  <span class="hljs-comment">#12 = Utf8               main</span><br>  <span class="hljs-comment">#13 = Utf8               ([Ljava/lang/String;)V</span><br>  <span class="hljs-comment">#14 = Utf8               SourceFile</span><br>  <span class="hljs-comment">#15 = Utf8               HelloByteCode.java</span><br>  <span class="hljs-comment">#16 = NameAndType        #8:#9          // &quot;&lt;init&gt;&quot;:()V</span><br>  <span class="hljs-comment">#17 = Utf8               HelloByteCode</span><br>  <span class="hljs-comment">#18 = Class              #24            // java/lang/System</span><br>  <span class="hljs-comment">#19 = NameAndType        #25:#26        // out:Ljava/io/PrintStream;</span><br>  <span class="hljs-comment">#20 = Utf8               hello</span><br>  <span class="hljs-comment">#21 = Class              #27            // java/io/PrintStream</span><br>  <span class="hljs-comment">#22 = NameAndType        #28:#29        // println:(Ljava/lang/String;)V</span><br>  <span class="hljs-comment">#23 = Utf8               java/lang/Object</span><br>  <span class="hljs-comment">#24 = Utf8               java/lang/System</span><br>  <span class="hljs-comment">#25 = Utf8               out</span><br>  <span class="hljs-comment">#26 = Utf8               Ljava/io/PrintStream;</span><br>  <span class="hljs-comment">#27 = Utf8               java/io/PrintStream</span><br>  <span class="hljs-comment">#28 = Utf8               println</span><br>  <span class="hljs-comment">#29 = Utf8               (Ljava/lang/String;)V</span><br>&#123;<br>  public HelloByteCode();<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=1, locals=1, args_size=1<br>         0: aload_0<br>         1: invokespecial <span class="hljs-comment">#1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>         4: <span class="hljs-built_in">return</span><br>      LineNumberTable:<br>        line 1: 0<br><br>  public static void main(java.lang.String[]);<br>    descriptor: ([Ljava/lang/String;)V<br>    flags: ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      stack=2, locals=2, args_size=1<br>         0: new           <span class="hljs-comment">#2                  // class HelloByteCode</span><br>         3: dup<br>         4: invokespecial <span class="hljs-comment">#3                  // Method &quot;&lt;init&gt;&quot;:()V</span><br>         7: astore_1<br>         8: getstatic     <span class="hljs-comment">#4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br>        11: ldc           <span class="hljs-comment">#5                  // String hello</span><br>        13: invokevirtual <span class="hljs-comment">#6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>        16: <span class="hljs-built_in">return</span><br>      LineNumberTable:<br>        line 3: 0<br>        line 4: 8<br>        line 5: 16<br>&#125;<br>SourceFile: <span class="hljs-string">&quot;HelloByteCode.java&quot;</span><br></code></pre></td></tr></table></figure><p>这次的输出比之前一次多了不少的信息，首先是 10～39 行的常量池信息。这里记录了代码中用到的常量。40～68行是之前代码部分的字节码，这一次多了一些如 <code>descriptor, flags</code> 的信息。descriptor 是方法的描述符，flags 则是方法的访问描述符，这是个 public static 方法。第45行的 <code>stack=1, locals=1, args_size=1</code> 表示方法栈的深度为1， 本地局部变量表大小为1 ，方法的入参为1。这里有个比较有意思的地方，就是无参构造的 args_size 不为0 而是 1 ，这是因为对于构造方法需要有一个引用地址，也就是 this 的引用地址，这个可以类比反射里面<code>Method#invoke(Object obj, Object... args);</code> 第一个参数是被调用对象一样。</p><h3 id="线程栈和字节码执行模型"><a href="#线程栈和字节码执行模型" class="headerlink" title="线程栈和字节码执行模型"></a>线程栈和字节码执行模型</h3><p>JVM 是基于栈的计算机模型，每一个线程都有自己的线程栈（JVM stack）和用于存储的<code>栈帧</code>（Frame），每调用一个方法JVM都会自动创建一个栈帧，栈帧中包括<code>操作数栈</code>，<code>局部变量数组</code>和一个 <code>class 引用</code>构成，class 引用指向当前方法在运行时常量池中对应的class。</p><p>​       <img src="https://gitee.com/realDaiwei/img/raw/master/20210507003351.png"></p><p><code>局部变量数组</code> 也成为 <code>局部方法表</code>（LocalVariableTable），其中包括方法的参数和局部变量。局部变量数组长度在编译时就已经确定。和局部变量和方法形参有关，但是具体长度还要看具体每个字段占用的长度。<code>操作数栈</code>（Operand Stack）是一个 LIFO 的结构栈，通过于压入弹出进行数据操作，其大小在编译时确定。</p><p>一些操作码/指令可以将值压入操作数栈，还有一些操作码/指令从操作数栈获取操作数，并进行计算，然后再压入操作数栈。操作数栈还用于接受调用其他方法的返回值。</p><h3 id="方法体中的字节码解析"><a href="#方法体中的字节码解析" class="headerlink" title="方法体中的字节码解析"></a>方法体中的字节码解析</h3><p>在前面的几个例子当中，字节码看起来问题都不大，但是看方法体中的字节码的编号有点看不懂，也就是下面的一些字节码</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">0:</span> <span class="hljs-string">new</span>           <span class="hljs-comment">#2                  // class HelloByteCode</span><br><span class="hljs-attr">3:</span> <span class="hljs-string">dup</span><br><span class="hljs-attr">4:</span> <span class="hljs-string">invokespecial</span> <span class="hljs-comment">#3                  // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="hljs-attr">7:</span> <span class="hljs-string">astore_1</span><br><span class="hljs-attr">8:</span> <span class="hljs-string">return</span><br></code></pre></td></tr></table></figure><p>前面的一排数字是<code>指令集数组中的索引</code> new 操作占用一个槽位，并且 new 指令需要消耗两个操作数，所以 dup 指令是从<code>3</code>开始的，<code>dup</code> 指令不需要操作数，所以只占一个槽位。位于<code>4</code>号槽位中的 <code>invokespecial</code> 指令同样需要消耗两个操作数，所以 astore_1 从7号槽位开始。<code>astore_1</code>意思是将栈顶元素存入局部变量表1号槽位，不需要操作数，所以 <code>return</code> 位于<code>8</code>号槽位。<img src="https://gitee.com/realDaiwei/img/raw/master/20210507003454.png"></p><p>通过操作码/指令对照表并换算十六进制（HEX）表示形式之后。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210507003612.png"></p><p>也就是我们通过十六进制打开.class 文件所能看到的数据片段了。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210507003708.png"></p><h3 id="对象初始化指令"><a href="#对象初始化指令" class="headerlink" title="对象初始化指令"></a>对象初始化指令</h3><p>new 是Java 的关键字，但是在字节码中，也有一个指令 new 但是整个 new 的逻辑，可以分为以下的字节码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">0: new           <span class="hljs-comment">#2                  // class HelloByteCode</span><br>3: dup<br>4: invokespecial <span class="hljs-comment">#3                  // Method &quot;&lt;init&gt;&quot;:()V</span><br></code></pre></td></tr></table></figure><p>new 指令和 invokespecial 指令在一起，那么这段字节码一定是在实例一个对象。那为什么实例一个对象不是一个指令而是三个指令呢？</p><ul><li><code>new</code> 指令只是创建对象，而并没有调用构造函数。</li><li><code>dup</code> 复制栈顶元素。这里为什么要复制栈顶元素呢？因为构造函数不会返回实例对象引用，所以没用dup指令，操作数栈是空的，初始化之后就会有问题。</li><li><code>invokespecial</code> 字面意思，调用特殊的方法，在这里就是调用构造函数。</li></ul><p>完成了上面的代码后一般会执行的指令会有下面几种：</p><ul><li><code>astore &#123;N&#125;</code> 或者 <code>astore_&#123;N&#125;</code> 给局部变量赋值，其中{N}代表局部变量表中的位置。</li><li><code>putfield</code>  将值赋给实例。</li><li><code>putstatic</code> 将实例赋给静态字段。</li></ul><p>这个时候如果没有那个 dup 的引用的话这里就没有就没法进行出栈赋值操作。</p><p>在调用构造函数之前，还会执行一个类似 <init> 的方法。但是 <clinit> 并不能被直接调用，而是由 <code>new</code>，<code>getstatic</code>，<code>putstatic</code> 或 <code>invokestatic</code> 触发。</p><p>也就是说，在实例化一个对象，访问静态字段或一些静态方法，就会触发这个类的静态初始化方法。</p><h3 id="栈内存操作指令"><a href="#栈内存操作指令" class="headerlink" title="栈内存操作指令"></a>栈内存操作指令</h3><p>有很多指令可以操作方法栈。压入栈数据和从数据栈弹出数据等一些基础的操作，有 <code>dup</code> 复制栈顶元素，和 <code>pop</code> 弹出栈顶元素的指令。还有一些复杂点的指令例如：</p><ul><li><code>swap</code> ：交换两个栈顶元素。</li><li><code>dup_x1</code>：复制栈顶的值, 并将复制的值插入到最上面2个值的下方。</li><li><code>dup2_x1</code>：制栈顶 1个64位/或2个32位的值, 并将复制的值按照原始顺序，插入原始值下面一个32位值的下方。 配合使用可用于交换两个64位数据的位置。</li></ul><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210507003819.png"></p><blockquote><p>数据类型分组（1代表32 位元素， 2代表64位元素）</p></blockquote><table><thead><tr><th>实际类型</th><th>JVM 计算类型</th><th>类型分组</th></tr></thead><tbody><tr><td>boolean</td><td>int</td><td>1</td></tr><tr><td>byte</td><td>int</td><td>1</td></tr><tr><td>char</td><td>int</td><td>1</td></tr><tr><td>short</td><td>int</td><td>1</td></tr><tr><td>int</td><td>int</td><td>1</td></tr><tr><td>float</td><td>float</td><td>1</td></tr><tr><td>refrence</td><td>refrence</td><td>1</td></tr><tr><td>retrunAddress</td><td>retrunAddress</td><td>1</td></tr><tr><td>long</td><td>long</td><td>2</td></tr><tr><td>double</td><td>double</td><td>2</td></tr></tbody></table><blockquote><p>⚠️ 理解这些字节码的诀窍在于</p><p>给局部变量赋值时，需要使用相应的指令来进行 <code>store</code> ，如 <code>astore_1</code>、 <code>store</code> 类的指令都会删除栈顶值。 相应的 load 指令则会将值从局部变量表压入操作数栈，但并不会删除局部变量中的值。</p></blockquote><h3 id="算术运算指令与类型转换指令"><a href="#算术运算指令与类型转换指令" class="headerlink" title="算术运算指令与类型转换指令"></a>算术运算指令与类型转换指令</h3><p>Java 字节码有很多的指令可以执行算术运算。对于所有数值类型（<code>int</code>, <code>long</code>, <code>double</code>, <code>float</code>）都有各自的加、减、乘、除、取反指令。当然boolean、byte、short、char 等都是当 int 类型处理。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210507003904.png"></p><p>在java 是一个强类型的语言，如果类型不匹配需要进行类型转换，如果<code>int</code>需要转换为 <code>double</code> 会调用 i2d 指令进行类型转换。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210507003936.png"></p><p>唯一一个不需要将数值load到操作数栈的指令是 <code>iinc</code>，他可以直接对 <code>LocalVariableTable</code> 中的数值进行运算。其他的操作均使用操作数栈进行运算。</p><blockquote><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-7.html">操作码对照表</a></p></blockquote><h3 id="方法调用指令"><a href="#方法调用指令" class="headerlink" title="方法调用指令"></a>方法调用指令</h3><p>在前面已经到了 <code>invokespceial</code> 调用构造方法，那调用其他不同类型的方法用什么指令呢？</p><ul><li><code>invokestatic</code> 调用静态方法，也是几个调用指令当中最快的。</li><li><code>invokespeical</code> 可以用来调用构造方法，同时这个指令也可以用来调用 <code>private</code> 方法 和可见的 <code>super</code> 中的方法。</li><li><code>invokevirtual</code> 可以调用目标对象的实例方法。</li><li><code>invokeinterface</code> 用于调用目标接口方法，可以在运行时搜索一个实现这个接口的对象，并找出合适的方法进行调用。</li><li><code>invokedynamic</code> jdk 1.7 新加入的一个虚拟机指令，前四条指令的分派逻辑在虚拟机内部是固定的，<code>invokedynamic</code> 它允许应用代码来确定具体执行的是那个方法，从而到达对动态语言的支持。Lambda 表达式基于 <code>invokedynamic</code> 实现。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个部分简单介绍了Java 字节码，从开篇介绍怎么拉取一个 Java 代码的字节码开始，逐步复习了jvm 方法栈的栈帧，也就是 字节码的执行环境，这个部分由一个操作数栈，一个本地局部变量表和一个class 引用构成。通过分析一些常见的字节码例如构造函数和一些简单的方法体，熟悉了解了一些基本的操作码，例如 dup、pop、istore、iload 等指令。其中理解的诀窍在于 给局部变量赋值时，需要使用相应的指令来进行 <code>store</code> ，如 <code>astore_1</code>、 <code>store</code> 类的指令都会删除栈顶值。 相应的 load 指令则会将值从局部变量表压入操作数栈，但并不会删除局部变量中的值。当然在这些基本的操作指令中还包括一些类型转换的指令和方法的调用的指令，方法调用到后面会有专门梳理。</p><h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><ul><li>Java 字节码技术：不积细流，无以成江河。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>Java知识结构梳理</tag>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcodes 习题汇总</title>
    <link href="/2021/03/28/leetcodes/"/>
    <url>/2021/03/28/leetcodes/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-习题汇总"><a href="#LeetCode-习题汇总" class="headerlink" title="LeetCode 习题汇总"></a>LeetCode 习题汇总</h2><h5 id="数组、链表"><a href="#数组、链表" class="headerlink" title="数组、链表"></a>数组、链表</h5><ol><li><a href="https://leetcode-cn.com/problems/container-with-most-water/">盛水最多的容器</a></li><li><a href="https://leetcode-cn.com/problems/move-zeroes/">移动零</a></li><li><a href="https://leetcode-cn.com/problems/climbing-stairs/">爬楼梯</a></li><li><a href="https://leetcode-cn.com/problems/two-sum/">两数之和</a></li><li><a href="https://leetcode-cn.com/problems/3sum/">三数之和</a></li><li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">删除排序数组中的重复项</a></li><li><a href="https://leetcode-cn.com/problems/rotate-array/">旋转数组</a></li><li><a href="https://leetcode-cn.com/problems/reverse-linked-list/">反转链表</a></li><li><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">两两交换链表中的节点</a></li><li><a href="https://leetcode-cn.com/problems/linked-list-cycle/">环形链表</a></li><li><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">环形链表2</a></li><li><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">K 个一组翻转链表</a></li><li><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">合并两个有序链表</a></li></ol><h5 id="栈、队列、优先队列、双端队列"><a href="#栈、队列、优先队列、双端队列" class="headerlink" title="栈、队列、优先队列、双端队列"></a>栈、队列、优先队列、双端队列</h5><ol><li><a href="https://leetcode-cn.com/problems/valid-parentheses/">有效的括号</a></li><li><a href="https://leetcode-cn.com/problems/min-stack/">最小栈</a></li><li><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">柱状图中的最大矩形</a></li><li><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">滑动窗口最大值</a></li><li><a href="https://leetcode-cn.com/problems/trapping-rain-water/">接雨水</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天一个开发小技巧</title>
    <link href="/2021/03/11/daily-tips/"/>
    <url>/2021/03/11/daily-tips/</url>
    
    <content type="html"><![CDATA[<h2 id="尬聊"><a href="#尬聊" class="headerlink" title="尬聊"></a>尬聊</h2><p>在日常开发中，不免会遇到自己不熟悉的地方，但是很多时候我们查完用完然后就是技能归还。如果能在这里记录整理收集，那也是一笔宝贵的知识力量。可能有的小技巧并没有太多的实用价值，也有可能有一些奇奇怪怪的奇技淫巧，但这些代码里的精彩的碎片。日拱一卒，积少成多，相信时间的力量。</p><h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><ul><li>Mac校验文件SHA</li></ul><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">shasum -a 256 <span class="hljs-variable">$&#123;file&#125;</span><br></code></pre></td></tr></table></figure><ul><li><a href="https://jaywcjlove.gitee.io/linux-command/c/tcpdump.html">Linux 命令行抓包</a></li></ul><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">tcpdump -D <span class="hljs-comment"># 当前可以监听的网卡</span><br></code></pre></td></tr></table></figure><ul><li>git tag 重命名</li></ul><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs zsh">daiwei@daiweideMacBook-Pro ~ % git tag [new_name] [old_name]  <span class="hljs-comment"># 复制原有的tag</span><br>daiwei@daiweideMacBook-Pro ~ % git tag -d [old_name] <span class="hljs-comment"># 删除原有tag</span><br>daiwei@daiweideMacBook-Pro ~ % git push origin :refs/tag/v1.0 <span class="hljs-comment"># 删除远程 tag</span><br>daiwei@daiweideMacBook-Pro ~ % git push --tag <span class="hljs-comment">#推送本地新的tag</span><br></code></pre></td></tr></table></figure><ul><li>reflections 反射工具包，内置反射相关操作，简化开发</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.reflections<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>reflections<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>不使用 springboot-parent 创建 springboot 项目，方便清晰系统整体继承结构。只需要在依赖的父pom 的 dependencyManagement 中添加 spring-boot-dependencies 依赖即可。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;springboot.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p>三个有意思的在线的 playgroud </p><ul><li><p>redis 在线的web shell <a href="https://try.redis.io/">try redis</a> ，可以执行一些 redis cmds。</p></li><li><p>docker 的在线 <a href="https://labs.play-with-docker.com/">docker lab</a>，登录后提供一个时长四个小时的 session，过期需要重新登录，登录需要 docker hub 的账号，在 session 中可以操作多个docker实例，正如这个 lab 的名字一样～paly with docker。</p></li><li><p>git 在线学习网站 <a href="https://learngitbranching.js.org/?locale=zh_CN">learn-git-branch</a>，在这个网站通过完成一个个任务学习命令操作可视化的git节点到达学习 git 的目的，就很nice～</p></li></ul></li><li><p>.gitignore 文件不生效的问题，清理 git 的本地的缓存，然后重新 add commit 就可以了</p></li></ul><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs zsh">daiwei@daiweideMacBook-Pro ~ % git rm -r --cached .<br>daiwei@daiweideMacBook-Pro ~ % git add .<br>daiwei@daiweideMacBook-Pro ~ % git commit -m<span class="hljs-string">&#x27;update msg&#x27;</span><br>daiwei@daiweideMacBook-Pro ~ % git push origin main<br></code></pre></td></tr></table></figure><ul><li><p>linux 查看端口，每次都要查，每次都记不住😫</p><p>netstat 命令 用于查看 tcp 和 udp 的端口占用情况</p><ul><li>-t (tcp) 仅仅显示 tcp 相关</li><li>-u(udp) 仅仅显示 udp 相关</li><li>-n 拒绝显示别名，能显示数字的全部转化为数字</li><li>-l 仅列出在Listen(监听)的服务状态</li><li>-p 显示建立相关链接的程序名</li></ul><p>所以我全都要 所以命令就是 -nptul (牛批吐了)😏</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">netstat -nptul | grep &lt;port&gt;<br></code></pre></td></tr></table></figure><p> <strong>注意这个命令 mac 上就是另外一套参数了，mac 上可以使用 lsof - i:port</strong></p></li><li><p>redis 中 lua 脚本的编写的基本方法</p><p>从 redis 2.6.0 开始内置支持 lua 脚本，可以通过 lua 脚本实现执行多条命令的原子性，典型的使用场景有 分布式锁 和 分布式扣减等。基本的操作命令如下</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">127.0.0.1:6379&gt; EVAL script numkeys key [key...] arg [arg...]<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>script</td><td>脚本内容</td></tr><tr><td>numkeys</td><td>key 的个数（只是 key 的个数和 argv 没有关系）</td></tr><tr><td>key [key…]</td><td>key列表，键名通过全局变量 KEYS 数组，用 1 为基址的形式访问( KEYS[1] ， KEYS[2] ，以此类推)</td></tr><tr><td>arg [arg…]</td><td>参数列表，参数通过全局变量 ARGV 数组，用 1 为基址的形式访问( ARGV[1] ， ARGV[2] ，以此类推)</td></tr></tbody></table><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs zsh">127.0.0.1:6379&gt; <span class="hljs-built_in">eval</span> <span class="hljs-string">&quot;return &#123;KEYS[1], KEYS[2], ARGV[1], ARGV[2], ARGV[3]&#125;&quot;</span> 2 key1 key2 avg1 avg2 avg3<br><span class="hljs-comment">## 输出</span><br>1) <span class="hljs-string">&quot;key1&quot;</span><br>2) <span class="hljs-string">&quot;key2&quot;</span><br>3) <span class="hljs-string">&quot;avg1&quot;</span><br>4) <span class="hljs-string">&quot;avg2&quot;</span><br>5) <span class="hljs-string">&quot;avg3&quot;</span><br></code></pre></td></tr></table></figure><p>还可以通过 <strong>script load</strong> 命令缓存命令，并通过 <strong>evalsha</strong> 命令执行</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs zsh">SCRIPT LOAD script <span class="hljs-comment"># 缓存 lua 脚本</span><br>EVALSHA sha1 numkeys key [key ...] arg [arg ...]  <span class="hljs-comment"># 执行 lua 脚本</span><br></code></pre></td></tr></table></figure><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs zsh">script load <span class="hljs-string">&quot;return &#123;KEYS[1], KEYS[2], ARGV[1], ARGV[2], ARGV[3]&#125;&quot;</span><br><span class="hljs-string">&quot;0e8e5b92bfe818cf5eb29a03465e71bd8ef3e95a&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs zsh">127.0.0.1:6379&gt; evalsha 0e8e5b92bfe818cf5eb29a03465e71bd8ef3e95a 2 hello word arg1 arg2 arg3<br>1) <span class="hljs-string">&quot;hello&quot;</span><br>2) <span class="hljs-string">&quot;word&quot;</span><br>3) <span class="hljs-string">&quot;arg1&quot;</span><br>4) <span class="hljs-string">&quot;arg2&quot;</span><br>5) <span class="hljs-string">&quot;arg3&quot;</span><br></code></pre></td></tr></table></figure><p>几个常用的 redis lua 脚本</p><p>​    分布式锁</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--lock</span><br><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&#x27;setnx&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>]) == <span class="hljs-number">1</span> <span class="hljs-keyword">then</span> redis.call(<span class="hljs-string">&#x27;expire&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">2</span>]) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;true&#x27;</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;false&#x27;</span> <span class="hljs-keyword">end</span><br><span class="hljs-comment">-- unlock</span><br><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>] <span class="hljs-keyword">then</span> redis.call(<span class="hljs-string">&#x27;del&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) <span class="hljs-keyword">end</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;true&#x27;</span><br></code></pre></td></tr></table></figure><p>​    分布式计数器</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&#x27;EXISTS&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> redis.call(<span class="hljs-string">&#x27;GET&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) &gt; ARGV[<span class="hljs-number">1</span>] <span class="hljs-keyword">then</span> redis.call(<span class="hljs-string">&#x27;decr&#x27;</span>, KEYS[<span class="hljs-number">1</span>])  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;true&#x27;</span> <span class="hljs-keyword">else</span>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;false&#x27;</span> <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>随笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发小技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>100w数据插入实现与思考</title>
    <link href="/2021/03/07/100w-data-insert/"/>
    <url>/2021/03/07/100w-data-insert/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这是学习中遇到的一个题目，往一个表中插入100w条数据，看到这个题目的时候人是懵逼的。因为目前公司线上最大的表记录不过100w出头，每次做数据清洗或者数据迁移的时候一个通宵都不一定能跑完，那么插入100w 又怎么会快的起来呢？更何况老师问是否能把性能优化到 10s 之内呢。。</p><h3 id="思维爆炸"><a href="#思维爆炸" class="headerlink" title="思维爆炸"></a>思维爆炸</h3><p>只要思想不滑坡，办法总比方法多。老师既然问了那这个问题肯定是有解的，如果脑暴分析下可以得到下面的一些信息线索。</p><ul><li><p><strong>数据库优化主要分以下三部分</strong></p><ul><li><strong>数据库端参数优化</strong></li><li><strong>sql 优化</strong></li><li><strong>表结构优化</strong></li></ul></li><li><p>影响数据库吞吐量的因素</p><ul><li>单个事务大小</li><li>redolog写入情况和脏页数量</li><li>数据库连接池空闲情况和一些相关的buffer</li><li>索引</li><li>数据库实例性能</li></ul></li><li><p>java 代码的性能因素</p><ul><li>封装越小 速度越快</li><li>多线程</li><li>数据库连接池</li></ul></li><li><p>运行环境因素</p><ul><li>cpu</li><li>io</li><li>system</li></ul></li></ul><p>以上这些是我能想到的一些影响的方面，和可以针对优化的点。本次测试基本上都在我自己的 mbp 上跑，所以<strong>运行环境这个条件变量基本是控制不变</strong>的。</p><p>根据上面的一些因素可以得到一些可行的操作方案</p><ol><li>数据库连接工具执行批量sql</li><li>基本的循环插入</li><li>拼接批量 sql</li><li>使用preparedStatement + queryBatch</li><li>多线程提升性能</li></ol><h3 id="走两步试试"><a href="#走两步试试" class="headerlink" title="走两步试试"></a>走两步试试</h3><h4 id="数据库环境"><a href="#数据库环境" class="headerlink" title="数据库环境"></a>数据库环境</h4><blockquote><p>docker 默认配置 + mysql5.7</p></blockquote><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs zsh">docker pull mysql:5.7<br>docker run --name mysql-test -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7<br></code></pre></td></tr></table></figure><h4 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> tb_order_test_1(<br>`id` <span class="hljs-type">int</span> auto_increment,<br>`good_id` <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;0&#x27;</span>,<br>`user_id` <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;0&#x27;</span>, <br>`good_status` tinyint <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;1&#x27;</span>,<br>`username` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;&#x27;</span>,<br><span class="hljs-keyword">primary</span> key(id)<br>) engine<span class="hljs-operator">=</span>innodb<br></code></pre></td></tr></table></figure><h4 id="数据库连接工具执行批量sql"><a href="#数据库连接工具执行批量sql" class="headerlink" title="数据库连接工具执行批量sql"></a>数据库连接工具执行批量sql</h4><p>从数据库中反向导出数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql">LOCK TABLES `tb_order_test_1` WRITE;<br><span class="hljs-comment">/*!40000 ALTER TABLE `tb_order_test_1` DISABLE KEYS */</span>;<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `tb_order_test_1` (`id`, `good_id`, `user_id`, `good_status`, `username`)<br><span class="hljs-keyword">VALUES</span><br>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;daiwei&#x27;</span>),<br>(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;daiwei&#x27;</span>),<br>(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;daiwei&#x27;</span>),<br>(<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;daiwei&#x27;</span>),<br>(<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;daiwei&#x27;</span>),<br>..... <span class="hljs-number">100</span>w .....<br>(<span class="hljs-number">999997</span>,<span class="hljs-number">999996</span>,<span class="hljs-number">999996</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;daiwei&#x27;</span>),<br>(<span class="hljs-number">999998</span>,<span class="hljs-number">999997</span>,<span class="hljs-number">999997</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;daiwei&#x27;</span>),<br>(<span class="hljs-number">999999</span>,<span class="hljs-number">999998</span>,<span class="hljs-number">999998</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;daiwei&#x27;</span>),<br>(<span class="hljs-number">1000000</span>,<span class="hljs-number">999999</span>,<span class="hljs-number">999999</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;daiwei&#x27;</span>);<br><br><span class="hljs-comment">/*!40000 ALTER TABLE `tb_order_test_1` ENABLE KEYS */</span>;<br>UNLOCK TABLES;<br></code></pre></td></tr></table></figure><p>这里导出数据可以发现两个问题，首先sql 的存储的文件是批量插入的，其次在操作的过程中，表是锁定状态的。</p><p>最终手动🙈掐表测100w 的数据导入大概需要 7.5 秒。</p><h4 id="基础的循环操作插入操作"><a href="#基础的循环操作插入操作" class="headerlink" title="基础的循环操作插入操作"></a>基础的循环操作插入操作</h4><p>这个最基本最简单的循环插入，明显是不可能会有较高的插入性能的，但是我就是想知道最慢着要多久🤤。这最基本的就不用那些ORM 框架了就直接使用 jdbc 操作了，封装越高速度也就越慢。同时稍微控制下事务，这种不考虑大事务的前提下，减少事务提交，一次提交。大量数据的插入会影响到数据页导致页分裂，也会拖慢整体的时间，所以整个测试过程中，不额外创建索引。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertByLoop</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>  Connection conn = JdbcUtil.getConnFromHikari();<br>  PreparedStatement stat = <span class="hljs-keyword">null</span>;<br>  <span class="hljs-keyword">try</span> &#123;<br>      String sql = <span class="hljs-string">&quot;insert into tb_order_test_1(good_id, user_id, good_status, username) values (?, ?, ?, ?)&quot;</span>;<br>      conn.setAutoCommit(<span class="hljs-keyword">false</span>);<br>      stat = conn.prepareStatement(sql);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3000</span>; i++) &#123;<br>          stat.setLong(<span class="hljs-number">1</span>, i);<br>          stat.setLong(<span class="hljs-number">2</span>, i);<br>          stat.setInt(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>);<br>          stat.setString(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;daiwei&quot;</span>);<br>          stat.execute();<br>        &#125;<br>      conn.commit();<br>    &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>      throwables.printStackTrace();<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>      JdbcUtil.release(conn, stat, <span class="hljs-keyword">null</span>);<br>    &#125;<br>  System.out.println(System.currentTimeMillis() - start);<br>&#125;<br></code></pre></td></tr></table></figure><p>1w条数据插入耗时 24015 ms，插入的数据量和插入时间是线性相关的，所以就不过多的浪费时间了。。。🤨</p><h4 id="jdbc-batch-批处理"><a href="#jdbc-batch-批处理" class="headerlink" title="jdbc batch 批处理"></a>jdbc batch 批处理</h4><p>这个版本的操作相较于上面的一种，最大的提升就是用了批处理操作。在批量插入上性能能有一定的提升，但是提升效果不是很大。1w 数据量 11358ms。<strong>但是这里有一个参数rewriteBatchedStatements=true</strong>，加上这个参数允许将批量处理的 sql 进行重写，来提高批处理性能，相当于魔改了。。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertSqlBatch</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>  Connection conn = JdbcUtil.getConnFromHikari();<br>  PreparedStatement stat = <span class="hljs-keyword">null</span>;<br>  <span class="hljs-keyword">try</span> &#123;<br>      String sql = <span class="hljs-string">&quot;insert into tb_order_test_1(good_id, user_id, good_status, username) values (?, ?, ?, ?)&quot;</span>;<br>      conn.setAutoCommit(<span class="hljs-keyword">false</span>);<br>      stat = conn.prepareStatement(sql);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50000</span>; i++) &#123;<br>          stat.setLong(<span class="hljs-number">1</span>, i);<br>          stat.setLong(<span class="hljs-number">2</span>, i);<br>          stat.setInt(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>);<br>          stat.setString(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;daiwei&quot;</span>);<br>          stat.addBatch();<br>        &#125;<br>      stat.executeBatch();<br>      conn.commit();<br>    &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>      throwables.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      JdbcUtil.release(conn, stat, <span class="hljs-keyword">null</span>);<br>    &#125;<br>  System.out.println(System.currentTimeMillis() - start);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">jdbc.url</span>=<span class="hljs-string">jdbc:mysql://127.0.0.1:3306/test?rewriteBatchedStatements=true</span><br></code></pre></td></tr></table></figure><p>添加参数之后，batch insert 的性能有极大的提高。100w 的数据量 8775ms 就操作完成。</p><h4 id="拼接sql-批处理"><a href="#拼接sql-批处理" class="headerlink" title="拼接sql + 批处理"></a>拼接sql + 批处理</h4><p>在不开启rewriteBatchedStatements = true 的情况下，如果我自己手动拼接sql 减少 jdbc 的封装，速度是否能在往上提升呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertByBatch</span><span class="hljs-params">()</span> </span>&#123;<br>  Connection conn = JdbcUtil.getConnFromHikari();<br>    Statement stat = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>    <span class="hljs-keyword">try</span> &#123;<br>      stat = conn.createStatement();<br>      String sql;<br>      StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;insert into tb_order_test_1(good_id, user_id, good_status, username) values&quot;</span>);<br>      conn.setAutoCommit(<span class="hljs-keyword">false</span>);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;<br>              sb.append(<span class="hljs-string">&quot;(&quot;</span> + i +<span class="hljs-string">&quot; , &quot;</span> + j +<span class="hljs-string">&quot;, 1 , &#x27;daiwei&#x27;),&quot;</span>);<br>            &#125;<br>          sql = sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>).toString();<br>          stat.addBatch(sql);<br>          sb.delete(<span class="hljs-number">75</span>, sb.length());<br>        &#125;<br>      stat.executeBatch();<br>      conn.commit();<br>      System.out.println(System.currentTimeMillis() - start);<br>    &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>      throwables.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      JdbcUtil.release(conn, stat, <span class="hljs-keyword">null</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方案跑下来，优化效果还是比较明显的，100w的数据插入的时间大概在 5s ～6s 这个区间。</p><p>这个方案的小缺点是事务分开的整体的数据插入不是原子性的。</p><h4 id="多线程-拼接sql-批处理"><a href="#多线程-拼接sql-批处理" class="headerlink" title="多线程 + 拼接sql + 批处理"></a>多线程 + 拼接sql + 批处理</h4><p>单线程跑下来性能都已经提升这么明显了，那多线程。。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertConcurBatch</span><span class="hljs-params">()</span> </span>&#123;<br>  ExecutorService executor = Executors.newFixedThreadPool(<span class="hljs-number">4</span>);<br>  <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>  CyclicBarrier cyclicBarrier = <span class="hljs-keyword">new</span> CyclicBarrier(<span class="hljs-number">4</span>, () -&gt; &#123;<br>      System.out.println(System.currentTimeMillis() - start);<br>      executor.shutdown();<br>    &#125;);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>      executor.execute(() -&gt; &#123;<br>          insertByBatch(<span class="hljs-number">250</span>);<br>          <span class="hljs-keyword">try</span> &#123;<br>              cyclicBarrier.await();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>              e.printStackTrace();<br>            &#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException e) &#123;<br>              e.printStackTrace();<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertByBatch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>  Connection conn = JdbcUtil.getConnFromHikari();<br>    Statement stat = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>    <span class="hljs-keyword">try</span> &#123;<br>      stat = conn.createStatement();<br>      String sql;<br>      StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;insert into tb_order_test_1(good_id, user_id, good_status, username) values&quot;</span>);<br>      conn.setAutoCommit(<span class="hljs-keyword">false</span>);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;<br>              sb.append(<span class="hljs-string">&quot;(&quot;</span> + i +<span class="hljs-string">&quot; , &quot;</span> + j +<span class="hljs-string">&quot;, 1 , &#x27;daiwei&#x27;),&quot;</span>);<br>            &#125;<br>          sql = sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>).toString();<br>          stat.addBatch(sql);<br>          sb.delete(<span class="hljs-number">75</span>, sb.length());<br>        &#125;<br>      stat.executeBatch();<br>      conn.commit();<br>      System.out.println(System.currentTimeMillis() - start);<br>    &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>      throwables.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      JdbcUtil.release(conn, stat, <span class="hljs-keyword">null</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>果然发挥多线程的性能优势，整体性能优能往上提升一点点。</p><h3 id="泥巴路上走一走"><a href="#泥巴路上走一走" class="headerlink" title="泥巴路上走一走"></a>泥巴路上走一走</h3><p>实际生产环境的话，并不会有几个表只有 几个字段，多是字段20+ ，所以如果字段多上去，插入性能是否会受到影响？如此便有了下面的测试</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `tb_order_test` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `good_id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `user_id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `good_status` tinyint(<span class="hljs-number">4</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;1&#x27;</span>,<br>  `field_4` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_5` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_6` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_7` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_8` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_9` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_10` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_11` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_12` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_13` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_14` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_15` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_16` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_17` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_18` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_19` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_20` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_21` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_22` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_23` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_24` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_25` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_26` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_27` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_28` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_29` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_30` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">5214001</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>latin1;<br></code></pre></td></tr></table></figure><p>测试代码的话这里用的还是 多线程 + 拼接sql + 批处理 的 pro 版本，果然这次的测试的速度有很明显的下降 100w 的插入时间 到了 19866ms，我的电脑是 8 核的，本着充分利用系统资源和数据库并发资源的原则。最终的 100w 时间到了 18080ms。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在这个场景中有很多的环境因素：mysql数据库、sql语句和 java代码等多个方面，其中的任何一个部分出现瓶颈，都会拖累整体的性能，但是如果换个角度去看这个问题。如果我们每个部分的性能都能充分发挥整体的性能也相应提高。本次的优化过程从 sql部分，编码技巧到表结构优化去尽可能提升100w数据的插入速度。这里漏了一个角度，就是调整mysql 的参数去优化，在mysql 写入过程中有 WAL 机制，如果这里调大 redolog buf 尽可能少的减少 redolog 的 刷脏页操作，是否也能提升写入的性能呢？🤔，最后下面是本次测试结果表格</p><table><thead><tr><th>插入方式</th><th>1w</th><th>10w</th><th>100W</th></tr></thead><tbody><tr><td>数据库工具导入</td><td>-</td><td>-</td><td>7500ms</td></tr><tr><td>单个事务循环插入</td><td>24015ms</td><td>-</td><td>-</td></tr><tr><td>单个事务batch批处理</td><td>11358ms</td><td>-</td><td>-</td></tr><tr><td>魔改 batch <br />（rewriteBatchedStatements）</td><td>689ms</td><td>1562ms</td><td>8775ms</td></tr><tr><td>拼接sql + 批处理</td><td>105ms</td><td>992ms</td><td>5302ms</td></tr><tr><td>多线程 + 拼接sql + 批处理</td><td>-</td><td>-</td><td>4314ms</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>随笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>jdbc</tag>
      
      <tag>实操</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
