<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JVM 基础—Java 字节码</title>
    <link href="/2021/05/07/java-bytecode/"/>
    <url>/2021/05/07/java-bytecode/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM-基础—Java-字节码"><a href="#JVM-基础—Java-字节码" class="headerlink" title="JVM 基础—Java 字节码"></a>JVM 基础—Java 字节码</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们通常表述的 JVM 通常有三种意思，JVM 是 Java virtual machine 即 java 虚拟机的缩写，也就是我们通常所指的 JVM。JVM还是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。因此 JVM 也是图灵完备的。当然 JVM 还可以表示一个虚拟机的实例。Java 一个非常重要的特性就是和平台无关，而 JVM 是实现这一点的关键。JVM 底层使用 C 进行编写，只要平台能执行 C 语言，这也就能启动 JVM 运行 Java 程序。JVM 通过编译 Java 语言生成字节码文件，字节码文件在通过 JVM 进行解释执行。因此只要运行在不同的平台上的JVM 能拿到字节码文件，就能解释执行出相同的结果。这就是 Java 可以 “一次编译，到处执行” 的原因。 </p><p>当然并不是Java 语言是跨平台的语言，拿 C++ 举个例子，C++ 也是一门跨平台的语言，但是和 Java 语言不同的是，C++ 需要到不同的平台生成不同的文件，然后进行执行，也就是源码跨平台，而 Java 是二进制跨平台。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210507003029.png"></p><h2 id="Java-字节码技术"><a href="#Java-字节码技术" class="headerlink" title="Java 字节码技术"></a>Java 字节码技术</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>Java 代码通过编译生成 Java 字节码即 .class 文件，不同的 JVM 通过执行 .class 文件实现跨平台。Java bytecode 由但字节 （byte）的指令组成，理论上最多支持 256 个操作码（opencode）。实际上 Java 只用了 200 左右的操作码，还有一些操作码则保留给调试操作。操作码， 下面称为 指令 , 主要由 类型前缀 和 操作名称 两部分组成。 </p><blockquote><p>例如，’ i ‘ 前缀代表 ‘ integer ’，所以，’ iadd ‘ 很容易理解, 表示对整数执行加法运算。</p></blockquote><p>根据指令性质，主要分为 4 个大类：</p><ol><li>栈操作指令， 包括与局部变量交互的指令。</li><li>程序流程控制指令。</li><li>对象操作指令，包括方法调用指令。</li><li>算术运算以及类型转换指令。</li></ol><h3 id="获取字节码"><a href="#获取字节码" class="headerlink" title="获取字节码"></a>获取字节码</h3><p>可以使用 javap 命令来获取 class 文件中的字节码， javap 是 jdk 中内置的用于反编译字节码的工具</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloByteCode</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        HelloByteCode obj = <span class="hljs-keyword">new</span> HelloByteCode();<br>        System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>现使用 javac 命令编译出 .class，在使用 <code>javap -c</code> 命令编译得到字节码文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">daiwei@daiweideMacBook-Pro <span class="hljs-built_in">test</span> % javap -c HelloByteCode.class<br>Compiled from <span class="hljs-string">&quot;HelloByteCode.java&quot;</span><br>public class HelloByteCode &#123;<br>  public HelloByteCode();<br>    Code:<br>       0: aload_0<br>       1: invokespecial <span class="hljs-comment">#1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>       4: <span class="hljs-built_in">return</span><br><br>  public static void main(java.lang.String[]);<br>    Code:<br>       0: new           <span class="hljs-comment">#2                  // class HelloByteCode</span><br>       3: dup<br>       4: invokespecial <span class="hljs-comment">#3                  // Method &quot;&lt;init&gt;&quot;:()V</span><br>       7: astore_1<br>       8: getstatic     <span class="hljs-comment">#4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br>      11: ldc           <span class="hljs-comment">#5                  // String hello</span><br>      13: invokevirtual <span class="hljs-comment">#6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>      16: <span class="hljs-built_in">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上面拉出 java 的字节码清单之后，下面对其进行简单的解读</p><h3 id="解析字节码清单"><a href="#解析字节码清单" class="headerlink" title="解析字节码清单"></a>解析字节码清单</h3><p>在上面的输出信息中，第二行也就是打印出来的字节码的第一行<code>Compiled from &quot;HelloByteCode.java&quot;</code>表示我们是从 HelloByteCode这个类反编译而来的字节码文件。4～8 行是一个构造函数，总所周知，如果我们在编写代码时不编写构造函数，就会生成一个默认的构造方法，这个就是默认的构造方法。而这个构造方法里也只有一条指令就是 <code>invokespecial</code> 这个是调用父类Object 对象的构造方法即 <code>super()</code> 方法。</p><p>如果想要看到更多的信息则需要使用<code>javap -c -verbose</code> 命令输出更多信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs bash">daiwei@daiweideMacBook-Pro <span class="hljs-built_in">test</span> % javap -c -verbose HelloByteCode.class<br>Classfile /Users/daiwei/study/java-course/JVM/<span class="hljs-built_in">test</span>/HelloByteCode.class<br>  Last modified 2021-1-7; size 442 bytes<br>  MD5 checksum 8e2a795fb147ef48ba63f55886005f32<br>  Compiled from <span class="hljs-string">&quot;HelloByteCode.java&quot;</span><br>public class HelloByteCode<br>  minor version: 0<br>  major version: 52<br>  flags: ACC_PUBLIC, ACC_SUPER<br>Constant pool:<br>   <span class="hljs-comment">#1 = Methodref          #7.#16         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>   <span class="hljs-comment">#2 = Class              #17            // HelloByteCode</span><br>   <span class="hljs-comment">#3 = Methodref          #2.#16         // HelloByteCode.&quot;&lt;init&gt;&quot;:()V</span><br>   <span class="hljs-comment">#4 = Fieldref           #18.#19        // java/lang/System.out:Ljava/io/PrintStream;</span><br>   <span class="hljs-comment">#5 = String             #20            // hello</span><br>   <span class="hljs-comment">#6 = Methodref          #21.#22        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>   <span class="hljs-comment">#7 = Class              #23            // java/lang/Object</span><br>   <span class="hljs-comment">#8 = Utf8               &lt;init&gt;</span><br>   <span class="hljs-comment">#9 = Utf8               ()V</span><br>  <span class="hljs-comment">#10 = Utf8               Code</span><br>  <span class="hljs-comment">#11 = Utf8               LineNumberTable</span><br>  <span class="hljs-comment">#12 = Utf8               main</span><br>  <span class="hljs-comment">#13 = Utf8               ([Ljava/lang/String;)V</span><br>  <span class="hljs-comment">#14 = Utf8               SourceFile</span><br>  <span class="hljs-comment">#15 = Utf8               HelloByteCode.java</span><br>  <span class="hljs-comment">#16 = NameAndType        #8:#9          // &quot;&lt;init&gt;&quot;:()V</span><br>  <span class="hljs-comment">#17 = Utf8               HelloByteCode</span><br>  <span class="hljs-comment">#18 = Class              #24            // java/lang/System</span><br>  <span class="hljs-comment">#19 = NameAndType        #25:#26        // out:Ljava/io/PrintStream;</span><br>  <span class="hljs-comment">#20 = Utf8               hello</span><br>  <span class="hljs-comment">#21 = Class              #27            // java/io/PrintStream</span><br>  <span class="hljs-comment">#22 = NameAndType        #28:#29        // println:(Ljava/lang/String;)V</span><br>  <span class="hljs-comment">#23 = Utf8               java/lang/Object</span><br>  <span class="hljs-comment">#24 = Utf8               java/lang/System</span><br>  <span class="hljs-comment">#25 = Utf8               out</span><br>  <span class="hljs-comment">#26 = Utf8               Ljava/io/PrintStream;</span><br>  <span class="hljs-comment">#27 = Utf8               java/io/PrintStream</span><br>  <span class="hljs-comment">#28 = Utf8               println</span><br>  <span class="hljs-comment">#29 = Utf8               (Ljava/lang/String;)V</span><br>&#123;<br>  public HelloByteCode();<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=1, locals=1, args_size=1<br>         0: aload_0<br>         1: invokespecial <span class="hljs-comment">#1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>         4: <span class="hljs-built_in">return</span><br>      LineNumberTable:<br>        line 1: 0<br><br>  public static void main(java.lang.String[]);<br>    descriptor: ([Ljava/lang/String;)V<br>    flags: ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      stack=2, locals=2, args_size=1<br>         0: new           <span class="hljs-comment">#2                  // class HelloByteCode</span><br>         3: dup<br>         4: invokespecial <span class="hljs-comment">#3                  // Method &quot;&lt;init&gt;&quot;:()V</span><br>         7: astore_1<br>         8: getstatic     <span class="hljs-comment">#4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br>        11: ldc           <span class="hljs-comment">#5                  // String hello</span><br>        13: invokevirtual <span class="hljs-comment">#6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>        16: <span class="hljs-built_in">return</span><br>      LineNumberTable:<br>        line 3: 0<br>        line 4: 8<br>        line 5: 16<br>&#125;<br>SourceFile: <span class="hljs-string">&quot;HelloByteCode.java&quot;</span><br></code></pre></td></tr></table></figure><p>这次的输出比之前一次多了不少的信息，首先是 10～39 行的常量池信息。这里记录了代码中用到的常量。40～68行是之前代码部分的字节码，这一次多了一些如 <code>descriptor, flags</code> 的信息。descriptor 是方法的描述符，flags 则是方法的访问描述符，这是个 public static 方法。第45行的 <code>stack=1, locals=1, args_size=1</code> 表示方法栈的深度为1， 本地局部变量表大小为1 ，方法的入参为1。这里有个比较有意思的地方，就是无参构造的 args_size 不为0 而是 1 ，这是因为对于构造方法需要有一个引用地址，也就是 this 的引用地址，这个可以类比反射里面<code>Method#invoke(Object obj, Object... args);</code> 第一个参数是被调用对象一样。</p><h3 id="线程栈和字节码执行模型"><a href="#线程栈和字节码执行模型" class="headerlink" title="线程栈和字节码执行模型"></a>线程栈和字节码执行模型</h3><p>JVM 是基于栈的计算机模型，每一个线程都有自己的线程栈（JVM stack）和用于存储的<code>栈帧</code>（Frame），每调用一个方法JVM都会自动创建一个栈帧，栈帧中包括<code>操作数栈</code>，<code>局部变量数组</code>和一个 <code>class 引用</code>构成，class 引用指向当前方法在运行时常量池中对应的class。</p><p>​       <img src="https://gitee.com/realDaiwei/img/raw/master/20210507003351.png"></p><p><code>局部变量数组</code> 也成为 <code>局部方法表</code>（LocalVariableTable），其中包括方法的参数和局部变量。局部变量数组长度在编译时就已经确定。和局部变量和方法形参有关，但是具体长度还要看具体每个字段占用的长度。<code>操作数栈</code>（Operand Stack）是一个 LIFO 的结构栈，通过于压入弹出进行数据操作，其大小在编译时确定。</p><p>一些操作码/指令可以将值压入操作数栈，还有一些操作码/指令从操作数栈获取操作数，并进行计算，然后再压入操作数栈。操作数栈还用于接受调用其他方法的返回值。</p><h3 id="方法体中的字节码解析"><a href="#方法体中的字节码解析" class="headerlink" title="方法体中的字节码解析"></a>方法体中的字节码解析</h3><p>在前面的几个例子当中，字节码看起来问题都不大，但是看方法体中的字节码的编号有点看不懂，也就是下面的一些字节码</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">0:</span> <span class="hljs-string">new</span>           <span class="hljs-comment">#2                  // class HelloByteCode</span><br><span class="hljs-attr">3:</span> <span class="hljs-string">dup</span><br><span class="hljs-attr">4:</span> <span class="hljs-string">invokespecial</span> <span class="hljs-comment">#3                  // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="hljs-attr">7:</span> <span class="hljs-string">astore_1</span><br><span class="hljs-attr">8:</span> <span class="hljs-string">return</span><br></code></pre></td></tr></table></figure><p>前面的一排数字是<code>指令集数组中的索引</code> new 操作占用一个槽位，并且 new 指令需要消耗两个操作数，所以 dup 指令是从<code>3</code>开始的，<code>dup</code> 指令不需要操作数，所以只占一个槽位。位于<code>4</code>号槽位中的 <code>invokespecial</code> 指令同样需要消耗两个操作数，所以 astore_1 从7号槽位开始。<code>astore_1</code>意思是将栈顶元素存入局部变量表1号槽位，不需要操作数，所以 <code>return</code> 位于<code>8</code>号槽位。<img src="https://gitee.com/realDaiwei/img/raw/master/20210507003454.png"></p><p>通过操作码/指令对照表并换算十六进制（HEX）表示形式之后。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210507003612.png"></p><p>也就是我们通过十六进制打开.class 文件所能看到的数据片段了。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210507003708.png"></p><h3 id="对象初始化指令"><a href="#对象初始化指令" class="headerlink" title="对象初始化指令"></a>对象初始化指令</h3><p>new 是Java 的关键字，但是在字节码中，也有一个指令 new 但是整个 new 的逻辑，可以分为以下的字节码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">0: new           <span class="hljs-comment">#2                  // class HelloByteCode</span><br>3: dup<br>4: invokespecial <span class="hljs-comment">#3                  // Method &quot;&lt;init&gt;&quot;:()V</span><br></code></pre></td></tr></table></figure><p>new 指令和 invokespecial 指令在一起，那么这段字节码一定是在实例一个对象。那为什么实例一个对象不是一个指令而是三个指令呢？</p><ul><li><code>new</code> 指令只是创建对象，而并没有调用构造函数。</li><li><code>dup</code> 复制栈顶元素。这里为什么要复制栈顶元素呢？因为构造函数不会返回实例对象引用，所以没用dup指令，操作数栈是空的，初始化之后就会有问题。</li><li><code>invokespecial</code> 字面意思，调用特殊的方法，在这里就是调用构造函数。</li></ul><p>完成了上面的代码后一般会执行的指令会有下面几种：</p><ul><li><code>astore &#123;N&#125;</code> 或者 <code>astore_&#123;N&#125;</code> 给局部变量赋值，其中{N}代表局部变量表中的位置。</li><li><code>putfield</code>  将值赋给实例。</li><li><code>putstatic</code> 将实例赋给静态字段。</li></ul><p>这个时候如果没有那个 dup 的引用的话这里就没有就没法进行出栈赋值操作。</p><p>在调用构造函数之前，还会执行一个类似 <init> 的方法。但是 <clinit> 并不能被直接调用，而是由 <code>new</code>，<code>getstatic</code>，<code>putstatic</code> 或 <code>invokestatic</code> 触发。</p><p>也就是说，在实例化一个对象，访问静态字段或一些静态方法，就会触发这个类的静态初始化方法。</p><h3 id="栈内存操作指令"><a href="#栈内存操作指令" class="headerlink" title="栈内存操作指令"></a>栈内存操作指令</h3><p>有很多指令可以操作方法栈。压入栈数据和从数据栈弹出数据等一些基础的操作，有 <code>dup</code> 复制栈顶元素，和 <code>pop</code> 弹出栈顶元素的指令。还有一些复杂点的指令例如：</p><ul><li><code>swap</code> ：交换两个栈顶元素。</li><li><code>dup_x1</code>：复制栈顶的值, 并将复制的值插入到最上面2个值的下方。</li><li><code>dup2_x1</code>：制栈顶 1个64位/或2个32位的值, 并将复制的值按照原始顺序，插入原始值下面一个32位值的下方。 配合使用可用于交换两个64位数据的位置。</li></ul><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210507003819.png"></p><blockquote><p>数据类型分组（1代表32 位元素， 2代表64位元素）</p></blockquote><table><thead><tr><th>实际类型</th><th>JVM 计算类型</th><th>类型分组</th></tr></thead><tbody><tr><td>boolean</td><td>int</td><td>1</td></tr><tr><td>byte</td><td>int</td><td>1</td></tr><tr><td>char</td><td>int</td><td>1</td></tr><tr><td>short</td><td>int</td><td>1</td></tr><tr><td>int</td><td>int</td><td>1</td></tr><tr><td>float</td><td>float</td><td>1</td></tr><tr><td>refrence</td><td>refrence</td><td>1</td></tr><tr><td>retrunAddress</td><td>retrunAddress</td><td>1</td></tr><tr><td>long</td><td>long</td><td>2</td></tr><tr><td>double</td><td>double</td><td>2</td></tr></tbody></table><blockquote><p>⚠️ 理解这些字节码的诀窍在于</p><p>给局部变量赋值时，需要使用相应的指令来进行 <code>store</code> ，如 <code>astore_1</code>、 <code>store</code> 类的指令都会删除栈顶值。 相应的 load 指令则会将值从局部变量表压入操作数栈，但并不会删除局部变量中的值。</p></blockquote><h3 id="算术运算指令与类型转换指令"><a href="#算术运算指令与类型转换指令" class="headerlink" title="算术运算指令与类型转换指令"></a>算术运算指令与类型转换指令</h3><p>Java 字节码有很多的指令可以执行算术运算。对于所有数值类型（<code>int</code>, <code>long</code>, <code>double</code>, <code>float</code>）都有各自的加、减、乘、除、取反指令。当然boolean、byte、short、char 等都是当 int 类型处理。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210507003904.png"></p><p>在java 是一个强类型的语言，如果类型不匹配需要进行类型转换，如果<code>int</code>需要转换为 <code>double</code> 会调用 i2d 指令进行类型转换。</p><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210507003936.png"></p><p>唯一一个不需要将数值load到操作数栈的指令是 <code>iinc</code>，他可以直接对 <code>LocalVariableTable</code> 中的数值进行运算。其他的操作均使用操作数栈进行运算。</p><blockquote><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-7.html">操作码对照表</a></p></blockquote><h3 id="方法调用指令"><a href="#方法调用指令" class="headerlink" title="方法调用指令"></a>方法调用指令</h3><p>在前面已经到了 <code>invokespceial</code> 调用构造方法，那调用其他不同类型的方法用什么指令呢？</p><ul><li><code>invokestatic</code> 调用静态方法，也是几个调用指令当中最快的。</li><li><code>invokespeical</code> 可以用来调用构造方法，同时这个指令也可以用来调用 <code>private</code> 方法 和可见的 <code>super</code> 中的方法。</li><li><code>invokevirtual</code> 可以调用目标对象的实例方法。</li><li><code>invokeinterface</code> 用于调用目标接口方法，可以在运行时搜索一个实现这个接口的对象，并找出合适的方法进行调用。</li><li><code>invokedynamic</code> jdk 1.7 新加入的一个虚拟机指令，前四条指令的分派逻辑在虚拟机内部是固定的，<code>invokedynamic</code> 它允许应用代码来确定具体执行的是那个方法，从而到达对动态语言的支持。Lambda 表达式基于 <code>invokedynamic</code> 实现。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个部分简单介绍了Java 字节码，从开篇介绍怎么拉取一个 Java 代码的字节码开始，逐步复习了jvm 方法栈的栈帧，也就是 字节码的执行环境，这个部分由一个操作数栈，一个本地局部变量表和一个class 引用构成。通过分析一些常见的字节码例如构造函数和一些简单的方法体，熟悉了解了一些基本的操作码，例如 dup、pop、istore、iload 等指令。其中理解的诀窍在于 给局部变量赋值时，需要使用相应的指令来进行 <code>store</code> ，如 <code>astore_1</code>、 <code>store</code> 类的指令都会删除栈顶值。 相应的 load 指令则会将值从局部变量表压入操作数栈，但并不会删除局部变量中的值。当然在这些基本的操作指令中还包括一些类型转换的指令和方法的调用的指令，方法调用到后面会有专门梳理。</p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>Java知识结构梳理</tag>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcodes 习题汇总</title>
    <link href="/2021/03/28/leetcodes/"/>
    <url>/2021/03/28/leetcodes/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-习题汇总"><a href="#LeetCode-习题汇总" class="headerlink" title="LeetCode 习题汇总"></a>LeetCode 习题汇总</h2><h5 id="数组、链表"><a href="#数组、链表" class="headerlink" title="数组、链表"></a>数组、链表</h5><ol><li><a href="https://leetcode-cn.com/problems/container-with-most-water/">盛水最多的容器</a></li><li><a href="https://leetcode-cn.com/problems/move-zeroes/">移动零</a></li><li><a href="https://leetcode-cn.com/problems/climbing-stairs/">爬楼梯</a></li><li><a href="https://leetcode-cn.com/problems/two-sum/">两数之和</a></li><li><a href="https://leetcode-cn.com/problems/3sum/">三数之和</a></li><li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">删除排序数组中的重复项</a></li><li><a href="https://leetcode-cn.com/problems/rotate-array/">旋转数组</a></li><li><a href="https://leetcode-cn.com/problems/reverse-linked-list/">反转链表</a></li><li><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">两两交换链表中的节点</a></li><li><a href="https://leetcode-cn.com/problems/linked-list-cycle/">环形链表</a></li><li><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">环形链表2</a></li><li><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">K 个一组翻转链表</a></li><li><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">合并两个有序链表</a></li></ol><h5 id="栈、队列、优先队列、双端队列"><a href="#栈、队列、优先队列、双端队列" class="headerlink" title="栈、队列、优先队列、双端队列"></a>栈、队列、优先队列、双端队列</h5><ol><li><a href="https://leetcode-cn.com/problems/valid-parentheses/">有效的括号</a></li><li><a href="https://leetcode-cn.com/problems/min-stack/">最小栈</a></li><li><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">柱状图中的最大矩形</a></li><li><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">滑动窗口最大值</a></li><li><a href="https://leetcode-cn.com/problems/trapping-rain-water/">接雨水</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天一个开发小技巧</title>
    <link href="/2021/03/11/daily-tips/"/>
    <url>/2021/03/11/daily-tips/</url>
    
    <content type="html"><![CDATA[<h2 id="尬聊"><a href="#尬聊" class="headerlink" title="尬聊"></a>尬聊</h2><p>在日常开发中，不免会遇到自己不熟悉的地方，但是很多时候我们查完用完然后就是技能归还。如果能在这里记录整理收集，那也是一笔宝贵的知识力量。可能有的小技巧并没有太多的实用价值，也有可能有一些奇奇怪怪的奇技淫巧，但这些代码里的精彩的碎片。日拱一卒，积少成多，相信时间的力量。</p><h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><ul><li>Mac校验文件SHA</li></ul><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">shasum -a 256 <span class="hljs-variable">$&#123;file&#125;</span><br></code></pre></td></tr></table></figure><ul><li><a href="https://jaywcjlove.gitee.io/linux-command/c/tcpdump.html">Linux 命令行抓包</a></li></ul><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">tcpdump -D <span class="hljs-comment"># 当前可以监听的网卡</span><br></code></pre></td></tr></table></figure><ul><li>git tag 重命名</li></ul><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs zsh">daiwei@daiweideMacBook-Pro ~ % git tag [new_name] [old_name]  <span class="hljs-comment"># 复制原有的tag</span><br>daiwei@daiweideMacBook-Pro ~ % git tag -d [old_name] <span class="hljs-comment"># 删除原有tag</span><br>daiwei@daiweideMacBook-Pro ~ % git push origin :refs/tag/v1.0 <span class="hljs-comment"># 删除远程 tag</span><br>daiwei@daiweideMacBook-Pro ~ % git push --tag <span class="hljs-comment">#推送本地新的tag</span><br></code></pre></td></tr></table></figure><ul><li>reflections 反射工具包，内置反射相关操作，简化开发</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.reflections<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>reflections<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>不使用 springboot-parent 创建 springboot 项目，方便清晰系统整体继承结构。只需要在依赖的父pom 的 dependencyManagement 中添加 spring-boot-dependencies 依赖即可。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;springboot.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p>三个有意思的在线的 playgroud </p><ul><li><p>redis 在线的web shell <a href="https://try.redis.io/">try redis</a> ，可以执行一些 redis cmds。</p></li><li><p>docker 的在线 <a href="https://labs.play-with-docker.com/">docker lab</a>，登录后提供一个时长四个小时的 session，过期需要重新登录，登录需要 docker hub 的账号，在 session 中可以操作多个docker实例，正如这个 lab 的名字一样～paly with docker。</p></li><li><p>git 在线学习网站 <a href="https://learngitbranching.js.org/?locale=zh_CN">learn-git-branch</a>，在这个网站通过完成一个个任务学习命令操作可视化的git节点到达学习 git 的目的，就很nice～</p></li></ul></li><li><p>.gitignore 文件不生效的问题，清理 git 的本地的缓存，然后重新 add commit 就可以了</p></li></ul><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs zsh">daiwei@daiweideMacBook-Pro ~ % git rm -r --cached .<br>daiwei@daiweideMacBook-Pro ~ % git add .<br>daiwei@daiweideMacBook-Pro ~ % git commit -m<span class="hljs-string">&#x27;update msg&#x27;</span><br>daiwei@daiweideMacBook-Pro ~ % git push origin main<br></code></pre></td></tr></table></figure><ul><li><p>linux 查看端口，每次都要查，每次都记不住😫</p><p>netstat 命令 用于查看 tcp 和 udp 的端口占用情况</p><ul><li>-t (tcp) 仅仅显示 tcp 相关</li><li>-u(udp) 仅仅显示 udp 相关</li><li>-n 拒绝显示别名，能显示数字的全部转化为数字</li><li>-l 仅列出在Listen(监听)的服务状态</li><li>-p 显示建立相关链接的程序名</li></ul><p>所以我全都要 所以命令就是 -nptul (牛批吐了)😏</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">netstat -nptul | grep &lt;port&gt;<br></code></pre></td></tr></table></figure><p> <strong>注意这个命令 mac 上就是另外一套参数了，mac 上可以使用 lsof - i:port</strong></p></li><li><p>redis 中 lua 脚本的编写的基本方法</p><p>从 redis 2.6.0 开始内置支持 lua 脚本，可以通过 lua 脚本实现执行多条命令的原子性，典型的使用场景有 分布式锁 和 分布式扣减等。基本的操作命令如下</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">127.0.0.1:6379&gt; EVAL script numkeys key [key...] arg [arg...]<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>script</td><td>脚本内容</td></tr><tr><td>numkeys</td><td>key 的个数（只是 key 的个数和 argv 没有关系）</td></tr><tr><td>key [key…]</td><td>key列表，键名通过全局变量 KEYS 数组，用 1 为基址的形式访问( KEYS[1] ， KEYS[2] ，以此类推)</td></tr><tr><td>arg [arg…]</td><td>参数列表，参数通过全局变量 ARGV 数组，用 1 为基址的形式访问( ARGV[1] ， ARGV[2] ，以此类推)</td></tr></tbody></table><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs zsh">127.0.0.1:6379&gt; <span class="hljs-built_in">eval</span> <span class="hljs-string">&quot;return &#123;KEYS[1], KEYS[2], ARGV[1], ARGV[2], ARGV[3]&#125;&quot;</span> 2 key1 key2 avg1 avg2 avg3<br><span class="hljs-comment">## 输出</span><br>1) <span class="hljs-string">&quot;key1&quot;</span><br>2) <span class="hljs-string">&quot;key2&quot;</span><br>3) <span class="hljs-string">&quot;avg1&quot;</span><br>4) <span class="hljs-string">&quot;avg2&quot;</span><br>5) <span class="hljs-string">&quot;avg3&quot;</span><br></code></pre></td></tr></table></figure><p>还可以通过 <strong>script load</strong> 命令缓存命令，并通过 <strong>evalsha</strong> 命令执行</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs zsh">SCRIPT LOAD script <span class="hljs-comment"># 缓存 lua 脚本</span><br>EVALSHA sha1 numkeys key [key ...] arg [arg ...]  <span class="hljs-comment"># 执行 lua 脚本</span><br></code></pre></td></tr></table></figure><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs zsh">script load <span class="hljs-string">&quot;return &#123;KEYS[1], KEYS[2], ARGV[1], ARGV[2], ARGV[3]&#125;&quot;</span><br><span class="hljs-string">&quot;0e8e5b92bfe818cf5eb29a03465e71bd8ef3e95a&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs zsh">127.0.0.1:6379&gt; evalsha 0e8e5b92bfe818cf5eb29a03465e71bd8ef3e95a 2 hello word arg1 arg2 arg3<br>1) <span class="hljs-string">&quot;hello&quot;</span><br>2) <span class="hljs-string">&quot;word&quot;</span><br>3) <span class="hljs-string">&quot;arg1&quot;</span><br>4) <span class="hljs-string">&quot;arg2&quot;</span><br>5) <span class="hljs-string">&quot;arg3&quot;</span><br></code></pre></td></tr></table></figure><p>几个常用的 redis lua 脚本</p><p>​    分布式锁</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--lock</span><br><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&#x27;setnx&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>]) == <span class="hljs-number">1</span> <span class="hljs-keyword">then</span> redis.call(<span class="hljs-string">&#x27;expire&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">2</span>]) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;true&#x27;</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;false&#x27;</span> <span class="hljs-keyword">end</span><br><span class="hljs-comment">-- unlock</span><br><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>] <span class="hljs-keyword">then</span> redis.call(<span class="hljs-string">&#x27;del&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) <span class="hljs-keyword">end</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;true&#x27;</span><br></code></pre></td></tr></table></figure><p>​    分布式计数器</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&#x27;EXISTS&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> redis.call(<span class="hljs-string">&#x27;GET&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) &gt; ARGV[<span class="hljs-number">1</span>] <span class="hljs-keyword">then</span> redis.call(<span class="hljs-string">&#x27;decr&#x27;</span>, KEYS[<span class="hljs-number">1</span>])  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;true&#x27;</span> <span class="hljs-keyword">else</span>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;false&#x27;</span> <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>随笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发小技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>100w数据插入实现与思考</title>
    <link href="/2021/03/07/100w-data-insert/"/>
    <url>/2021/03/07/100w-data-insert/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这是学习中遇到的一个题目，往一个表中插入100w条数据，看到这个题目的时候人是懵逼的。因为目前公司线上最大的表记录不过100w出头，每次做数据清洗或者数据迁移的时候一个通宵都不一定能跑完，那么插入100w 又怎么会快的起来呢？更何况老师问是否能把性能优化到 10s 之内呢。。</p><h3 id="思维爆炸"><a href="#思维爆炸" class="headerlink" title="思维爆炸"></a>思维爆炸</h3><p>只要思想不滑坡，办法总比方法多。老师既然问了那这个问题肯定是有解的，如果脑暴分析下可以得到下面的一些信息线索。</p><ul><li><p><strong>数据库优化主要分以下三部分</strong></p><ul><li><strong>数据库端参数优化</strong></li><li><strong>sql 优化</strong></li><li><strong>表结构优化</strong></li></ul></li><li><p>影响数据库吞吐量的因素</p><ul><li>单个事务大小</li><li>redolog写入情况和脏页数量</li><li>数据库连接池空闲情况和一些相关的buffer</li><li>索引</li><li>数据库实例性能</li></ul></li><li><p>java 代码的性能因素</p><ul><li>封装越小 速度越快</li><li>多线程</li><li>数据库连接池</li></ul></li><li><p>运行环境因素</p><ul><li>cpu</li><li>io</li><li>system</li></ul></li></ul><p>以上这些是我能想到的一些影响的方面，和可以针对优化的点。本次测试基本上都在我自己的 mbp 上跑，所以<strong>运行环境这个条件变量基本是控制不变</strong>的。</p><p>根据上面的一些因素可以得到一些可行的操作方案</p><ol><li>数据库连接工具执行批量sql</li><li>基本的循环插入</li><li>拼接批量 sql</li><li>使用preparedStatement + queryBatch</li><li>多线程提升性能</li></ol><h3 id="走两步试试"><a href="#走两步试试" class="headerlink" title="走两步试试"></a>走两步试试</h3><h4 id="数据库环境"><a href="#数据库环境" class="headerlink" title="数据库环境"></a>数据库环境</h4><blockquote><p>docker 默认配置 + mysql5.7</p></blockquote><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs zsh">docker pull mysql:5.7<br>docker run --name mysql-test -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7<br></code></pre></td></tr></table></figure><h4 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> tb_order_test_1(<br>`id` <span class="hljs-type">int</span> auto_increment,<br>`good_id` <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;0&#x27;</span>,<br>`user_id` <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;0&#x27;</span>, <br>`good_status` tinyint <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;1&#x27;</span>,<br>`username` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;&#x27;</span>,<br><span class="hljs-keyword">primary</span> key(id)<br>) engine<span class="hljs-operator">=</span>innodb<br></code></pre></td></tr></table></figure><h4 id="数据库连接工具执行批量sql"><a href="#数据库连接工具执行批量sql" class="headerlink" title="数据库连接工具执行批量sql"></a>数据库连接工具执行批量sql</h4><p>从数据库中反向导出数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql">LOCK TABLES `tb_order_test_1` WRITE;<br><span class="hljs-comment">/*!40000 ALTER TABLE `tb_order_test_1` DISABLE KEYS */</span>;<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `tb_order_test_1` (`id`, `good_id`, `user_id`, `good_status`, `username`)<br><span class="hljs-keyword">VALUES</span><br>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;daiwei&#x27;</span>),<br>(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;daiwei&#x27;</span>),<br>(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;daiwei&#x27;</span>),<br>(<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;daiwei&#x27;</span>),<br>(<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;daiwei&#x27;</span>),<br>..... <span class="hljs-number">100</span>w .....<br>(<span class="hljs-number">999997</span>,<span class="hljs-number">999996</span>,<span class="hljs-number">999996</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;daiwei&#x27;</span>),<br>(<span class="hljs-number">999998</span>,<span class="hljs-number">999997</span>,<span class="hljs-number">999997</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;daiwei&#x27;</span>),<br>(<span class="hljs-number">999999</span>,<span class="hljs-number">999998</span>,<span class="hljs-number">999998</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;daiwei&#x27;</span>),<br>(<span class="hljs-number">1000000</span>,<span class="hljs-number">999999</span>,<span class="hljs-number">999999</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;daiwei&#x27;</span>);<br><br><span class="hljs-comment">/*!40000 ALTER TABLE `tb_order_test_1` ENABLE KEYS */</span>;<br>UNLOCK TABLES;<br></code></pre></td></tr></table></figure><p>这里导出数据可以发现两个问题，首先sql 的存储的文件是批量插入的，其次在操作的过程中，表是锁定状态的。</p><p>最终手动🙈掐表测100w 的数据导入大概需要 7.5 秒。</p><h4 id="基础的循环操作插入操作"><a href="#基础的循环操作插入操作" class="headerlink" title="基础的循环操作插入操作"></a>基础的循环操作插入操作</h4><p>这个最基本最简单的循环插入，明显是不可能会有较高的插入性能的，但是我就是想知道最慢着要多久🤤。这最基本的就不用那些ORM 框架了就直接使用 jdbc 操作了，封装越高速度也就越慢。同时稍微控制下事务，这种不考虑大事务的前提下，减少事务提交，一次提交。大量数据的插入会影响到数据页导致页分裂，也会拖慢整体的时间，所以整个测试过程中，不额外创建索引。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertByLoop</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>  Connection conn = JdbcUtil.getConnFromHikari();<br>  PreparedStatement stat = <span class="hljs-keyword">null</span>;<br>  <span class="hljs-keyword">try</span> &#123;<br>      String sql = <span class="hljs-string">&quot;insert into tb_order_test_1(good_id, user_id, good_status, username) values (?, ?, ?, ?)&quot;</span>;<br>      conn.setAutoCommit(<span class="hljs-keyword">false</span>);<br>      stat = conn.prepareStatement(sql);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3000</span>; i++) &#123;<br>          stat.setLong(<span class="hljs-number">1</span>, i);<br>          stat.setLong(<span class="hljs-number">2</span>, i);<br>          stat.setInt(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>);<br>          stat.setString(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;daiwei&quot;</span>);<br>          stat.execute();<br>        &#125;<br>      conn.commit();<br>    &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>      throwables.printStackTrace();<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>      JdbcUtil.release(conn, stat, <span class="hljs-keyword">null</span>);<br>    &#125;<br>  System.out.println(System.currentTimeMillis() - start);<br>&#125;<br></code></pre></td></tr></table></figure><p>1w条数据插入耗时 24015 ms，插入的数据量和插入时间是线性相关的，所以就不过多的浪费时间了。。。🤨</p><h4 id="jdbc-batch-批处理"><a href="#jdbc-batch-批处理" class="headerlink" title="jdbc batch 批处理"></a>jdbc batch 批处理</h4><p>这个版本的操作相较于上面的一种，最大的提升就是用了批处理操作。在批量插入上性能能有一定的提升，但是提升效果不是很大。1w 数据量 11358ms。<strong>但是这里有一个参数rewriteBatchedStatements=true</strong>，加上这个参数允许将批量处理的 sql 进行重写，来提高批处理性能，相当于魔改了。。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertSqlBatch</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>  Connection conn = JdbcUtil.getConnFromHikari();<br>  PreparedStatement stat = <span class="hljs-keyword">null</span>;<br>  <span class="hljs-keyword">try</span> &#123;<br>      String sql = <span class="hljs-string">&quot;insert into tb_order_test_1(good_id, user_id, good_status, username) values (?, ?, ?, ?)&quot;</span>;<br>      conn.setAutoCommit(<span class="hljs-keyword">false</span>);<br>      stat = conn.prepareStatement(sql);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50000</span>; i++) &#123;<br>          stat.setLong(<span class="hljs-number">1</span>, i);<br>          stat.setLong(<span class="hljs-number">2</span>, i);<br>          stat.setInt(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>);<br>          stat.setString(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;daiwei&quot;</span>);<br>          stat.addBatch();<br>        &#125;<br>      stat.executeBatch();<br>      conn.commit();<br>    &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>      throwables.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      JdbcUtil.release(conn, stat, <span class="hljs-keyword">null</span>);<br>    &#125;<br>  System.out.println(System.currentTimeMillis() - start);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">jdbc.url</span>=<span class="hljs-string">jdbc:mysql://127.0.0.1:3306/test?rewriteBatchedStatements=true</span><br></code></pre></td></tr></table></figure><p>添加参数之后，batch insert 的性能有极大的提高。100w 的数据量 8775ms 就操作完成。</p><h4 id="拼接sql-批处理"><a href="#拼接sql-批处理" class="headerlink" title="拼接sql + 批处理"></a>拼接sql + 批处理</h4><p>在不开启rewriteBatchedStatements = true 的情况下，如果我自己手动拼接sql 减少 jdbc 的封装，速度是否能在往上提升呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertByBatch</span><span class="hljs-params">()</span> </span>&#123;<br>  Connection conn = JdbcUtil.getConnFromHikari();<br>    Statement stat = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>    <span class="hljs-keyword">try</span> &#123;<br>      stat = conn.createStatement();<br>      String sql;<br>      StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;insert into tb_order_test_1(good_id, user_id, good_status, username) values&quot;</span>);<br>      conn.setAutoCommit(<span class="hljs-keyword">false</span>);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;<br>              sb.append(<span class="hljs-string">&quot;(&quot;</span> + i +<span class="hljs-string">&quot; , &quot;</span> + j +<span class="hljs-string">&quot;, 1 , &#x27;daiwei&#x27;),&quot;</span>);<br>            &#125;<br>          sql = sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>).toString();<br>          stat.addBatch(sql);<br>          sb.delete(<span class="hljs-number">75</span>, sb.length());<br>        &#125;<br>      stat.executeBatch();<br>      conn.commit();<br>      System.out.println(System.currentTimeMillis() - start);<br>    &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>      throwables.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      JdbcUtil.release(conn, stat, <span class="hljs-keyword">null</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方案跑下来，优化效果还是比较明显的，100w的数据插入的时间大概在 5s ～6s 这个区间。</p><p>这个方案的小缺点是事务分开的整体的数据插入不是原子性的。</p><h4 id="多线程-拼接sql-批处理"><a href="#多线程-拼接sql-批处理" class="headerlink" title="多线程 + 拼接sql + 批处理"></a>多线程 + 拼接sql + 批处理</h4><p>单线程跑下来性能都已经提升这么明显了，那多线程。。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertConcurBatch</span><span class="hljs-params">()</span> </span>&#123;<br>  ExecutorService executor = Executors.newFixedThreadPool(<span class="hljs-number">4</span>);<br>  <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>  CyclicBarrier cyclicBarrier = <span class="hljs-keyword">new</span> CyclicBarrier(<span class="hljs-number">4</span>, () -&gt; &#123;<br>      System.out.println(System.currentTimeMillis() - start);<br>      executor.shutdown();<br>    &#125;);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>      executor.execute(() -&gt; &#123;<br>          insertByBatch(<span class="hljs-number">250</span>);<br>          <span class="hljs-keyword">try</span> &#123;<br>              cyclicBarrier.await();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>              e.printStackTrace();<br>            &#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException e) &#123;<br>              e.printStackTrace();<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertByBatch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>  Connection conn = JdbcUtil.getConnFromHikari();<br>    Statement stat = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>    <span class="hljs-keyword">try</span> &#123;<br>      stat = conn.createStatement();<br>      String sql;<br>      StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;insert into tb_order_test_1(good_id, user_id, good_status, username) values&quot;</span>);<br>      conn.setAutoCommit(<span class="hljs-keyword">false</span>);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;<br>              sb.append(<span class="hljs-string">&quot;(&quot;</span> + i +<span class="hljs-string">&quot; , &quot;</span> + j +<span class="hljs-string">&quot;, 1 , &#x27;daiwei&#x27;),&quot;</span>);<br>            &#125;<br>          sql = sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>).toString();<br>          stat.addBatch(sql);<br>          sb.delete(<span class="hljs-number">75</span>, sb.length());<br>        &#125;<br>      stat.executeBatch();<br>      conn.commit();<br>      System.out.println(System.currentTimeMillis() - start);<br>    &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>      throwables.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      JdbcUtil.release(conn, stat, <span class="hljs-keyword">null</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>果然发挥多线程的性能优势，整体性能优能往上提升一点点。</p><h3 id="泥巴路上走一走"><a href="#泥巴路上走一走" class="headerlink" title="泥巴路上走一走"></a>泥巴路上走一走</h3><p>实际生产环境的话，并不会有几个表只有 几个字段，多是字段20+ ，所以如果字段多上去，插入性能是否会受到影响？如此便有了下面的测试</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `tb_order_test` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `good_id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `user_id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `good_status` tinyint(<span class="hljs-number">4</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;1&#x27;</span>,<br>  `field_4` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_5` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_6` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_7` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_8` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_9` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_10` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_11` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_12` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_13` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_14` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_15` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_16` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_17` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_18` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_19` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_20` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_21` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_22` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_23` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_24` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_25` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_26` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_27` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_28` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_29` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `field_30` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">5214001</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>latin1;<br></code></pre></td></tr></table></figure><p>测试代码的话这里用的还是 多线程 + 拼接sql + 批处理 的 pro 版本，果然这次的测试的速度有很明显的下降 100w 的插入时间 到了 19866ms，我的电脑是 8 核的，本着充分利用系统资源和数据库并发资源的原则。最终的 100w 时间到了 18080ms。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在这个场景中有很多的环境因素：mysql数据库、sql语句和 java代码等多个方面，其中的任何一个部分出现瓶颈，都会拖累整体的性能，但是如果换个角度去看这个问题。如果我们每个部分的性能都能充分发挥整体的性能也相应提高。本次的优化过程从 sql部分，编码技巧到表结构优化去尽可能提升100w数据的插入速度。这里漏了一个角度，就是调整mysql 的参数去优化，在mysql 写入过程中有 WAL 机制，如果这里调大 redolog buf 尽可能少的减少 redolog 的 刷脏页操作，是否也能提升写入的性能呢？🤔，最后下面是本次测试结果表格</p><table><thead><tr><th>插入方式</th><th>1w</th><th>10w</th><th>100W</th></tr></thead><tbody><tr><td>数据库工具导入</td><td>-</td><td>-</td><td>7500ms</td></tr><tr><td>单个事务循环插入</td><td>24015ms</td><td>-</td><td>-</td></tr><tr><td>单个事务batch批处理</td><td>11358ms</td><td>-</td><td>-</td></tr><tr><td>魔改 batch <br />（rewriteBatchedStatements）</td><td>689ms</td><td>1562ms</td><td>8775ms</td></tr><tr><td>拼接sql + 批处理</td><td>105ms</td><td>992ms</td><td>5302ms</td></tr><tr><td>多线程 + 拼接sql + 批处理</td><td>-</td><td>-</td><td>4314ms</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>随笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>jdbc</tag>
      
      <tag>实操</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
