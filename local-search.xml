<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>leetcodes 习题汇总</title>
    <link href="/2021/03/28/leetcodes/"/>
    <url>/2021/03/28/leetcodes/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-习题汇总"><a href="#LeetCode-习题汇总" class="headerlink" title="LeetCode 习题汇总"></a>LeetCode 习题汇总</h2><h5 id="数组、链表"><a href="#数组、链表" class="headerlink" title="数组、链表"></a>数组、链表</h5><ol><li><a href="https://leetcode-cn.com/problems/container-with-most-water/">盛水最多的容器</a></li><li><a href="https://leetcode-cn.com/problems/move-zeroes/">移动零</a></li><li><a href="https://leetcode-cn.com/problems/climbing-stairs/">爬楼梯</a></li><li><a href="https://leetcode-cn.com/problems/two-sum/">两数之和</a></li><li><a href="https://leetcode-cn.com/problems/3sum/">三数之和</a></li><li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">删除排序数组中的重复项</a></li><li><a href="https://leetcode-cn.com/problems/rotate-array/">旋转数组</a></li><li><a href="https://leetcode-cn.com/problems/reverse-linked-list/">反转链表</a></li><li><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">两两交换链表中的节点</a></li><li><a href="https://leetcode-cn.com/problems/linked-list-cycle/">环形链表</a></li><li><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">环形链表2</a></li><li><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">K 个一组翻转链表</a></li><li><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">合并两个有序链表</a></li></ol><h5 id="栈、队列、优先队列、双端队列"><a href="#栈、队列、优先队列、双端队列" class="headerlink" title="栈、队列、优先队列、双端队列"></a>栈、队列、优先队列、双端队列</h5><ol><li><a href="https://leetcode-cn.com/problems/valid-parentheses/">有效的括号</a></li><li><a href="https://leetcode-cn.com/problems/min-stack/">最小栈</a></li><li><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">柱状图中的最大矩形</a></li><li><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">滑动窗口最大值</a></li><li><a href="https://leetcode-cn.com/problems/trapping-rain-water/">接雨水</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每天一个开发小技巧</title>
    <link href="/2021/03/11/daily-tips/"/>
    <url>/2021/03/11/daily-tips/</url>
    
    <content type="html"><![CDATA[<h2 id="尬聊"><a href="#尬聊" class="headerlink" title="尬聊"></a>尬聊</h2><p>在日常开发中，不免会遇到自己不熟悉的地方，但是很多时候我们查完用完然后就是技能归还。如果能在这里记录整理收集，那也是一笔宝贵的知识力量。可能有的小技巧并没有太多的实用价值，也有可能有一些奇奇怪怪的奇技淫巧，但这些代码里的精彩的碎片。日拱一卒，积少成多，相信时间的力量。</p><h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><ul><li>Mac校验文件SHA</li></ul><div class="code-wrapper"><pre><code class="hljs zsh">shasum -a 256 <span class="hljs-variable">$&#123;file&#125;</span></code></pre></div><ul><li><a href="https://jaywcjlove.gitee.io/linux-command/c/tcpdump.html">Linux 命令行抓包</a></li></ul><div class="code-wrapper"><pre><code class="hljs zsh">tcpdump -D <span class="hljs-comment"># 当前可以监听的网卡</span></code></pre></div><ul><li>git tag 重命名</li></ul><div class="code-wrapper"><pre><code class="hljs zsh">daiwei@daiweideMacBook-Pro ~ % git tag [new_name] [old_name]  <span class="hljs-comment"># 复制原有的tag</span>daiwei@daiweideMacBook-Pro ~ % git tag -d [old_name] <span class="hljs-comment"># 删除原有tag</span>daiwei@daiweideMacBook-Pro ~ % git push origin :refs/tag/v1.0 <span class="hljs-comment"># 删除远程 tag</span>daiwei@daiweideMacBook-Pro ~ % git push --tag <span class="hljs-comment">#推送本地新的tag</span></code></pre></div><ul><li>reflections 反射工具包，内置反射相关操作，简化开发</li></ul><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.reflections<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>reflections<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><ul><li>不使用 springboot-parent 创建 springboot 项目，方便清晰系统整体继承结构。只需要在依赖的父pom 的 dependencyManagement 中添加 spring-boot-dependencies 依赖即可。</li></ul><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;springboot.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><ul><li><p>三个有意思的在线的 playgroud </p><ul><li><p>redis 在线的web shell <a href="https://try.redis.io/">try redis</a> ，可以执行一些 redis cmds。</p></li><li><p>docker 的在线 <a href="https://labs.play-with-docker.com/">docker lab</a>，登录后提供一个时长四个小时的 session，过期需要重新登录，登录需要 docker hub 的账号，在 session 中可以操作多个docker实例，正如这个 lab 的名字一样～paly with docker。</p></li><li><p>git 在线学习网站 <a href="https://learngitbranching.js.org/?locale=zh_CN">learn-git-branch</a>，在这个网站通过完成一个个任务学习命令操作可视化的git节点到达学习 git 的目的，就很nice～</p></li></ul></li><li><p>.gitignore 文件不生效的问题，清理 git 的本地的缓存，然后重新 add commit 就可以了</p></li></ul><div class="code-wrapper"><pre><code class="hljs zsh">daiwei@daiweideMacBook-Pro ~ % git rm -r --cached .daiwei@daiweideMacBook-Pro ~ % git add .daiwei@daiweideMacBook-Pro ~ % git commit -m<span class="hljs-string">&#x27;update msg&#x27;</span>daiwei@daiweideMacBook-Pro ~ % git push origin main</code></pre></div><ul><li><p>linux 查看端口，每次都要查，每次都记不住😫</p><p>netstat 命令 用于查看 tcp 和 udp 的端口占用情况</p><ul><li>-t (tcp) 仅仅显示 tcp 相关</li><li>-u(udp) 仅仅显示 udp 相关</li><li>-n 拒绝显示别名，能显示数字的全部转化为数字</li><li>-l 仅列出在Listen(监听)的服务状态</li><li>-p 显示建立相关链接的程序名</li></ul><p>所以我全都要 所以命令就是 -nptul (牛批吐了)😏</p><div class="code-wrapper"><pre><code class="hljs zsh">netstat -nptul | grep &lt;port&gt;</code></pre></div><p> <strong>注意这个命令 mac 上就是另外一套参数了，mac 上可以使用 lsof - i:port</strong></p></li><li><p>redis 中 lua 脚本的编写的基本方法</p><p>从 redis 2.6.0 开始内置支持 lua 脚本，可以通过 lua 脚本实现执行多条命令的原子性，典型的使用场景有 分布式锁 和 分布式扣减等。基本的操作命令如下</p><div class="code-wrapper"><pre><code class="hljs zsh">127.0.0.1:6379&gt; EVAL script numkeys key [key...] arg [arg...]</code></pre></div><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>script</td><td>脚本内容</td></tr><tr><td>numkeys</td><td>key 的个数（只是 key 的个数和 argv 没有关系）</td></tr><tr><td>key [key…]</td><td>key列表，键名通过全局变量 KEYS 数组，用 1 为基址的形式访问( KEYS[1] ， KEYS[2] ，以此类推)</td></tr><tr><td>arg [arg…]</td><td>参数列表，参数通过全局变量 ARGV 数组，用 1 为基址的形式访问( ARGV[1] ， ARGV[2] ，以此类推)</td></tr></tbody></table><div class="code-wrapper"><pre><code class="hljs zsh">127.0.0.1:6379&gt; <span class="hljs-built_in">eval</span> <span class="hljs-string">&quot;return &#123;KEYS[1], KEYS[2], ARGV[1], ARGV[2], ARGV[3]&#125;&quot;</span> 2 key1 key2 avg1 avg2 avg3<span class="hljs-comment">## 输出</span>1) <span class="hljs-string">&quot;key1&quot;</span>2) <span class="hljs-string">&quot;key2&quot;</span>3) <span class="hljs-string">&quot;avg1&quot;</span>4) <span class="hljs-string">&quot;avg2&quot;</span>5) <span class="hljs-string">&quot;avg3&quot;</span></code></pre></div><p>还可以通过 <strong>script load</strong> 命令缓存命令，并通过 <strong>evalsha</strong> 命令执行</p><div class="code-wrapper"><pre><code class="hljs zsh">SCRIPT LOAD script <span class="hljs-comment"># 缓存 lua 脚本</span>EVALSHA sha1 numkeys key [key ...] arg [arg ...]  <span class="hljs-comment"># 执行 lua 脚本</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs zsh">script load <span class="hljs-string">&quot;return &#123;KEYS[1], KEYS[2], ARGV[1], ARGV[2], ARGV[3]&#125;&quot;</span><span class="hljs-string">&quot;0e8e5b92bfe818cf5eb29a03465e71bd8ef3e95a&quot;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs zsh">127.0.0.1:6379&gt; evalsha 0e8e5b92bfe818cf5eb29a03465e71bd8ef3e95a 2 hello word arg1 arg2 arg31) <span class="hljs-string">&quot;hello&quot;</span>2) <span class="hljs-string">&quot;word&quot;</span>3) <span class="hljs-string">&quot;arg1&quot;</span>4) <span class="hljs-string">&quot;arg2&quot;</span>5) <span class="hljs-string">&quot;arg3&quot;</span></code></pre></div><p>几个常用的 redis lua 脚本</p><p>​    分布式锁</p><div class="code-wrapper"><pre><code class="hljs lua"><span class="hljs-comment">--lock</span><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&#x27;setnx&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>]) == <span class="hljs-number">1</span> <span class="hljs-keyword">then</span> redis.call(<span class="hljs-string">&#x27;expire&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">2</span>]) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;true&#x27;</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;false&#x27;</span> <span class="hljs-keyword">end</span><span class="hljs-comment">-- unlock</span><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>] <span class="hljs-keyword">then</span> redis.call(<span class="hljs-string">&#x27;del&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) <span class="hljs-keyword">end</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;true&#x27;</span></code></pre></div><p>​    分布式计数器</p><div class="code-wrapper"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&#x27;EXISTS&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> redis.call(<span class="hljs-string">&#x27;GET&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) &gt; ARGV[<span class="hljs-number">1</span>] <span class="hljs-keyword">then</span> redis.call(<span class="hljs-string">&#x27;decr&#x27;</span>, KEYS[<span class="hljs-number">1</span>])  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;true&#x27;</span> <span class="hljs-keyword">else</span>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;false&#x27;</span> <span class="hljs-keyword">end</span></code></pre></div></li></ul>]]></content>
    
    
    <categories>
      
      <category>随笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发小技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>100w数据插入实现与思考</title>
    <link href="/2021/03/07/100w-data-insert/"/>
    <url>/2021/03/07/100w-data-insert/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这是学习中遇到的一个题目，往一个表中插入100w条数据，看到这个题目的时候人是懵逼的。因为目前公司线上最大的表记录不过100w出头，每次做数据清洗或者数据迁移的时候一个通宵都不一定能跑完，那么插入100w 又怎么会快的起来呢？更何况老师问是否能把性能优化到 10s 之内呢。。</p><h3 id="思维爆炸"><a href="#思维爆炸" class="headerlink" title="思维爆炸"></a>思维爆炸</h3><p>只要思想不滑坡，办法总比方法多。老师既然问了那这个问题肯定是有解的，如果脑暴分析下可以得到下面的一些信息线索。</p><ul><li><p><strong>数据库优化主要分以下三部分</strong></p><ul><li><strong>数据库端参数优化</strong></li><li><strong>sql 优化</strong></li><li><strong>表结构优化</strong></li></ul></li><li><p>影响数据库吞吐量的因素</p><ul><li>单个事务大小</li><li>redolog写入情况和脏页数量</li><li>数据库连接池空闲情况和一些相关的buffer</li><li>索引</li><li>数据库实例性能</li></ul></li><li><p>java 代码的性能因素</p><ul><li>封装越小 速度越快</li><li>多线程</li><li>数据库连接池</li></ul></li><li><p>运行环境因素</p><ul><li>cpu</li><li>io</li><li>system</li></ul></li></ul><p>以上这些是我能想到的一些影响的方面，和可以针对优化的点。本次测试基本上都在我自己的 mbp 上跑，所以<strong>运行环境这个条件变量基本是控制不变</strong>的。</p><p>根据上面的一些因素可以得到一些可行的操作方案</p><ol><li>数据库连接工具执行批量sql</li><li>基本的循环插入</li><li>拼接批量 sql</li><li>使用preparedStatement + queryBatch</li><li>多线程提升性能</li></ol><h3 id="走两步试试"><a href="#走两步试试" class="headerlink" title="走两步试试"></a>走两步试试</h3><h4 id="数据库环境"><a href="#数据库环境" class="headerlink" title="数据库环境"></a>数据库环境</h4><blockquote><p>docker 默认配置 + mysql5.7</p></blockquote><div class="code-wrapper"><pre><code class="hljs zsh">docker pull mysql:5.7docker run --name mysql-test -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7</code></pre></div><h4 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h4><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> tb_order_test_1(`id` <span class="hljs-type">int</span> auto_increment,`good_id` <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;0&#x27;</span>,`user_id` <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;0&#x27;</span>, `good_status` tinyint <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;1&#x27;</span>,`username` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-keyword">primary</span> key(id)) engine<span class="hljs-operator">=</span>innodb</code></pre></div><h4 id="数据库连接工具执行批量sql"><a href="#数据库连接工具执行批量sql" class="headerlink" title="数据库连接工具执行批量sql"></a>数据库连接工具执行批量sql</h4><p>从数据库中反向导出数据</p><div class="code-wrapper"><pre><code class="hljs sql">LOCK TABLES `tb_order_test_1` WRITE;<span class="hljs-comment">/*!40000 ALTER TABLE `tb_order_test_1` DISABLE KEYS */</span>;<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `tb_order_test_1` (`id`, `good_id`, `user_id`, `good_status`, `username`)<span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;daiwei&#x27;</span>),(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;daiwei&#x27;</span>),(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;daiwei&#x27;</span>),(<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;daiwei&#x27;</span>),(<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;daiwei&#x27;</span>),..... <span class="hljs-number">100</span>w .....(<span class="hljs-number">999997</span>,<span class="hljs-number">999996</span>,<span class="hljs-number">999996</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;daiwei&#x27;</span>),(<span class="hljs-number">999998</span>,<span class="hljs-number">999997</span>,<span class="hljs-number">999997</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;daiwei&#x27;</span>),(<span class="hljs-number">999999</span>,<span class="hljs-number">999998</span>,<span class="hljs-number">999998</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;daiwei&#x27;</span>),(<span class="hljs-number">1000000</span>,<span class="hljs-number">999999</span>,<span class="hljs-number">999999</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;daiwei&#x27;</span>);<span class="hljs-comment">/*!40000 ALTER TABLE `tb_order_test_1` ENABLE KEYS */</span>;UNLOCK TABLES;</code></pre></div><p>这里导出数据可以发现两个问题，首先sql 的存储的文件是批量插入的，其次在操作的过程中，表是锁定状态的。</p><p>最终手动🙈掐表测100w 的数据导入大概需要 7.5 秒。</p><h4 id="基础的循环操作插入操作"><a href="#基础的循环操作插入操作" class="headerlink" title="基础的循环操作插入操作"></a>基础的循环操作插入操作</h4><p>这个最基本最简单的循环插入，明显是不可能会有较高的插入性能的，但是我就是想知道最慢着要多久🤤。这最基本的就不用那些ORM 框架了就直接使用 jdbc 操作了，封装越高速度也就越慢。同时稍微控制下事务，这种不考虑大事务的前提下，减少事务提交，一次提交。大量数据的插入会影响到数据页导致页分裂，也会拖慢整体的时间，所以整个测试过程中，不额外创建索引。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertByLoop</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">long</span> start = System.currentTimeMillis();  Connection conn = JdbcUtil.getConnFromHikari();  PreparedStatement stat = <span class="hljs-keyword">null</span>;  <span class="hljs-keyword">try</span> &#123;      String sql = <span class="hljs-string">&quot;insert into tb_order_test_1(good_id, user_id, good_status, username) values (?, ?, ?, ?)&quot;</span>;      conn.setAutoCommit(<span class="hljs-keyword">false</span>);      stat = conn.prepareStatement(sql);      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3000</span>; i++) &#123;          stat.setLong(<span class="hljs-number">1</span>, i);          stat.setLong(<span class="hljs-number">2</span>, i);          stat.setInt(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>);          stat.setString(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;daiwei&quot;</span>);          stat.execute();        &#125;      conn.commit();    &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;      throwables.printStackTrace();    &#125;<span class="hljs-keyword">finally</span> &#123;      JdbcUtil.release(conn, stat, <span class="hljs-keyword">null</span>);    &#125;  System.out.println(System.currentTimeMillis() - start);&#125;</code></pre></div><p>1w条数据插入耗时 24015 ms，插入的数据量和插入时间是线性相关的，所以就不过多的浪费时间了。。。🤨</p><h4 id="jdbc-batch-批处理"><a href="#jdbc-batch-批处理" class="headerlink" title="jdbc batch 批处理"></a>jdbc batch 批处理</h4><p>这个版本的操作相较于上面的一种，最大的提升就是用了批处理操作。在批量插入上性能能有一定的提升，但是提升效果不是很大。1w 数据量 11358ms。<strong>但是这里有一个参数rewriteBatchedStatements=true</strong>，加上这个参数允许将批量处理的 sql 进行重写，来提高批处理性能，相当于魔改了。。。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertSqlBatch</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">long</span> start = System.currentTimeMillis();  Connection conn = JdbcUtil.getConnFromHikari();  PreparedStatement stat = <span class="hljs-keyword">null</span>;  <span class="hljs-keyword">try</span> &#123;      String sql = <span class="hljs-string">&quot;insert into tb_order_test_1(good_id, user_id, good_status, username) values (?, ?, ?, ?)&quot;</span>;      conn.setAutoCommit(<span class="hljs-keyword">false</span>);      stat = conn.prepareStatement(sql);      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50000</span>; i++) &#123;          stat.setLong(<span class="hljs-number">1</span>, i);          stat.setLong(<span class="hljs-number">2</span>, i);          stat.setInt(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>);          stat.setString(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;daiwei&quot;</span>);          stat.addBatch();        &#125;      stat.executeBatch();      conn.commit();    &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;      throwables.printStackTrace();    &#125; <span class="hljs-keyword">finally</span> &#123;      JdbcUtil.release(conn, stat, <span class="hljs-keyword">null</span>);    &#125;  System.out.println(System.currentTimeMillis() - start);&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">jdbc.url</span>=<span class="hljs-string">jdbc:mysql://127.0.0.1:3306/test?rewriteBatchedStatements=true</span></code></pre></div><p>添加参数之后，batch insert 的性能有极大的提高。100w 的数据量 8775ms 就操作完成。</p><h4 id="拼接sql-批处理"><a href="#拼接sql-批处理" class="headerlink" title="拼接sql + 批处理"></a>拼接sql + 批处理</h4><p>在不开启rewriteBatchedStatements = true 的情况下，如果我自己手动拼接sql 减少 jdbc 的封装，速度是否能在往上提升呢？</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertByBatch</span><span class="hljs-params">()</span> </span>&#123;  Connection conn = JdbcUtil.getConnFromHikari();    Statement stat = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">long</span> start = System.currentTimeMillis();    <span class="hljs-keyword">try</span> &#123;      stat = conn.createStatement();      String sql;      StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;insert into tb_order_test_1(good_id, user_id, good_status, username) values&quot;</span>);      conn.setAutoCommit(<span class="hljs-keyword">false</span>);      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;              sb.append(<span class="hljs-string">&quot;(&quot;</span> + i +<span class="hljs-string">&quot; , &quot;</span> + j +<span class="hljs-string">&quot;, 1 , &#x27;daiwei&#x27;),&quot;</span>);            &#125;          sql = sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>).toString();          stat.addBatch(sql);          sb.delete(<span class="hljs-number">75</span>, sb.length());        &#125;      stat.executeBatch();      conn.commit();      System.out.println(System.currentTimeMillis() - start);    &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;      throwables.printStackTrace();    &#125; <span class="hljs-keyword">finally</span> &#123;      JdbcUtil.release(conn, stat, <span class="hljs-keyword">null</span>);    &#125;&#125;</code></pre></div><p>这个方案跑下来，优化效果还是比较明显的，100w的数据插入的时间大概在 5s ～6s 这个区间。</p><p>这个方案的小缺点是事务分开的整体的数据插入不是原子性的。</p><h4 id="多线程-拼接sql-批处理"><a href="#多线程-拼接sql-批处理" class="headerlink" title="多线程 + 拼接sql + 批处理"></a>多线程 + 拼接sql + 批处理</h4><p>单线程跑下来性能都已经提升这么明显了，那多线程。。。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertConcurBatch</span><span class="hljs-params">()</span> </span>&#123;  ExecutorService executor = Executors.newFixedThreadPool(<span class="hljs-number">4</span>);  <span class="hljs-keyword">long</span> start = System.currentTimeMillis();  CyclicBarrier cyclicBarrier = <span class="hljs-keyword">new</span> CyclicBarrier(<span class="hljs-number">4</span>, () -&gt; &#123;      System.out.println(System.currentTimeMillis() - start);      executor.shutdown();    &#125;);  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;      executor.execute(() -&gt; &#123;          insertByBatch(<span class="hljs-number">250</span>);          <span class="hljs-keyword">try</span> &#123;              cyclicBarrier.await();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;              e.printStackTrace();            &#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException e) &#123;              e.printStackTrace();            &#125;        &#125;);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertByBatch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;  Connection conn = JdbcUtil.getConnFromHikari();    Statement stat = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">long</span> start = System.currentTimeMillis();    <span class="hljs-keyword">try</span> &#123;      stat = conn.createStatement();      String sql;      StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;insert into tb_order_test_1(good_id, user_id, good_status, username) values&quot;</span>);      conn.setAutoCommit(<span class="hljs-keyword">false</span>);      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;              sb.append(<span class="hljs-string">&quot;(&quot;</span> + i +<span class="hljs-string">&quot; , &quot;</span> + j +<span class="hljs-string">&quot;, 1 , &#x27;daiwei&#x27;),&quot;</span>);            &#125;          sql = sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>).toString();          stat.addBatch(sql);          sb.delete(<span class="hljs-number">75</span>, sb.length());        &#125;      stat.executeBatch();      conn.commit();      System.out.println(System.currentTimeMillis() - start);    &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;      throwables.printStackTrace();    &#125; <span class="hljs-keyword">finally</span> &#123;      JdbcUtil.release(conn, stat, <span class="hljs-keyword">null</span>);    &#125;&#125;</code></pre></div><p>果然发挥多线程的性能优势，整体性能优能往上提升一点点。</p><h3 id="泥巴路上走一走"><a href="#泥巴路上走一走" class="headerlink" title="泥巴路上走一走"></a>泥巴路上走一走</h3><p>实际生产环境的话，并不会有几个表只有 几个字段，多是字段20+ ，所以如果字段多上去，插入性能是否会受到影响？如此便有了下面的测试</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `tb_order_test` (  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,  `good_id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  `user_id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  `good_status` tinyint(<span class="hljs-number">4</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;1&#x27;</span>,  `field_4` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  `field_5` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  `field_6` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  `field_7` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  `field_8` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  `field_9` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  `field_10` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  `field_11` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  `field_12` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  `field_13` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  `field_14` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  `field_15` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  `field_16` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  `field_17` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  `field_18` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  `field_19` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  `field_20` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  `field_21` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  `field_22` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  `field_23` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  `field_24` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  `field_25` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  `field_26` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  `field_27` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  `field_28` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  `field_29` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  `field_30` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  <span class="hljs-keyword">PRIMARY</span> KEY (`id`)) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">5214001</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>latin1;</code></pre></div><p>测试代码的话这里用的还是 多线程 + 拼接sql + 批处理 的 pro 版本，果然这次的测试的速度有很明显的下降 100w 的插入时间 到了 19866ms，我的电脑是 8 核的，本着充分利用系统资源和数据库并发资源的原则。最终的 100w 时间到了 18080ms。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在这个场景中有很多的环境因素：mysql数据库、sql语句和 java代码等多个方面，其中的任何一个部分出现瓶颈，都会拖累整体的性能，但是如果换个角度去看这个问题。如果我们每个部分的性能都能充分发挥整体的性能也相应提高。本次的优化过程从 sql部分，编码技巧到表结构优化去尽可能提升100w数据的插入速度。这里漏了一个角度，就是调整mysql 的参数去优化，在mysql 写入过程中有 WAL 机制，如果这里调大 redolog buf 尽可能少的减少 redolog 的 刷脏页操作，是否也能提升写入的性能呢？🤔，最后下面是本次测试结果表格</p><table><thead><tr><th>插入方式</th><th>1w</th><th>10w</th><th>100W</th></tr></thead><tbody><tr><td>数据库工具导入</td><td>-</td><td>-</td><td>7500ms</td></tr><tr><td>单个事务循环插入</td><td>24015ms</td><td>-</td><td>-</td></tr><tr><td>单个事务batch批处理</td><td>11358ms</td><td>-</td><td>-</td></tr><tr><td>魔改 batch <br />（rewriteBatchedStatements）</td><td>689ms</td><td>1562ms</td><td>8775ms</td></tr><tr><td>拼接sql + 批处理</td><td>105ms</td><td>992ms</td><td>5302ms</td></tr><tr><td>多线程 + 拼接sql + 批处理</td><td>-</td><td>-</td><td>4314ms</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>随笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>jdbc</tag>
      
      <tag>实操</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
