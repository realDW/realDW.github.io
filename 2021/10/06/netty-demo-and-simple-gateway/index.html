

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/blogFavicon.png">
  <link rel="icon" href="/img/blogFavicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  
    <meta name="description" content="">
  
  <meta name="author" content="Daiwei">
  <meta name="keywords" content="">
  
  <title>Netty实战 — 基础Demo与API网关实战 - Daiwei‘s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.8","typing":{"enable":true,"typeSpeed":100,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Daiwei's blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://gitee.com/realDaiwei/img/raw/master/cici-hung-scx2cls93VM-unsplash.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Netty实战 — 基础Demo与API网关实战">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-10-06 15:09" pubdate>
        2021年10月6日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      9.2k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      40
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Netty实战 — 基础Demo与API网关实战</h1>
            
            <div class="markdown-body">
              <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一小节我们总结了Reactor模型，Netty基于主从Reactor模型设计了自己的模型结构，使得Netty在不同的场景下都有非常亮眼的性能和可用性表现。进入到这一小节，我又想到了那句话”Talk is cheap, show me code”。虽然上一小节我们简单写了一个“快速开始”，但是这对于要达到快速使用Netty进行网络开发的目的还远远不够。在一小节中我们会通过一系列的Demo示例熟悉Netty的开发，从代码中感受他们的特性。最后我们会通过一个简单的聊天加深我们对Netty各个核心组件的理解。最后我们动手设计实践一个API网关，认识网关的功能和结构，同时也进入提升我们使用Netty进行网络开发的熟练度，同时为后续深入源码打下基础。这一小节代码比较多，不要害怕耐心看完并付诸实践，一定会收获满满。</p>
<h1 id="Demo示例"><a href="#Demo示例" class="headerlink" title="Demo示例"></a>Demo示例</h1><p>在这一部分中，我们使用Netty编写几个我们常见的服务类型，其中包括HttpServer和WebSocket服务。我们还会一起编写Netty的idel检测的Demo，它常用于进行服务间心跳包的开发，还会简单实践我们上一小节说到的<code>inboundHandler</code>和<code>outboundHandler</code>，感受他们在代码中的特性。为后续的使用Netty进行API网关的开发实战基础。</p>
<h2 id="Http服务"><a href="#Http服务" class="headerlink" title="Http服务"></a>Http服务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by Daiwei on 2021/9/25</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyHttpServer</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> port = <span class="hljs-number">8001</span>;<br>        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">try</span> &#123;<br>            ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>            bootstrap.group(bossGroup, workerGroup)<br>                    .channel(NioServerSocketChannel.class)<br>                    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">4096</span>)<br>                    .option(ChannelOption.SO_RCVBUF, <span class="hljs-number">32</span> * <span class="hljs-number">1024</span>)<br>                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-keyword">true</span>)<br><span class="hljs-comment">//                    .handler(new LoggingHandler(LogLevel.INFO))</span><br>                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> HttpServerCodec())<br>                                    .addLast(<span class="hljs-keyword">new</span> HttpObjectAggregator(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>))<br>                                    .addLast(<span class="hljs-keyword">new</span> HttpHandler());<br>                        &#125;<br>                    &#125;);<br>            ChannelFuture future = bootstrap.bind(port).sync();<br>            System.out.println(<span class="hljs-string">&quot;server started and listening port &quot;</span>+ port);<br>            future.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Http的ChannelHandler</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        FullHttpRequest request = (FullHttpRequest) msg;<br><span class="hljs-comment">//        System.out.println(request.uri());</span><br>        sndHttpResp(ctx.channel(), <span class="hljs-string">&quot;&#123;\&quot;status\&quot;: 1, \&quot;message\&quot;:\&quot;hello netty\&quot;&#125;&quot;</span>, request);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        cause.printStackTrace();<br>        ctx.channel().close();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回客户端响应</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 当前连接channel</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msg 响应消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request http请求</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sndHttpResp</span><span class="hljs-params">(Channel channel, String msg, FullHttpRequest request)</span> </span>&#123;<br>        DefaultFullHttpResponse response = <span class="hljs-keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, Unpooled.wrappedBuffer(msg.getBytes(StandardCharsets.UTF_8)));<br>        response.headers().set(HttpHeaderNames.CONTENT_TYPE, HttpHeaderValues.APPLICATION_JSON);<br>        response.headers().setInt(HttpHeaderNames.CONTENT_LENGTH, response.content().readableBytes());<br>        <span class="hljs-keyword">if</span> (!HttpUtil.isKeepAlive(request)) &#123;<br>            channel.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);<br>            channel.writeAndFlush(response);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这是一个用Netty实现的HttpServer的实例。在这个例子里，我们可以看到代码分成了两个部分，上面部分是Netty的Server，它的大体的结构和之前的结构都是一致的。在Netty服务的部分，我们要着重关注ChildHandler。在上一小节我们知道ChildHandler是最后执行业务逻辑的地方，对于我们HttpServer来说，<strong>它和其他的TCPServer并没有什么本质的区别，应用层以下都是一样的。只有在编解码的时候要注意Http协议的格式</strong>，所以这里我们看到Netty通过<code>HttpServerCodec</code>和<code>HttpObjectAggregator</code> 的方式对HttpServer的适配。所以从这里我们不难可以拓展思考，我们如果需要自定义协议的话是否可以从这里下手呢？下面的部分是HttpHandler的实现，也是我们处理业务逻辑的地方，这里我们简单的给前端重新返回一个HttpResponse就可以了。</p>
<blockquote>
<p>在这个demo中在每次启动完成服务后的第一次调用都会出现一个内存泄漏的异常</p>
<p>io.netty.util.ResourceLeakDetector reportTracedLeak</p>
<p>严重: LEAK: ByteBuf.release() was not called before it’s garbage-collected. See <a target="_blank" rel="noopener" href="https://netty.io/wiki/reference-counted-objects.html">https://netty.io/wiki/reference-counted-objects.html</a> for more information.</p>
<p>服务一切正常，并且这里的编解码其也都是使用Netty提供的，所以这里为什么会出现这样问题，恐怕只有深入源码才能探其究竟吧🙈</p>
</blockquote>
<p>对比我们使用Socket编写的简单的Http服务，Netty的性能有非常明显的提升。以下是使用wrk压测的结果：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs markdown">-- socket <br>daiwei@daiweideMacBook-Pro ~ % wrk -t10 -c10 -d5s --latency  http://127.0.0.1:8081<br>Running 5s test @ http://127.0.0.1:8081<br>  10 threads and 10 connections<br>  Thread Stats   Avg      Stdev     Max   +/- Stdev<br><span class="hljs-code">    Latency     5.05ms   23.84ms 225.27ms   95.38%</span><br><span class="hljs-code">    Req/Sec     2.43k   719.68     6.96k    87.96%</span><br><span class="hljs-code">  Latency Distribution</span><br><span class="hljs-code">     50%  171.00us</span><br><span class="hljs-code">     75%  194.00us</span><br><span class="hljs-code">     90%  266.00us</span><br><span class="hljs-code">     99%  147.61ms</span><br><span class="hljs-code">  119295 requests in 5.06s, 10.69MB read</span><br><span class="hljs-code">  Socket errors: connect 0, read 118887, write 404, timeout 0</span><br><span class="hljs-code">Requests/sec:  23560.89</span><br><span class="hljs-code">Transfer/sec:      2.11MB</span><br><span class="hljs-code"></span><br><span class="hljs-code">-- Netty</span><br><span class="hljs-code">daiwei@daiweideMacBook-Pro ~ % wrk -t10 -c10 -d5s --latency  http://127.0.0.1:8001</span><br><span class="hljs-code">Running 5s test @ http://127.0.0.1:8001</span><br><span class="hljs-code">  10 threads and 10 connections</span><br><span class="hljs-code">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="hljs-code">    Latency     1.49ms   10.13ms 124.27ms   97.88%</span><br><span class="hljs-code">    Req/Sec    11.07k     4.14k   16.54k    73.95%</span><br><span class="hljs-code">  Latency Distribution</span><br><span class="hljs-code">     50%   71.00us</span><br><span class="hljs-code">     75%   95.00us</span><br><span class="hljs-code">     90%  228.00us</span><br><span class="hljs-code">     99%   63.43ms</span><br><span class="hljs-code">  550359 requests in 5.10s, 69.81MB read</span><br><span class="hljs-code">Requests/sec: 107857.46</span><br><span class="hljs-code">Transfer/sec:     13.68MB</span><br></code></pre></td></tr></table></figure>

<h2 id="WebSocket服务"><a href="#WebSocket服务" class="headerlink" title="WebSocket服务"></a>WebSocket服务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by Daiwei on 2021/9/25</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyWebsocketServer</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> port = <span class="hljs-number">8002</span>;<br>        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">try</span> &#123;<br>            ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>            bootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)<br>                    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>)<br>                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> HttpServerCodec())<br>                                    .addLast(<span class="hljs-keyword">new</span> HttpObjectAggregator(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>))<br>                                    .addLast(<span class="hljs-keyword">new</span> WebSocketServerProtocolHandler(<span class="hljs-string">&quot;/websocket&quot;</span>))<br>                                    .addLast(<span class="hljs-keyword">new</span> MyWebSocketHandler());<br>                        &#125;<br>                    &#125;);<br>            ChannelFuture channelFuture = bootstrap.bind(port).sync();<br>            System.out.println(<span class="hljs-string">&quot;netty websocket server started and listening at port &quot;</span> + port);<br>            channelFuture.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 业务处理的ChannelHandler</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWebSocketHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">TextWebSocketFrame</span>&gt; </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;receive message [&quot;</span>+ msg.text() +<span class="hljs-string">&quot;] from web &quot;</span>);<br>        ctx.channel().writeAndFlush(<span class="hljs-keyword">new</span> TextWebSocketFrame(<span class="hljs-string">&quot;[&quot;</span> + DateFormatUtil.nowStr() + <span class="hljs-string">&quot;]: 服务端收到消息[&quot;</span> + msg.text() + <span class="hljs-string">&quot;]&quot;</span>));<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        cause.printStackTrace();<br>        ctx.channel().close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面这段代码是Netty实现WebSocket的服务端部分，整体结构上和我们前面构建的HttpServer是一致的，不同的地方在于ChildChannel中的handler是不一样的。相较于HttpServer，WebSocket 多了个处理器<code>WebSocketServerProtocolHandler</code>，这个handler从名字就能看出来是一个用于WebSocket协议的handler，构造这个handler需要传入一个字符串，就是我们Socket服务所监听的地址，最后加上我们自己的业务处理器。我们实现的业务处理handler和前面的HttpHandler有一点点不同，这次我们继承的是<code>SimpleChannelInboundHandler</code>，这个类也是<code>channelInboundHandlerAdapter</code>的子类，这个子类特殊的地方在于提供了一个泛型，即为read方法中的message的类型。如果在read方法中进行类型转换也是一样的。当然Websocket光有服务端是远远不够的，我们还需要页面的配合使用。以下是页面的HTML代码。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> socket;</span><br><span class="javascript">    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.WebSocket) &#123;</span><br><span class="javascript">        socket = <span class="hljs-keyword">new</span> WebSocket(<span class="hljs-string">&quot;ws://localhost:8002/websocket&quot;</span>);</span><br><span class="javascript">        socket.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ev</span>) </span>&#123;</span><br><span class="javascript">            <span class="hljs-keyword">var</span> rt = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;respText&#x27;</span>);</span><br><span class="javascript">            rt.value = rt.value + <span class="hljs-string">&quot;\n&quot;</span> + ev.data;</span><br>        &#125;<br><br><span class="javascript">        socket.onopen = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ev</span>) </span>&#123;</span><br><span class="javascript">            <span class="hljs-keyword">var</span> rt = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;respText&#x27;</span>);</span><br><span class="javascript">            rt.value = <span class="hljs-string">&quot;连接开启了&quot;</span>;</span><br>        &#125;<br><br><span class="javascript">        socket.onclose = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ev</span>) </span>&#123;</span><br><span class="javascript">            <span class="hljs-keyword">var</span> rt = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;respText&#x27;</span>);</span><br><span class="javascript">            rt.value = <span class="hljs-string">&quot;连接关闭了&quot;</span>;</span><br>        &#125;<br><span class="javascript">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="javascript">        alter(<span class="hljs-string">&quot;当浏览器不支持 webSocket&quot;</span>);</span><br>    &#125;<br><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">send</span>(<span class="hljs-params">msg</span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">window</span>.socket) &#123;</span><br><span class="javascript">            <span class="hljs-keyword">return</span>;</span><br>        &#125;<br>        if (socket.readyState == WebSocket.OPEN) &#123;<br>            socket.send(msg);<br>        &#125;<br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;message&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 300px; width: 300px;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;发生消息&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;send(this.form.message.value)&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;respText&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 300px; width: 300px;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;清空内容&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;document.getElementById(&#x27;respText&#x27;).value = &#x27;&#x27;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>启动后端服务并使用浏览器打开上面的HTML代码，我们可以得到如下的页面，当我们看到连接开启即表明当前websocket连接已经建立。</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20210925154930.png" srcset="/img/loading.gif"></p>
<p>在左侧的文本框中输入文字并点击发送数据，我们的Netty服务端即可收到消息，并且添加一些内容将消息返回给前端，同时在后端输出结构。</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20210925155653.png" srcset="/img/loading.gif"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">console 输出：<br>netty websocket server started and listening at port 8002<br>receive message [不积跬步，无以至千里。] from web <br></code></pre></td></tr></table></figure>

<h2 id="Idel（空闲）检测"><a href="#Idel（空闲）检测" class="headerlink" title="Idel（空闲）检测"></a>Idel（空闲）检测</h2><p><strong>在网络连接中处于idel(空闲)状态是非常常见的，但是我们经常需要依据idel状态进行一些简单的开发，例如分布式服务中的心跳探活。</strong>服务端和客户端在一定时间没有进行任何的读写请求，就可以认为两个服务之间的连接是空闲的。使用Netty进行idel（空闲）检测是非常方便的。看下面的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by Daiwei on 2021/9/21</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServer</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> port = <span class="hljs-number">8801</span>;<br>        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        EventLoopGroup workGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">try</span> &#123;<br>            ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>            bootstrap.group(bossGroup, workGroup)<br>                    .channel(NioServerSocketChannel.class)<br>                    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">512</span>)<br>                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-keyword">true</span>)<br>                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> IdleStateHandler(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, TimeUnit.SECONDS))<br>                                    .addLast(<span class="hljs-keyword">new</span> HelloHandler());<br>                        &#125;<br>                    &#125;);<br>            ChannelFuture future = bootstrap.bind(port).sync();<br>            System.out.println(<span class="hljs-string">&quot;服务启动完成, 监听端口 http://127.0.0.1:&quot;</span> + port);<br>            future.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            bossGroup.shutdownGracefully();<br>            workGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * helloHandler 处理器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从channel中读数据。执行一些业务操作，或者加入一些hook触发后续业务。</span><br><span class="hljs-comment">     * 同时可以通过channel发送数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx 上下文</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msg 从channel中读到的数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ByteBuf byteBuf = (ByteBuf) msg;<br>        System.out.println(<span class="hljs-string">&quot;message[&quot;</span>+ byteBuf.toString(StandardCharsets.UTF_8) +<span class="hljs-string">&quot;] received！and &quot;</span> +<br>                <span class="hljs-string">&quot;message is from [&quot;</span> + ctx.channel().remoteAddress().toString() + <span class="hljs-string">&quot;]&quot;</span>);<br>        ByteBuf toClientMsg = Unpooled.copiedBuffer( <span class="hljs-string">&quot;hello!&quot;</span>.getBytes(StandardCharsets.UTF_8));<br>        ctx.channel().writeAndFlush(toClientMsg);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 事件触发方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx 上下文</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> evt 事件</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext ctx, Object evt)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">if</span> (evt <span class="hljs-keyword">instanceof</span> IdleStateEvent) &#123;<br>            IdleStateEvent event = (IdleStateEvent) evt;<br>            IdleState state = event.state();<br>            System.out.println(state.toString());<br>            <span class="hljs-keyword">if</span> (IdleState.ALL_IDLE.equals(state)) &#123;<br>                System.out.println(<span class="hljs-string">&quot;all idle and close channel&quot;</span>);<br>                ctx.channel().close();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在处理过程中捕捉到了异常执行这个方法，输出异常，关闭资源</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx 上下文</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cause 异常信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ctx.close();<br>        cause.printStackTrace();<br>        <span class="hljs-keyword">super</span>.exceptionCaught(ctx, cause);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个例子是Netty入门那小节快速开始的例子改过来的，这里修改了两个地方。第一个地方是在childHandler 中添加了<code>new IdleStateHandler(2, 5, 8, TimeUnit.SECONDS)</code>，这是连接空闲检测的Handler，其中入参<code>2</code>表示当读空闲超过2秒触发一次读空闲的idel事件，<code>5</code>表示写空闲超过5秒触发一次写空闲的idel事件，<code>8</code>表示读和写同时空闲超过8秒触发一次读写空闲事件。事件触发方法写位于IdleStateHandler后面的HelloHandler的中，即上面这段代码的<code>userEventTriggered</code>方法中。在这段代码中，如果是IdelStatEvent（连接空闲事件）输出他们的事件类型，并最后判断如果是读写空闲则关闭空闲连接。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown">console 输出～<br><br>服务启动完成, 监听端口 http://127.0.0.1:8801<br>message[hello server!] received！and message is from [/127.0.0.1:49529]<br>READER<span class="hljs-emphasis">_IDLE</span><br><span class="hljs-emphasis">READER_</span>IDLE<br>WRITER<span class="hljs-emphasis">_IDLE</span><br><span class="hljs-emphasis">READER_</span>IDLE<br>ALL<span class="hljs-emphasis">_IDLE</span><br><span class="hljs-emphasis">all idle and close channel</span><br></code></pre></td></tr></table></figure>

<h2 id="自定义编解码"><a href="#自定义编解码" class="headerlink" title="自定义编解码"></a>自定义编解码</h2><p>我们前面介绍了<strong>ChannelPipeline提供了一个容器，在这个容器内包含很多的ChannelHandler</strong>，这些ChannelHandler提供了一个API调用链。ChannelPipeline管理这沿着链入站和出站的事件流动。下面是Netty ChannelPipline的Doc文档说明，这个图很形象的描述了ChannelPipline的作用。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs sh">                                             I/O Request<br>                                          via Channel or<br>                                      ChannelHandlerContext<br>                                                    |<br>+---------------------------------------------------+---------------+<br>|                           ChannelPipeline         |               |<br>|                                                  \|/              |<br>|    +---------------------+            +-----------+----------+    |<br>|    | Inbound Handler  N  |            | Outbound Handler  1  |    |<br>|    +----------+----------+            +-----------+----------+    |<br>|              /|\                                  |               |<br>|               |                                  \|/              |<br>|    +----------+----------+            +-----------+----------+    |<br>|    | Inbound Handler N-1 |            | Outbound Handler  2  |    |<br>|    +----------+----------+            +-----------+----------+    |<br>|              /|\                                  .               |<br>|               .                                   .               |<br>| ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()|<br>|        [ method call]                       [method call]         |<br>|               .                                   .               |<br>|               .                                  \|/              |<br>|    +----------+----------+            +-----------+----------+    |<br>|    | Inbound Handler  2  |            | Outbound Handler M-1 |    |<br>|    +----------+----------+            +-----------+----------+    |<br>|              /|\                                  |               |<br>|               |                                  \|/              |<br>|    +----------+----------+            +-----------+----------+    |<br>|    | Inbound Handler  1  |            | Outbound Handler  M  |    |<br>|    +----------+----------+            +-----------+----------+    |<br>|              /|\                                  |               |<br>+---------------+-----------------------------------+---------------+<br>                |                                  \|/<br>+---------------+-----------------------------------+---------------+<br>|               |                                   |               |<br>|       [ Socket.read() ]                    [ Socket.write() ]     |<br>|                                                                   |<br>|  Netty Internal I/O Threads (Transport Implementation)            |<br>+-------------------------------------------------------------------+<br></code></pre></td></tr></table></figure>

<p>入站事件自下而上的入站程序即<code>inBoundHandler</code>处理，出站事件则有出站程序<code>outBoundHandler</code>处理，<strong>在Netty中每个Channel都有且仅有一个ChannelPipeline与之对应。</strong>在实际开发中，我们的inBound和outBound就像是一个“大的切面包裹着”实际的业务处理过程。<strong>我们可以通过增加handler的方式增加功能</strong>，就像前面一个Demo我们把IdleStateHandler加入到ChannelPipeline中添加一个idel检测功能一样。当然这个包裹在实际业务前后的主要还是编解码操作，就像我们前面编写Http的服务端和WebSocket的服务端一样。他们都在ChannelPipleline中添加了<code>HttpServerCodec</code>或<code>WebSocketServerProtocolHandler</code>来支持Http服务或WebSocket服务。同理，我们也可以编写我们自己的编解码器实现自定义协议的效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 编码器</span><br><span class="hljs-comment"> * Created by Daiwei on 2021/4/12</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyEncoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToByteEncoder</span>&lt;<span class="hljs-title">Object</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class&lt;?&gt; clazz;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RpcSerializer serializer;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NettyEncoder</span><span class="hljs-params">(Class&lt;?&gt; clazz, RpcSerializer serializer)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.clazz = clazz;<br>        <span class="hljs-keyword">this</span>.serializer = serializer;<br>    &#125;<br><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 2021/4/12 这里可以开发一个可拓展的协议</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ByteBuf out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">if</span> (clazz.isInstance(msg)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">this</span>.serializer.serialize(msg);<br>                out.writeInt(bytes.length);<br>                out.writeBytes(bytes);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                log.error(<span class="hljs-string">&quot;server catch exception!&quot;</span>, e);<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 解码器</span><br><span class="hljs-comment"> * Created by Daiwei on 2021/4/12</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ByteToMessageDecoder</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class&lt;?&gt; clazz;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RpcSerializer serializer;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NettyDecoder</span><span class="hljs-params">(Class&lt;?&gt; clazz, RpcSerializer serializer)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.clazz = clazz;<br>        <span class="hljs-keyword">this</span>.serializer = serializer;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">if</span> (in.readableBytes() &lt; <span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        in.markReaderIndex();<br>        <span class="hljs-keyword">int</span> len = in.readInt();<br>        <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">0</span>) &#123;<br>            ctx.close();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (in.readableBytes() &lt; len) &#123;<br>            in.resetReaderIndex();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[len];<br>        in.readBytes(bytes);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Object msg = serializer.deserialize(bytes, clazz);<br>            out.add(msg);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;server catch exception!&quot;</span>, e);<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这是我之前写的两个编解码器，通过构造方法传入序列化实现实例，实现RCP的编解码逻辑。只要在两个服务之间加入我们自定义的编解码器，就可以实现我们自定义在数据传输过程中的序列化协议，提高数据传输的安全性和可靠性，这也就是我们自定义的协议。</p>
<blockquote>
<p>我们自定义协议还是要解决一个问题就是<strong>TCP的粘包、半包和半粘包</strong>的问题。</p>
<p><strong>什么是TC粘包问题</strong></p>
<p>TCP沾包就是指发送方发送的若干包数据到达接收方时沾成了一包，从接收缓冲区来看，后一包数据的头会紧紧接着前一包数据的尾，出现沾包的原因是多方面的，可能来自发送方，也可能来自接收方。</p>
<p><strong>造成TCP粘包的原因</strong></p>
<ul>
<li><p>发送方原因，TCP默认使用Nagle算法，而Nagle算法主要做两件事：</p>
</li>
<li><ul>
<li>只有上一个分组得到确认，才会发送下一组。</li>
<li>收集多个小分组，在一个确认到来时一起发送。</li>
</ul>
</li>
</ul>
<p>因此Nagle算法造成发送方可能会出现粘包问题。</p>
<ul>
<li>接收方原因，TCP接收的数据包时，并不会马上交到应用层进行处理，或者说是应用层不会立即处理。实际上，TCP将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。这样，如果TCP接收数据到到缓存的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。</li>
</ul>
<p><strong>如何处理粘包问题</strong></p>
<ul>
<li>发送方，对于发送方造成的粘包问题，可以通过关闭Nagle算法来解决，使用TCP_NODELAY选项来关闭算法。</li>
<li>接收方，接收方没有办法来处理粘包现象，只能交给应用层来处理。</li>
</ul>
</blockquote>
<p>应用层读取数据的时候，按照数据的长度一批批读取数据从而解决粘包问题。同时在发送数据的时候，也需要将数据的长度加入到传输的数据中，方便读取的时候切割数据包。Netty通过添加编解码器的方式来很好的解决这个问题。</p>
<blockquote>
<p>⚠️添加编解码器的时候一定要注意要<strong>把它们加到处理逻辑前面</strong>，才能实现“业务处理器前后被包裹”的效果。</p>
</blockquote>
<p>这里还有一个点简单的啰嗦一下，就是InBoundHandler和outBoundHandler，这些Handler都是ChildHandler，也都是ChannelPipeline里面的Handler。ChannelPipeline中提供了双向的Handler链头尾引用分别是<code>head</code>和<code>tail</code>。<strong>然后入站事件从</strong><code>head</code><strong>开始从前向后遍历执行inBoundHandler，而出站事件从</strong><code>tail</code><strong>开始从后向前遍历执行outBoundhandler。</strong></p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20210921211125.png" srcset="/img/loading.gif"></p>
<p>因为两种类型的Handler是在一个调用链上，所以在遍历过程中需要判断是否是当前需要的执行的handler，Netty通过一下非常巧妙的方式实现。我一开始以为是通过一个字段标明，结果并不是，是通过<strong>每个handler实例中的executionMask的数值进行复杂的位运算来实现区分，真的很巧妙。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 一些常量用于计算</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MASK_ONLY_INBOUND =  MASK_CHANNEL_REGISTERED |<br>    MASK_CHANNEL_UNREGISTERED | MASK_CHANNEL_ACTIVE | MASK_CHANNEL_INACTIVE | MASK_CHANNEL_READ |<br>    MASK_CHANNEL_READ_COMPLETE | MASK_USER_EVENT_TRIGGERED | MASK_CHANNEL_WRITABILITY_CHANGED;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MASK_ALL_INBOUND = MASK_EXCEPTION_CAUGHT | MASK_ONLY_INBOUND;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MASK_ONLY_OUTBOUND =  MASK_BIND | MASK_CONNECT | MASK_DISCONNECT |<br>    MASK_CLOSE | MASK_DEREGISTER | MASK_READ | MASK_WRITE | MASK_FLUSH;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MASK_ALL_OUTBOUND = MASK_EXCEPTION_CAUGHT | MASK_ONLY_OUTBOUND;<br><br><span class="hljs-comment">// 循环找到当前需要执行的InboundHandler</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> AbstractChannelHandlerContext <span class="hljs-title">findContextInbound</span><span class="hljs-params">(<span class="hljs-keyword">int</span> mask)</span> </span>&#123;<br>    AbstractChannelHandlerContext ctx = <span class="hljs-keyword">this</span>;<br>    EventExecutor currentExecutor = executor();<br>    <span class="hljs-keyword">do</span> &#123;<br>        ctx = ctx.next;<br>    &#125; <span class="hljs-keyword">while</span> (skipContext(ctx, currentExecutor, mask, MASK_ONLY_INBOUND));<br>    <span class="hljs-keyword">return</span> ctx;<br>&#125;<br><br><span class="hljs-comment">// 是否要跳过</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">skipContext</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    AbstractChannelHandlerContext ctx, EventExecutor currentExecutor, <span class="hljs-keyword">int</span> mask, <span class="hljs-keyword">int</span> onlyMask)</span> </span>&#123;<br>    <span class="hljs-comment">// Ensure we correctly handle MASK_EXCEPTION_CAUGHT which is not included in the MASK_EXCEPTION_CAUGHT</span><br>    <span class="hljs-keyword">return</span> (ctx.executionMask &amp; (onlyMask | mask)) == <span class="hljs-number">0</span> ||<br>        <span class="hljs-comment">// We can only skip if the EventExecutor is the same as otherwise we need to ensure we offload</span><br>        <span class="hljs-comment">// everything to preserve ordering.</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// See https://github.com/netty/netty/issues/10067</span><br>        (ctx.executor() == currentExecutor &amp;&amp; (ctx.executionMask &amp; mask) == <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="API网关实战"><a href="#API网关实战" class="headerlink" title="API网关实战"></a>API网关实战</h1><p>在前面的梳理的内容中我们介绍过网关，它是一个三层的转发设备，往往是一个路由器、三层交换机或是防火墙。它是一个网段的入口和出口，连接这多个网段，如果我们想要访问不在当前网段的服务，数据包就要通过网关的路由转发。那我们今天要介绍的这个网关和那个网关又有一些不一样。我们这个网关是和服务集群有关，在以前的单机时代，我们只需要在服务前面加一个Nginx做一个反向代理，将请求均匀的分配到几个相同的实例上即可。但是在为服务架构中，不同的服务之间服务调用已经变得非常复杂，如果直接把服务接口暴露给客户端势必会有各种各样的问题。<strong>因此我们提供一个特定的微服务，所有的请求通过这个服务再次分派转发给目标的微服务接口</strong>。而这样特定的微服务就是我们的API网关。API网关是微服务架构中的基础组件，位于接入层之下和业务服务层之上。</p>
<h2 id="网关与微服务集群"><a href="#网关与微服务集群" class="headerlink" title="网关与微服务集群"></a>网关与微服务集群</h2><p>如果我们将上面的介绍的网关应用到实际的服务的拓扑图中，就可以得类似于下面的架构图。我们可以为每一个服务实例提供一个网关(Gateway)，也可以为一组服务配置一个，甚至可以为整个服务集群配置一个接入的网关(Gateway)，这样整体系统的复杂度就变得简单起来，集中重复的简单功能也可以放在网关中实现。</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20210927010419.png" srcset="/img/loading.gif"></p>
<p>上面的图展示了一个多层网关的架构，其中一个总的网关接入所有的流量，并分发给不同的子系统，还有二级网关用于做各个子系统的接入。通过网关，我们可以把分布式架构组成一个星型架构，由网关对服务的请求进行路由和分发。</p>
<h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><p>作为一个系统模块的入口和出口，如果要实现对接口服务的管理应该实现一下的一些功能。</p>
<ul>
<li><p><strong>请求路由</strong>，网关作为网络的出入口一定要具有请求路由的功能。对于调用端来说，并不知道真正调用的服务地址，一类服务的地址统一交给网关处理。</p>
</li>
<li><p><strong>服务注册功能</strong>，为了能够代理后面的服务，并把请求路由到正确的位置上，网关应该具备服务注册功能，也就是后端的实例可以将服务注册到网关上。一般来说，注册服务也就是注册提供服务的API接口，网关再通过策略从这些注册的接口中选择一个进行路由调用。</p>
</li>
<li><p><strong>负载均衡</strong>，一个网关可以注册多个服务实例，那么按照什么样的路由策略进行路由请求就是一个需要解决的问题。简单一点的可以直接是轮询或随机。复杂一点的可以设计权重随机等负载策略。</p>
</li>
<li><p><strong>弹力设计</strong>，网关还可以把弹力设计中的那些异步、重试、幂等、流控、熔断、监控等都实现进去。这样，可以像Service Mesh那样，让应用服务只关心自己的业务逻辑而不用考虑控制逻辑（控制面）。</p>
</li>
<li><p><strong>安全方面</strong>，SSL加密及证书管理、Session验证、授权、数据校验，以及黑白名单等。错误处理越高处理位置越靠前越好，所以，网关可以做到一个全站的接入组件来对后端的服务进行保护。当然，网关还可以做更多更有趣的事，比如：灰度发布、API聚合、API编排。</p>
</li>
</ul>
<blockquote>
<p>上面的这些点，简单归纳下可以总结为以下的四个功能点：</p>
<ol>
<li><p><strong>请求接入</strong>，作为所有API接口的服务请求的接入点。</p>
</li>
<li><p><strong>聚合业务</strong>，作为所有后端服务的聚合点。</p>
</li>
<li><p><strong>中介策略</strong>，实现安全、验证、路由、过滤、流控等策略。</p>
</li>
<li><p><strong>统一管理</strong>，对所有API服务和策略进行统一管理。</p>
</li>
</ol>
</blockquote>
<h2 id="设计重点"><a href="#设计重点" class="headerlink" title="设计重点"></a>设计重点</h2><p>网关是我们服务的入口和出口，所有的流量都会经过网关，因此高性能和高可用性很自然而然的成为我们的设计指标。网关的设计应该像许多服务一样，应该可以随着硬件水平的提升，提升整体的服务能力，也就是具有强大的水平拓展能力。我们时常还需要添加一些自己的业务逻辑在网关上，例如常见的一些登录、鉴权、限流等操作。</p>
<ul>
<li><p><strong>高性能</strong>，技术选型设计上，网关不应该也不能成为整个系统的系统瓶颈。对于高性能，最好是使用高性能的编程语言来实现。如C，C++、GO或Java。网关对后端的请求，以及对前端的请求的服务一定要使用异步阻塞的I/O来确保后端延迟不会导致应用程序中出现性能问题。</p>
</li>
<li><p><strong>高可用</strong>，所有的流量和调用都会经过网关，所以网关必须成为一个高可用的组件，它的稳定之间关系到所有服务的稳定，如果一片服务的网关出现故障，将会造成这一片服务的不可用。</p>
</li>
</ul>
<blockquote>
<p> 如果要做到高可用可以从以下几个方向拓展。</p>
<ul>
<li><p><strong>集群化</strong>，服务集群，降低单个服务负载，同时提升服务容错性。</p>
</li>
<li><p><strong>服务化</strong>，网关还需要做到在不间断的情况下修改配置，调整自己配置后，可以快速重启。<strong>或是说通过某些方式可以动态修改配置信息。</strong></p>
</li>
<li><p><strong>持续化</strong>，当某个服务下线后，可以保证流量不会进入到当前的正在下线的服务上。而服务上线后，服务可以快速地分摊整体的负载。</p>
</li>
</ul>
</blockquote>
<ul>
<li><strong>高扩展</strong>，因为网关需要承接所有的业务流量和请求，，所以一定会或多或少有一些业务逻辑。而这些业务逻辑是多变和不确定的，因此我们的服务还需要可拓展，并且能进行二次开发。</li>
</ul>
<h2 id="网关对比"><a href="#网关对比" class="headerlink" title="网关对比"></a>网关对比</h2><p>网关依据不同的功能和关注点也有不同的分类，分为流量网关和业务网关。流量网关顾名思义就是控制流量进入集群的网关，对于一个服务承载的流量是非常大的，但并不是每一个请求都是有效的请求。这个时候我们就需要将无效的请求挡在外面，降低整体服务的压力。而业务网关，顾名思义和业务贴的比较近，是微服务架构中的核心基础设施，主要做一些基础功能的扩展，比如请求转发，协议适配，熔断限流等。他们之间的关系如下图：</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20211005100142.png" srcset="/img/loading.gif"></p>
<h3 id="功能对比"><a href="#功能对比" class="headerlink" title="功能对比"></a>功能对比</h3><p>业务网关的功能更多和应用业务相关来提供更好的服务，而流量关注的更多的是流量负载压力保证服务稳定安全。<strong>流量网关</strong>通常包括下面一些功能：</p>
<ul>
<li><p><strong>全局性流控。</strong></p>
</li>
<li><p><strong>日志统计。</strong></p>
</li>
<li><p><strong>防止SQL注入。</strong></p>
</li>
<li><p><strong>防止Web攻击。</strong></p>
</li>
<li><p><strong>屏蔽工具扫描。</strong></p>
</li>
<li><p><strong>黑白名单。</strong></p>
</li>
<li><p><strong>证书/加解密处理。</strong></p>
</li>
</ul>
<p>流量通常只有一些全局性的API管理策略，从上面的主要功能也不难发现这一点。流量网关总体功能上类似防火墙。Kong就是典型的流量网关。可以看到下面也都是一些流量控制策略，包括一些日志记录，安全、监控等功能。</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20211005115210.png" srcset="/img/loading.gif"></p>
<p><strong>业务网关</strong>通常包含下面的一些功能：</p>
<ul>
<li><p><strong>服务级别流量控制。</strong></p>
</li>
<li><p><strong>服务降级与熔断。</strong></p>
</li>
<li><p><strong>路由与负载均衡、灰度策略。</strong></p>
</li>
<li><p><strong>服务过滤、聚合与发现。</strong></p>
</li>
<li><p><strong>权限验证与参数校验。</strong></p>
</li>
<li><p><strong>多级缓存策略。</strong></p>
</li>
</ul>
<p>业务网关相较于流量网关会更贴近业务，从上面的常包括的功能也能看出来，业务网关更多是和服务相关，有很多应用层需要考虑的事情，就可以依托于业务网关，例如线程模型、协议适配、熔断限流和服务编排等。下面这个就是一个网业务网关的结构。</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20211005101559.png" srcset="/img/loading.gif"></p>
<h3 id="主流网关"><a href="#主流网关" class="headerlink" title="主流网关"></a>主流网关</h3><p>目前常见的开源网关大致按照语言可以分为以下几类：</p>
<ul>
<li><p>Nginx+lua：OpenResty、Kong、Orange、Abtesting gateway等</p>
</li>
<li><p>Java：Zuul/Zuul2、Spring Cloud Gateway、Kaazing KWG、gravitee、shenyu（soul）等。</p>
</li>
<li><p>Go：Janus、fagongzi、Grpc-gateway</p>
</li>
<li><p>Dotnet：Ocelot</p>
</li>
<li><p>NodeJS：Express Gateway、Micro Gateway</p>
</li>
</ul>
<p>目前按照使用数量、成熟度等指标来划分。目前主流的有4个：</p>
<ul>
<li><p>OpenResty</p>
</li>
<li><p>Kong</p>
</li>
<li><p>Zuul/Zuul2</p>
</li>
<li><p>Spring Cloud Gateway</p>
</li>
</ul>
<p>这里我们就不深入梳理了，感兴趣的同学可以找对应项目的社区和文档继续深入学习。</p>
<h2 id="编码实战"><a href="#编码实战" class="headerlink" title="编码实战"></a>编码实战</h2><p>前面我们介绍了关网关的一些知识，这一部分我们将使用Netty实现一个简单的API网关。这个网关的功能包括基础的过滤，路由等功能。整体的功能结构如下图。</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20211005150931.png" srcset="/img/loading.gif"></p>
<p>首先我们创建一个基于Netty的HTTP Server，这个部分在前面的Demo中已经写过很多个了，这里就不过多赘述了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * netty 网关服务</span><br><span class="hljs-comment"> * Created by Daiwei on 2021/1/25</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyGateWayServer</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_PORT = <span class="hljs-number">8888</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> port;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;String&gt; proxyServers;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NettyGateWayServer</span><span class="hljs-params">(Integer port, List&lt;String&gt; proxyServers)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.port = port != <span class="hljs-keyword">null</span> ? port : DEFAULT_PORT;<br>        <span class="hljs-keyword">if</span> (proxyServers == <span class="hljs-keyword">null</span> || proxyServers.size() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;gateway need at least one server instance!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">this</span>.proxyServers = proxyServers;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">2</span>);<br>        EventLoopGroup workGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">4</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>            serverBootstrap.option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>)<br>                    .option(ChannelOption.SO_REUSEADDR, <span class="hljs-keyword">true</span>)<br>                    .option(ChannelOption.SO_RCVBUF, <span class="hljs-number">32</span> * <span class="hljs-number">1024</span>)<br>                    .option(EpollChannelOption.SO_REUSEPORT, <span class="hljs-keyword">true</span>)<br>                    .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)<br>                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-keyword">true</span>);<br>            serverBootstrap.group(bossGroup, workGroup).channel(NioServerSocketChannel.class)<br>                    .handler(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.INFO))<br>                    .childHandler(<span class="hljs-keyword">new</span> MyHttpInitializer(<span class="hljs-keyword">this</span>.proxyServers));<br><br>            ChannelFuture future = serverBootstrap.bind(port).sync();<br>            future.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            bossGroup.shutdownGracefully();<br>            workGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NettyGateWayServer&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;port=&quot;</span> + port +<br>                <span class="hljs-string">&quot;, proxyServers=&quot;</span> + proxyServers +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在前面的Demo中，我们是ChildHandler的实现直接作为内部类的方式直接放在NettyServer中，但是这么我们单独放在一个类文件中，这两种写法没有本质的区别。在这里的实现如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * childHandler 实现</span><br><span class="hljs-comment"> * Created by Daiwei on 2021/1/25</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHttpInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HttpRouterHandler httpRouterHandler;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyHttpInitializer</span><span class="hljs-params">(List&lt;String&gt; proxyServers)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.httpRouterHandler = <span class="hljs-keyword">new</span> HttpRouterHandler(proxyServers);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        HttpFilterChain chain = HttpFilterChain.createDefault().addFilter(<span class="hljs-keyword">new</span> PathCheckFilter())<br>                .addFilter(<span class="hljs-keyword">new</span> HeaderAdderFilter());<br>        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> HttpServerCodec())<br>                .addLast(<span class="hljs-keyword">new</span> HttpObjectAggregator(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>))<br>                .addLast(<span class="hljs-keyword">new</span> HttpFilterHandler(chain)).addLast(httpRouterHandler);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个实现中，提供了一个构造器需要传入一个<code>List&lt;String&gt;</code>即实例的地址列表。然后使用这个地址<code>List</code>创建出一个<code>RouterHandler</code>。通过这个<code>RouterHandler</code>实现不同的请求路由策略。这是一个HttpServer的实现，最后添加了我们两个自定义的Handler，一个是过滤器Handler，另外一个是路由Handler。在下面的<code>initChannel</code>我们还创建了<code>HttpFilterChain</code>即一个过滤链，在这个过滤链中加入我们自定义的过滤器实例。其中过滤链和过滤器实现如下，都非常简单。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by Daiwei on 2021/1/29</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpFilterChain</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;HttpRequestFilter&gt; filters;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">HttpFilterChain</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.filters = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> HttpFilterChain <span class="hljs-title">createDefault</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HttpFilterChain();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> HttpFilterChain <span class="hljs-title">addFilter</span><span class="hljs-params">(HttpRequestFilter filter)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.filters.add(filter);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;HttpRequestFilter&gt; <span class="hljs-title">getFilters</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.filters;<br>    &#125;<br><br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by Daiwei on 2021/1/29</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HttpRequestFilter</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">filter</span><span class="hljs-params">(FullHttpRequest request, ChannelHandlerContext ctx)</span></span>;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by Daiwei on 2021/1/29</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PathCheckFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpRequestFilter</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">filter</span><span class="hljs-params">(FullHttpRequest request, ChannelHandlerContext ctx)</span> </span>&#123;<br>        String uri = request.uri();<br>        <span class="hljs-keyword">return</span> uri.contains(<span class="hljs-string">&quot;hello&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>因为fitler方法会传入<code>FullHttpRequest</code>，我们往往可以在这里完成一些鉴权或是往头中加入一些业务需要的数据，例如下面这个实现。</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vbscript">/**<br> * Created by Daiwei <span class="hljs-keyword">on</span> <span class="hljs-number">2021</span>/<span class="hljs-number">1</span>/<span class="hljs-number">29</span><br> */<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> HeaderAdderFilter implements HttpRequestFilter &#123;<br><br>    @Override<br>    <span class="hljs-keyword">public</span> boolean <span class="hljs-built_in">filter</span>(FullHttpRequest <span class="hljs-built_in">request</span>, ChannelHandlerContext ctx) &#123;<br>        <span class="hljs-built_in">request</span>.headers().<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;daiwei&quot;</span>);<br>        <span class="hljs-built_in">request</span>.headers().<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">25</span>);<br>        <span class="hljs-built_in">request</span>.headers().<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;addr&quot;</span>, <span class="hljs-string">&quot;shanghai&quot;</span>);<br>        return <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在<code>ChannelPipline</code>中我们加入了两个自定义的<code>Handler</code>，其中第一个过滤器handler，第二个是路由handler。这两个handler实现了对请求的过滤和转发。下面的代码是这两个handler的实现代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 过滤器处理器</span><br><span class="hljs-comment"> * Created by Daiwei on 2021/1/25</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpFilterHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HttpFilterChain filterChain;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpFilterHandler</span><span class="hljs-params">(HttpFilterChain filterChain)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.filterChain = filterChain;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        FullHttpRequest fullHttpRequest = (FullHttpRequest) msg;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (doFilter(fullHttpRequest, ctx)) &#123;<br>                ctx.fireChannelRead(msg);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                DefaultFullHttpResponse unAuthResp = HttpNettyHelper.genUnAuthResp();<br>                <span class="hljs-keyword">if</span> (!HttpUtil.isKeepAlive(fullHttpRequest)) &#123;<br>                    ctx.writeAndFlush(unAuthResp).addListener(ChannelFutureListener.CLOSE);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    unAuthResp.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderNames.KEEP_ALIVE);<br>                    ctx.writeAndFlush(unAuthResp);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            ReferenceCountUtil.release(msg);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        cause.printStackTrace();<br>        ctx.close();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 执行过滤链</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(FullHttpRequest request, ChannelHandlerContext ctx)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (HttpRequestFilter filter : <span class="hljs-keyword">this</span>.filterChain.getFilters()) &#123;<br>            <span class="hljs-keyword">if</span> (!filter.filter(request, ctx)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这一段的逻辑也非常简单，<code>channelRead</code>方法读取请求，然后调用过滤链<code>doFilter</code>，如果过滤不通过，直接返回一个校验不通过的响应，如果过滤通过直接拉起调用下一个<code>channelPipline</code>的下一个<code>inboundHandler</code>，即负责路由的handler。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 路由处理器</span><br><span class="hljs-comment"> * Created by Daiwei on 2021/1/25</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpRouterHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HttpRouter router;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CloseableHttpAsyncClient httpClient;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadPoolExecutor executorService;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SUCCESS_CODE = <span class="hljs-number">200</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> NUM_OF_CORE = Runtime.getRuntime().availableProcessors();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> KEEP_ALIVE = <span class="hljs-number">8L</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> QUEUE_SIZE = <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpRouterHandler</span><span class="hljs-params">(List&lt;String&gt; proxyServers)</span> </span>&#123;<br><br><br>        IOReactorConfig ioConfig = IOReactorConfig.custom()<br>                .setConnectTimeout(<span class="hljs-number">1000</span>)<br>                .setSoTimeout(<span class="hljs-number">1000</span>)<br>                .setIoThreadCount(NUM_OF_CORE)<br>                .setRcvBufSize(<span class="hljs-number">32</span> * <span class="hljs-number">1024</span>)<br>                .build();<br><br>        httpClient = HttpAsyncClients.custom().setMaxConnTotal(<span class="hljs-number">40</span>)<br>                .setMaxConnPerRoute(<span class="hljs-number">8</span>).setDefaultIOReactorConfig(ioConfig)<br>                .setKeepAliveStrategy(((httpResponse, httpContext) -&gt; <span class="hljs-number">6000</span>)).build();<br><br>        httpClient.start();<br><br>        <span class="hljs-keyword">this</span>.executorService = <span class="hljs-keyword">new</span> ThreadPoolExecutor(NUM_OF_CORE, NUM_OF_CORE, KEEP_ALIVE, TimeUnit.SECONDS,<br>                <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(QUEUE_SIZE), <span class="hljs-keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());<br>        <span class="hljs-keyword">this</span>.router = <span class="hljs-keyword">new</span> RoundRobinRouter(proxyServers);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        String host = <span class="hljs-keyword">this</span>.router.route();<br>        FullHttpRequest request = (FullHttpRequest) msg;<br>        String url = host + request.uri();<br>        <span class="hljs-keyword">this</span>.executorService.submit(() -&gt; executeAndWrite(request, ctx, url));<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        cause.printStackTrace();<br>        ctx.close();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 调用并返回</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> url</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">executeAndWrite</span><span class="hljs-params">(FullHttpRequest request, ChannelHandlerContext ctx, String url)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> HttpGet httpGet = <span class="hljs-keyword">new</span> HttpGet(url);<br>        httpGet.setHeader(HTTP.CONN_DIRECTIVE, HTTP.CONN_KEEP_ALIVE);<br>        <span class="hljs-keyword">this</span>.httpClient.execute(httpGet, <span class="hljs-keyword">new</span> FutureCallback&lt;HttpResponse&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">completed</span><span class="hljs-params">(HttpResponse httpResponse)</span> </span>&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    writeResp(httpResponse, request, ctx);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">failed</span><span class="hljs-params">(Exception e)</span> </span>&#123;<br>                httpGet.abort();<br>                FullHttpResponse resp = HttpNettyHelper.genFailedResp();<br>                ctx.writeAndFlush(resp);<br>                e.printStackTrace();<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cancelled</span><span class="hljs-params">()</span> </span>&#123;<br>                httpGet.abort();<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeResp</span><span class="hljs-params">(HttpResponse response, FullHttpRequest request, ChannelHandlerContext ctx)</span> </span>&#123;<br>        FullHttpResponse resp = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (response.getStatusLine().getStatusCode() == SUCCESS_CODE) &#123;<br>                <span class="hljs-keyword">byte</span>[] bytes = EntityUtils.toByteArray(response.getEntity());<br>                resp = HttpNettyHelper.genBaseResp(bytes);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                resp = HttpNettyHelper.genFailedResp();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>            resp = HttpNettyHelper.genFailedResp();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (request != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (!HttpUtil.isKeepAlive(request)) &#123;<br>                    ctx.write(resp).addListener(ChannelFutureListener.CLOSE);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    ctx.write(resp);<br>                &#125;<br>            &#125;<br>            ctx.flush();<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个类构造方法里创建一个<code>httpClient</code>用来进行转发操作，并且创建了一个路由器。在读取请求的方法<code>channelRead</code>中，使用路由器路由出下一次的转发的地址。并且进行请求的转发操作。当都到回复请求后，再将响应返回给调用方。整个流程下来，一次请求的过滤和转发就完成了。注意这里的路由规则是<code>RoundRobinRouter</code>即轮询的路由规则。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by Daiwei on 2021/1/29</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoundRobinRouter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpRouter</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger cnt = <span class="hljs-keyword">new</span> AtomicInteger();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RoundRobinRouter</span><span class="hljs-params">(List&lt;String&gt; proxyServers)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(proxyServers);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">route</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.proxyServers.get(cnt.getAndIncrement() % <span class="hljs-keyword">this</span>.proxyServers.size());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我还顺带实现了随机的路由规则。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by Daiwei on 2021/1/29</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomRouter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpRouter</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Random rdn;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RandomRouter</span><span class="hljs-params">(List&lt;String&gt; proxyServers)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(proxyServers);<br>        <span class="hljs-keyword">this</span>.rdn = <span class="hljs-keyword">new</span> Random();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">route</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.proxyServers.get(<span class="hljs-keyword">this</span>.rdn.nextInt(proxyServers.size()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在我们实现的这个路由handler中有一个细节，之前我们提到当一个连接连接上后，Netty都会为这个请求创建一个ChannelPipline。那么这就意味着，每当一个连接连上都会初始化pipline中的handler。对于<code>HttpFilterHandler</code>来说创建开销并不大，但是对于<code>HttpRouterHandler</code>就完全不一样了，在路由handler中，不仅仅需要创建一个<code>HttpClient</code>还需要赋值一个路由（Router），如果每一个请求都要创建这么多东西，那性能的开销就非常的不乐观了。同时我们我们轮询的策略是通过一个<code>AtomicInteger</code>不断的去自增实现的，那么如果每次请求进来都创建一个新的<code>AtomicInteger</code>计数器，这轮询的策略就是有问题的。因此如果我们要现实轮询且避免每次连接创建一个<code>HttpClient</code>，我们可以将它们通过构造方法传入到RouterHandler中，也可以让这个RouterHandler在不同的连接中进行共享。共享的方法很简单，只要在Handler上添加注解<code>@ChannelHandler.Sharable</code>既可以让当前Handler实现在不同的ChannelPipline中共享。当然我建议使用传入的方式来实现，这种方式可以避免不同连接之间资源的共享，减少资源的竞争。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by Daiwei on 2021/1/29</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServerApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> port = <span class="hljs-number">8888</span>;<br>        List&lt;String&gt; serverList = Arrays.asList(<span class="hljs-string">&quot;http://127.0.0.1:8801&quot;</span>, <span class="hljs-string">&quot;http://127.0.0.1:8802&quot;</span>, <span class="hljs-string">&quot;http://127.0.0.1:8803&quot;</span>);<br>        NettyGateWayServer server = <span class="hljs-keyword">new</span> NettyGateWayServer(port, serverList);<br>        System.out.println(<span class="hljs-string">&quot;my gateway is listening at http:127.0.0.1:&quot;</span>+ port + <span class="hljs-string">&quot; for &quot;</span> + server.toString());<br>        <span class="hljs-keyword">try</span> &#123;<br>            server.run();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后这是一个整个项目的main函数，这里的ServerList是写死的，当然我们可以接入注册中心，来实现可用服务列表的动态拉取。以上就是整个简单的API网关的设计与编码。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这一小节我们接着上一小节的Demo，继续深入编写了一些Demo实例，熟悉掌握使用Netty进行网络编程，从代码层面感受Netty的特性。Demo示例中，我们梳理使用Netty编写Http服务、WebSocket服务，都是我们常用用到的Server类型。随后我们通过Idel检测和自定义编解码器的例子，熟悉我们实际开发过程中的一些使用实例。编写完成这些代码示例后，接下来我们开始我们的网关实战，我们先是介绍了网关，已经网关在微服务中扮演的角色。随后我们按照网关的不同类型，将网关分为流量网关和业务网关，以及他们的设计重点和功能侧重点。最后我们动手实战编写一个简单的API网关，分析实现了一个API网关的一些基础功能。在接下来的梳理中，我们将深入Netty的核心组件的源码进行分析，一定非常有意思，加油😏</p>
<h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41047704/article/details/85340311">什么是TCP粘包？怎么解决这个问题</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Courage129/p/14446586.html">亿级流量架构之网关设计思路、常见网关对比</a></li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/NIO%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">NIO与网络编程</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Java%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84%E6%A2%B3%E7%90%86/">Java知识结构梳理</a>
                    
                      <a class="hover-with-bg" href="/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">学习总结</a>
                    
                      <a class="hover-with-bg" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/10/16/netty-source-code-nioEventLoop/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Netty核心组件源码剖析 — NioEventLoop</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/09/22/reactor-model-and-netty-getting-start/">
                        <span class="hidden-mobile">网络编程 — Reactor模型与Netty入门</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
