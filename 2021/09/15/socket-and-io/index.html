

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/blogFavicon.png">
  <link rel="icon" href="/img/blogFavicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  
    <meta name="description" content="">
  
  <meta name="author" content="Daiwei">
  <meta name="keywords" content="">
  
  <title>网络编程 — Socket编程与IO模型 - Daiwei‘s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.8","typing":{"enable":true,"typeSpeed":100,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Daiwei's blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://raw.githubusercontent.com/realDaiwei/image/master/matthijs-van-schuppen-S2Oh-pBpI34-unsplash.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="网络编程 — Socket编程与IO模型">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-09-15 22:35" pubdate>
        2021年9月15日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      25
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">网络编程 — Socket编程与IO模型</h1>
            
            <div class="markdown-body">
              <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面的两小节，我们介绍了网络的基础知识包括一些网络模型和协议。我们常说Talk is cheap, show me code.这一小节我们将解锁Socket网络编程，通过Socket来编写简单一些简单的网络小程序。我很早之前就接触过Socket网络编程，也能写一些简单的程序，但是始终感觉socket离我很遥远，不清楚socket到底是什么以及socket是如何工作的。如果你也有和我一样的疑问，通过这一小节的梳理让我们一起搞懂socket，解锁socket技能点。在编写完socket程序之后，我们还会思考如何提高我们socket网络程序的处理吞吐量连接数，并且引入我们的IO模型，深入理解几种常见的IO模型。</p>
<h1 id="什么是Socket"><a href="#什么是Socket" class="headerlink" title="什么是Socket"></a>什么是Socket</h1><p>Socket这个名字很有意思，在很多书中翻译为套接字，我以前看到套接字总是感觉很陌生难以理解。Socket在英语中是插座，插槽的意思。我们写的Socket虽然是代码，但是可以想象成<strong>我们的服务端和客户端中间有“一根网线并且两头有插座”</strong>。我们的程序只要适配这个插座，两个端之间就可以相互通信了，而这个“插座”就是我们的Socket。Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。这一层加入到我们的网络模型后的效果如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/realDaiwei/image/master/20210909015223.png" srcset="/img/loading.gif"></p>
<p>在上面的图中不难看出Socket接口是位于传输层上方的一个中间层，<strong>通过这个中间层提供的接口，Java应用可以进行网络通信</strong>，这也体现了“socket插座”的字面意思。</p>
<h1 id="代码示例以及调用过程"><a href="#代码示例以及调用过程" class="headerlink" title="代码示例以及调用过程"></a>代码示例以及调用过程</h1><p>我们常说talk is chep，show me code。在这个部分，将使用Socket实现一个HTTP服务器，还会用Scoket实现一个互相通信的Server和Client。从代码的角度看看socket是怎么操作对接上下层，分析在TCP下和UDP下Socket的调用处理逻辑。</p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>以下是使用Socket实现的一个简单的HTTP服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.daiwei.socket.http;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.OutputStream;<br><span class="hljs-keyword">import</span> java.net.ServerSocket;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by Daiwei on 2021/9/9</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpServer</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8081</span>);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            Socket socket = serverSocket.accept();<br>            service(socket);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * socket 处理服务</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> socket </span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(Socket socket)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            String body = <span class="hljs-string">&quot;hello socket&quot;</span>;<br>            StringBuilder response = <span class="hljs-keyword">new</span> StringBuilder();<br>            response.append(<span class="hljs-string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>)<br>                    .append(<span class="hljs-string">&quot;Content-Length: &quot;</span>).append(body.getBytes().length).append(<span class="hljs-string">&quot;\r\n&quot;</span>)<br>                    .append(<span class="hljs-string">&quot;Content-Type: text/plain; charset-utf-8\r\n&quot;</span>)<br>                    .append(<span class="hljs-string">&quot;\r\n&quot;</span>)<br>                    .append(body).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br><br>            OutputStream outputStream = socket.getOutputStream();<br>            outputStream.write(response.toString().getBytes());<br>            outputStream.flush();<br><br>            socket.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用<code>wrk</code>进行简单的压测，可以得到以下的结果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">daiwei@daiweideMacBook-Pro ~ % wrk -t2 -c10 -d10s http://localhost:8081<br>Running 10s <span class="hljs-built_in">test</span> @ http://localhost:8081<br>  2 threads and 10 connections<br>  Thread Stats   Avg      Stdev     Max   +/- Stdev<br>    Latency     2.59ms   14.88ms 213.08ms   96.55%<br>    Req/Sec     9.91k     2.65k   11.99k    87.50%<br>  192565 requests <span class="hljs-keyword">in</span> 10.03s, 16.90MB <span class="hljs-built_in">read</span><br>  Socket errors: connect 0, <span class="hljs-built_in">read</span> 191661, write 903, timeout 0<br>Requests/sec:  19192.30<br>Transfer/sec:      1.68MB<br></code></pre></td></tr></table></figure>

<p>我们还可以使用Socket实现客户端和服务端间简单的通行，以下的代码是客户端client向服务端server连接并发送一段message。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.daiwei.socket.app;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.net.ServerSocket;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by Daiwei on 2021/9/9</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SocketAppServer</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> port = <span class="hljs-number">8888</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(port);<br>            System.out.println(<span class="hljs-string">&quot;server is running and listening at &quot;</span> + port);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                Socket socket = serverSocket.accept();<br>                InputStream is = socket.getInputStream();<br>                BufferedReader bufferedReader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(is));<br>                String res;<br>                <span class="hljs-keyword">while</span> ((res= bufferedReader.readLine()) != <span class="hljs-keyword">null</span>) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;message checked from [&quot;</span> + res + <span class="hljs-string">&quot;]&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">package</span> com.daiwei.socket.app;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.OutputStream;<br><span class="hljs-keyword">import</span> java.io.PrintWriter;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by Daiwei on 2021/9/9</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SocketAppClient</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">200</span>; i++) &#123;<br>            socketSendMsg(<span class="hljs-string">&quot;hello server of &quot;</span> + i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过socket 发送消息到server端</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msg</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">socketSendMsg</span><span class="hljs-params">(String msg)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8888</span>);<br>            OutputStream outputStream = socket.getOutputStream();<br>            PrintWriter printWriter = <span class="hljs-keyword">new</span> PrintWriter(outputStream);<br>            printWriter.write(msg);<br>            printWriter.flush();<br><br>            printWriter.close();<br>            outputStream.close();<br>            socket.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Socket调用过程分析"><a href="#Socket调用过程分析" class="headerlink" title="Socket调用过程分析"></a>Socket调用过程分析</h2><p>在上面的代码中我们也不难发现，socket建立的连接的参数是非常简洁的，客户端只需要提供一个目标主机IP和端口号，服务端则需要提供一个服务监听的端口号即可。socket编程进行是端到端的通行。承接上面的应用层，对接下面的传输层和网络层。针对网络层，socket需要指定是<code>IPv4</code>还是<code>IPv6</code>。分别对应这实现类<code>java.net.Inet4Address</code>和<code>java.net.Inet6Address</code>。我们前面提到过，TCP协议是基于数据流的而UDP是基于数据报的。在socket源码中有以下的一个私有构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Socket</span><span class="hljs-params">(SocketAddress address, SocketAddress localAddr, </span></span><br><span class="hljs-function"><span class="hljs-params">               <span class="hljs-keyword">boolean</span> stream)</span> <span class="hljs-keyword">throws</span> IOException </span><br></code></pre></td></tr></table></figure>

<p>其中当参数stream设置为<code>true</code>时，当前socket使用则是TCP协议，反正则为UDP协议。但是我发现调用这个构造的<strong>未被废弃</strong>的方法stream参数都是true。这就意味着我们创建的socket都是基于TCP的。有两个<strong>废弃了</strong>的构造方法可以传入stream参数指定使用UDP协议。并且在注释中可以发现以下一段说明。</p>
<blockquote>
<p>If UDP socket is used, TCP/IP related socket options will not apply.</p>
<p>Deprecated Use DatagramSocket instead for UDP transport.</p>
<p>-–</p>
<p>如果使用UDP socket被使用，那么TCP/IP有关的一些socket配置参数将不生效，</p>
<p>废弃使用数据报文Socket代替UDP数据传输。</p>
</blockquote>
<h3 id="基于TCP协议的调用过程分析"><a href="#基于TCP协议的调用过程分析" class="headerlink" title="基于TCP协议的调用过程分析"></a>基于TCP协议的调用过程分析</h3><p>两端创建了socket之后，接下来的过程中，TCP和UDP稍有不同。TCP的服务端要监听一个端口，一般是先调用<code>bind()</code>函数，给这个socket赋予一个IP地址和端口。为什么需要端口？当一个数据包到达后，内核要通过TCP头的端口号找到这个数据包所属的应用程序。如果一台机器有多个IP地址，我们可以选择监听所有网卡，也可以监听一个网卡（监听<code>0.0.0.0</code>即可监听所有网卡）。当服务端有了IP和端口号，就可以调用<code>listen()</code>函数进行监听。在TCP的状态图里面，有一个<code>listen</code>状态，当调用这个函数之后，服务端就进入了这个状态。这个时候客户端就可以发起连接。接下来，服务端调用<code>accept()</code>函数，拿出一个已经完成连接进行处理。</p>
<blockquote>
<p>在内核中，为每个socket维护两个队列，一个是已经建立了连接的队列，这时候连接三次握手已经完成，处于<code>establish</code>状态；一个是还没有完全建立连接的队列，这个时候三次握手还没完成，处于<code>syn_rcvd</code>的状态。</p>
</blockquote>
<p>在服务端等待过程中，客户端可以通过<code>connect</code>函数发起连接。先在参数中要明确连接的IP地址和端口号，然后发起三次握手。内核会给客户端分配一个临时的端口。一旦握手成功，服务端的<code>accept</code>就会返回另一个socket。</p>
<blockquote>
<p>用来监听的socket和真正用来传数据的socket是两个，一个叫做<strong>监听socket</strong>，一个叫做<strong>已经连接socket</strong>。</p>
<p>客户端：</p>
<p><code>scoket()</code> -&gt; 创建<code>active_socket_fd</code>（<code>client_socket_fd</code>）</p>
<p><code>bind()</code> -&gt; 把<code>active_socket_fd</code>与<code>ip, port</code>绑定起来。</p>
<p><code>connect()</code> -&gt; <code>client_socket_fd</code>主动请求服务端的<code>listen_socket_fd read()/write()</code> -&gt; 读/写<code>socket io close()</code> -&gt; 关闭<code>socket_fd</code></p>
<p>服务端：</p>
<p><code>socket()</code> -&gt; 创建<code>active_socket_fd</code></p>
<p><code>bind()</code> -&gt; 把<code>active_socket_fd</code>与<code>ip, port</code>绑定起来</p>
<p><code>listen()</code> -&gt;  <code>active_socket_fd</code> -&gt; <code>listen_socket_fd</code> 等待客户端的<code>client_socket_fd</code>来请求连接。</p>
<p><code>accept()</code> -&gt; <code>listen_socket_fd</code> -&gt; <code>connect_socket_fd</code> 把监听socket转变为连接socket，用于建立连接通道的数据读写。</p>
<p><code>read()/write()</code> -&gt; 读/写 <code>socket io close()</code> -&gt; 关闭<code>socket_fd</code></p>
<p>为什么需要两种状态的socket？</p>
<p>现在的网络程序中是C/S结构，一般是客户端主动向服务端请求建立连接。这个过程中，主要涉及两个状态，一个是主动一个是被动的。因此，客户端的socket只用于主动服务端的socket请求建立连接，服务器端的socket一直被动的等待客户端的请求连接就ok了。所以这就解答了为什么需要两种状态的socket，<strong>只有一个方是主动的，另一方是被动的才能完成上述操作，如果双方都是主动或是被动的，就完成不了上面的过程。</strong></p>
</blockquote>
<p>在成功建立连接之后，双方开始通过<code>read()</code>和<code>write()</code>函数来读写数据，就像是往一个文件流里面写东西一样。下面的图就是基于TCP的socket程序函数调用过程。</p>
<p><img src="https://raw.githubusercontent.com/realDaiwei/image/master/20210911133549.png" srcset="/img/loading.gif"></p>
<p><strong>说TCP的socket就是一个文件流，是非常准确的。因为socket在Linux中是以文件的形式存在的。</strong>除此之外，还存在文件描述符。写入和读出，也是通过文件描述符。在内核中，<strong>socket是一个文件，那对应的就有文件描述符</strong>。每一个进程都有一个数据结构<code>task_struct</code>，里面指向一个文件描述符数组。来列出这个进程打开的所有文件的文件描述符。<strong>文件描述符是一个整数，是这个数组的下标</strong>。其中数组的内容是一个指针，值向内核中所有打开的文件的列表，既然是一个文件，就会有一个inode，只不过Socket对应的inode保存在内存中，而不是像真正的文件系统保存在硬盘上。在这个inode中，指向Socket在内核中的Socket结构。在这个结构中，主要有两个队列，<strong>一个是发送队列，一个是接收队列</strong>。在这两个队列里面保存的是一个缓存<strong>sk_buff</strong>。这个里面能看到完整的包结构。</p>
<p><img src="https://raw.githubusercontent.com/realDaiwei/image/master/20210911135127.png" srcset="/img/loading.gif"></p>
<h3 id="基于UDP协议的调用过程分析"><a href="#基于UDP协议的调用过程分析" class="headerlink" title="基于UDP协议的调用过程分析"></a>基于UDP协议的调用过程分析</h3><p>对于UDP来讲，过程有一些不一样。<strong>UDP是没有连接的，所以不需要三次握手</strong>，也就不需要调用 listen 和 connent，但是UDP的交互仍然需要IP和端口号，因而也需要<code>bind</code>操作。UDP是没有维护连接状态的，因而<strong>不需要每队连接都建立一组Socket</strong>，而是只要一个Socket就能够和多个客户端通行。也正是因为没有连接状态，每次通信的时候，都调用<code>sendto</code>和<code>recvfrom</code>，都可以传入IP地址和端口，下图内容就是基于UDP协议的Socket函数调用过程。</p>
<p><img src="https://raw.githubusercontent.com/realDaiwei/image/master/20210911171040.png" srcset="/img/loading.gif"></p>
<h2 id="更多的连接"><a href="#更多的连接" class="headerlink" title="更多的连接"></a>更多的连接</h2><p>在完成上述的调用过程分析之后，我们可以用socket写出一个网络交互的程序了。在我们生产环境中，我们往往要服务要接入很多的服务。在上面的代码中，我们服务端通过<code>accept()</code>监听socket连接，当客户端的socket连接后。双方进行连接服务器处理逻辑然后将结果通过socket写回客户端。这个过程中，服务端只能处理这一个连接，不能处理其他的socket连接，其他的socket连接只能排队等待处理，这样的处理模式很明显是不能满足我们的期望。</p>
<p>在我们尝试提升连接数之前，我们先计算下理论值，也就是最大连接数。系统会使用一个四元组来标识唯一一个TCP连接。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">&#123;本机<span class="hljs-built_in">IP</span>，本机端口PORT : 对端<span class="hljs-built_in">IP</span>，对端端口PORT&#125;<br></code></pre></td></tr></table></figure>

<p>服务器通常固定在某个本地端口上监听，等待客户端的连接请求。因此服务端TCP连接四元组中只有对端IP，也就是客户端的IP和对端的端口。因此<strong>最大TCP连接数=对端IP * 对端端口数</strong>。对IPv4，客户端的IP数最多为2^32。客户端的端口数最多为2^16，也就是服务端单机最大TCP连接数为2^48。这只是理论值，实际上并不会有这么多连接数。其中<strong>最大的限制是文件文件描述符</strong>。我们前面分析过socket都是文件，所以首先要通<code>ulimit</code>配置文件描述符的数量。其次系统内存的限制，按照上面的分析，每个TCP连接都需要<strong>占用一定的内存，内存资源也是有限</strong>的。在有限的资源限制下，连接尽可能多的客户端。我们可以从以下四个方式去优化：</p>
<ul>
<li><strong>多进程方式</strong>，如果监听到有新的请求进来就创建一个子进程，然后将基于已经连接socket交给这个新的进程来处理。</li>
</ul>
<blockquote>
<p>在Linux下，使用fork函数创建子进程。<strong>在父进程的基础上完全拷贝一个子进程</strong>。在Linux内核中，会复制文件描述符列表，也会复制内存空间，还会复制一条记录当前执行到了哪一行程序的进程。在复制完成后，父子进程几乎一摸一样，只是根据fork的返回值来区分是父进程还是子进程。如果返回0则是子进程，其他整数则是父进程。</p>
</blockquote>
<ul>
<li><p><strong>多线程方式</strong>，我们很容易就容易想到使用多线程的方式提升性能。相较于进程来说。线程轻量的多。在linux下，通过pthread_create创建一个线程，也是调用do_fork。不同的是，虽然新的线程在task列表会新创建一项，但是很多资源都是可以共享，比进程方式轻量的多。新的连接可以通过多线程的方式快速处理，从而避免监听线程被阻塞。但是如果是一个台机器要维护1万个连接，就要创建1万个进程或者线程，操作系统是无法承受的，这也就是C10K问题。</p>
</li>
<li><p><strong>IO多路复用，一个线程维护多个socket</strong>，由于socket是文件描述符，某个线程轮训所有的socket都放在一个文件集合fd_set中。调用<code>select</code>函数来监听文件描述符在fd_set对应的卫视都设为1，标识socket可读或可写，从而可以进行读写操作，然后再调用select继续轮训下去。</p>
</li>
<li><p><strong>事件驱动IO</strong>，上面select函数还是存在问题，因为每次socket所在的文件描述符集合中有socket发生变化的时候，都需要通过轮询的方式，也就是需要将全部的项目都过一遍的方式查看进度，这大大影响了一个项目组能支撑的最大项目数量。因为使用select，能够同时查询的项目数量由<code>FD_SETSIZE</code>限制。如果改成事件通知的方式，从原来主动去查询socket的状态到被动通知socket可读或可写，性能将极大提升。也就是我们经常提到的<code>epoll</code>函数。在Linux内核中的实现不是通过轮训的方式，而是通过<strong>注册callback函数的方式</strong>，当某个文件描述符号发生变化的时候，就会主动通知。</p>
</li>
</ul>
<blockquote>
<p>事件驱动IO使得监听Socket数量增加，但是效率不会大幅降低，能同时监听的Socket的数量也非常多，上限就为系统定义的、进程打开的最大文件表述符个数。因而，<strong>epoll被称为解决C10K问题的利器。</strong></p>
</blockquote>
<h1 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h1><p>我们梳理网络的过程中必然会介绍网络模型。因为网络通信也是最常见的输入输出IO之一。在计算机世界中，我们将输入输出过程高度抽象可以描述为这样一个过程，即通过外部条件或数据的输入，然后经过系统的逻辑处理之后产生新的结果并将其输出。IO模型描述的计算机世界输入和输出经过的抽象模型。</p>
<h2 id="五种IO模型概述"><a href="#五种IO模型概述" class="headerlink" title="五种IO模型概述"></a>五种IO模型概述</h2><p>我们熟知的IO有阻塞，非阻塞，同步，异步这几种类型。依据这几种类型我们可以划分出五种IO模型。他们分别为<code>阻塞IO(BIO)</code>、<code>非阻塞IO(NIO)</code>、<code>多路复用IO(multiplexing IO)</code>、<code>信号驱动IO(signal-driven IO)</code>、<code>异步IO(AIO)</code>。每一种IO都有他们的使用场景和优势，以下这张图各个IO和阻塞非阻塞，同步异步之间的关系。</p>
<p><img src="https://raw.githubusercontent.com/realDaiwei/image/master/20210915224859.png" srcset="/img/loading.gif"></p>
<p>我们不难发现这些IO模型中，绝大多数都是同步的，只有异步模型是异步的。在深入梳理每一种IO模型之前，我们要先明确模型中阻塞和同步的定义。</p>
<blockquote>
<p>I/O 操作分为两个部分：</p>
<ol>
<li>数据准备，将数据加载到内核缓存。（数据加载到操作系统）</li>
<li>将内核缓存中的数据数据加载到用户缓存（从操作系统复制到应用中）</li>
</ol>
</blockquote>
<p><img src="https://raw.githubusercontent.com/realDaiwei/image/master/20210915005311.png" srcset="/img/loading.gif"></p>
<p>异步同步的概念描述的是用户线程和内核线程之间的交互方式，而阻塞和非阻塞描述的是用户线程调用内核IO的操作方式。同时只有同步才有阻塞和非阻塞之分。</p>
<p>阻塞IO和非阻塞IO的区别：</p>
<p><strong>第一步发起IO请求是否会被阻塞</strong>，如果阻塞知道完成就是传统的阻塞IO，如果不阻塞那就是非阻塞IO。</p>
<p>同步IO和异步IO的区别：</p>
<p><strong>第二步是否阻塞</strong>，而<strong>操作系统帮你做完IO操作再将结果返回</strong>，那就是异步IO。</p>
<p>我们说的阻塞和非阻塞要分场和范围，从根本上来说阻塞是进程“被休息”，<strong>CPU处理其他进程，而这里的非阻塞IO可以理解为将大的整片时间阻塞分成N多小的阻塞</strong>，进程依然可以获得CPU执行时间，同时CPU也可以处理其他进程。对于Linux来说，阻塞IO还是要比非阻塞IO好，因为<strong>CPU仍然有很大几率因socket没有数据而空转</strong>，从整体机器性能开销上来看这样的浪费更大。所以多路复用IO中的Selector.select() 函数还是阻塞的，因此这里把多路复用IO仍然划分为阻塞IO。</p>
<p><strong>阻塞、非阻塞、多路IO复用，都是同步IO</strong>，异步必定是非阻塞的，所以不存在异步阻塞和异步非阻塞的说法。真正的异步IO需要CPU的深入参与。换句话说，只有用户线程在操作IO的时候根本不用考虑IO的执行全部都交给CPU去完成，而自己只等待一个完成的信号的时候，才是真正的异步IO。所以<strong>拉一个子线程去轮训或使用select、poll、epoll都不是异步。</strong></p>
<h2 id="阻塞IO模型"><a href="#阻塞IO模型" class="headerlink" title="阻塞IO模型"></a>阻塞IO模型</h2><p>阻塞式IO、BIO，一般通过在 while(true) 循环中服务端会调用<code>accept()</code>方法等待接收客户端的连接的方式监听请求，请求一旦接收到一个连接请求，就可以建立通信套接字上进行读写操作，<strong>此时不能再接入其他客户端的操作执行完成</strong>，不过可以通过多线程来支持多个客户端的连接。</p>
<p><img src="https://raw.githubusercontent.com/realDaiwei/image/master/20210913011718.png" srcset="/img/loading.gif"></p>
<p>整个执行过程的时序图如下：</p>
<p><img src="https://raw.githubusercontent.com/realDaiwei/image/master/20210914210845.png" srcset="/img/loading.gif"></p>
<h2 id="非阻塞IO模型"><a href="#非阻塞IO模型" class="headerlink" title="非阻塞IO模型"></a>非阻塞IO模型</h2><p>和阻塞IO类比，内核会立即返回，<strong>返回后获得足够的CPU时间继续做其他的事情</strong>。<strong>用户进程第一阶段不是阻塞的，需要不断的主动循环kernel数据是否准备好;同时第二阶段依旧总是阻塞的</strong>。</p>
<p><img src="https://raw.githubusercontent.com/realDaiwei/image/master/20210914011754.png" srcset="/img/loading.gif"></p>
<p>非阻塞式IO的执行过程时序图如下：</p>
<p><img src="https://raw.githubusercontent.com/realDaiwei/image/master/20210914210701.png" srcset="/img/loading.gif"></p>
<h2 id="多路复用IO模型"><a href="#多路复用IO模型" class="headerlink" title="多路复用IO模型"></a>多路复用IO模型</h2><p>IO多路复用（IO multiplexing），也称事件驱动IO（event-driven IO），就是在<strong>单个线程里同时监控多个套接字</strong>，通过<code>select</code>或<code>poll</code>轮询所负责的所有socket，有数据到达了就通知用户线程。<strong>IO复用同非阻塞IO本质一样，不过利用了新的select系统调用</strong>。由内核来负责本来请求进程应该做的轮询操作。看似比本来的请求进程该做的轮询操作。看似比非阻塞IO还多了一个系统调用开销，不过<strong>因为可以支持多路IO，才算提高了效率</strong>。进程先是阻塞在select/poll上，再是<strong>阻塞在读操作的第二个阶段上。</strong></p>
<p><img src="https://raw.githubusercontent.com/realDaiwei/image/master/20210914210630.png" srcset="/img/loading.gif"></p>
<p>整个执行过程的时序图如下：</p>
<p><img src="https://raw.githubusercontent.com/realDaiwei/image/master/20210914215214.png" srcset="/img/loading.gif"></p>
<blockquote>
<p>select/poll 的几大缺点：</p>
<ol>
<li><p>每次调用select都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时很大。（<strong>拷贝大量fd开销大</strong>）。</p>
</li>
<li><p>每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多的时很大。（<strong>遍历大量fd开销大</strong>）。</p>
</li>
<li><p><strong>select支持的文件描述符(fd)数量太少</strong>，默认1024。</p>
</li>
</ol>
<p>epoll（Linux2.5.44内核中引入，2.6内核正式引入，可被用于代理POSIX select 和 poll系统调用）：</p>
<ol>
<li><p><strong>内核与用户空间共享一块内存</strong>。</p>
</li>
<li><p><strong>通过回调解决遍历问题</strong>。</p>
</li>
<li><p><strong>没有fd限制，可以支撑10w连接</strong>。</p>
</li>
</ol>
<p><strong>可以说select/poll的缺点在epoll上都被优化掉了。</strong></p>
</blockquote>
<h2 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h2><p>信号驱动IO是非阻塞的IO类型，我们梳理了以上的三种IO模型，除了非阻塞IO模型是非阻塞IO除外，其余的都是阻塞IO，但是非阻塞IO并不代表对CPU资源使用友好，尤其当CPU空转时系统开销可能更大，上面介绍的三种IO类型只有使用了epoll的多路复用IO模型对系统开销最为友好。信号驱动IO模型和使用epoll的多路复用IO模型比较相似，其中他们最大的不同点就是I<strong>O执行的数据准备阶段，信号驱动IO不会阻塞用户进程</strong>。如下图所示，当用户进程需要等待数据的时候，会向内核发送一个信号，然后用户进程继续向下执行。当内核中数据准备完成之后，内核向进程发送一个信号，然后<strong>用户进程从内核态拷贝数据到用户态</strong>，整个IO操作流程结束。我们可以看到在<strong>第一阶段线程数据准备阶段应用并没有阻塞，而第二阶段数据拷贝阶段应用被阻塞</strong>，因此信号驱动IO是<strong>同步非阻塞</strong>IO。</p>
<p><img src="https://raw.githubusercontent.com/realDaiwei/image/master/20210915003007.png" srcset="/img/loading.gif"></p>
<h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><p>异步IO真正实现了IO全流程的非阻塞，<strong>用户进程发出系统调用后立即返回，内核等待数据处理完成，内核将数据从内核态拷贝到用户进程缓冲区</strong>，然后发送信号通知用户线程IO操作执行完毕（与SIGIO相比，一个是发送信号告诉用户进程数据准备完毕，一个是IO执行完毕）。其中最为典型的是windows IOCP模型。</p>
<p><img src="https://raw.githubusercontent.com/realDaiwei/image/master/20210915004059.png" srcset="/img/loading.gif"></p>
<p>以上所有的网络模型的梳理与模型示意图，其中在Java中主要使用的有BIO、NIO和多路复用IO。BIO结构简单相较于除AIO以外的其他IO模型只有一次系统调用，在数据库连接等池化IO资源中还是多以BIO为主。Java使用的还是以NIO为主，其中我们后面即将梳理的Netty使用的就是采用epoll模式的多路复用NIO模型。AIO 适用于连接数多且需要长时间连接的场景，再加上AIO系统支持程度有限且底层实现复杂。NIO之前也尝试过AIO，但效果并不是很理想而最终废弃。</p>
<blockquote>
<p>之前在群里看到朋友们发的很有意思的Java IO模型比喻总结：</p>
<p>例子：有一个养鸡的农场，里面养着来自各个农户（Thread）的鸡（Socket），每家农户都在农场中建立了自己的鸡舍（SocketChannel）</p>
<ol>
<li><p>BIO：Block IO，每个农户盯着自己的鸡舍，一旦有鸡下蛋，就去做捡蛋处理；</p>
</li>
<li><p>NIO：No-BlockIO-单Selector，农户们花钱请了一个饲养员（Selector），并告诉饲养员（register）如果哪家的鸡有任何情况（下蛋）均要向这家农户报告（selectkeys）;</p>
</li>
<li><p>NIO：No-BlockIO-多Selector，当农场中的鸡舍(Selector)逐渐增多时，一个饲养员巡视（轮询）一次所需时间就会不断地加长，这样农户知道自己家的鸡有下蛋的情况就会发生较大的延迟。怎么解决呢？没错，多请几个饲养员（多Selector），每个饲养员分配管理鸡舍，这样就可以减轻一个饲养员的工作量，同时农户们可以更快的知晓自己家的鸡是否下蛋了；</p>
</li>
<li><p>Epoll模式：如果采用Epoll方式，农场问题应该如何改进呢？其实就是饲养员不需要再巡视鸡舍，而是听到哪间鸡舍(Selector)的鸡打鸣了（活跃连接），就知道哪家农户的鸡下蛋了；</p>
</li>
<li><p>AIO：AsynchronousI/O,鸡下蛋后，以前的NIO方式要求饲养员通知农户去取蛋，AIO模式出现以后，事情变得更加简单了，取蛋工作由饲养员自己负责，然后取完后，直接通知农户来拿即可，而不需要农户自己到鸡舍去取蛋。</p>
</li>
</ol>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这一小节我们从socket编程开始，介绍了什么socket，socket是我们网络编程的一套接口，位于传输层和应用层之间。socket就像他的中文意思“插座”一样，通过编写适配这个“插座”我们的程序就可以“插入网线”实现网通信功能。随后我们写了几个简单的socket程序Demo，并分析了背后的调用过程，其中socket分两种类型，一种是客户端用的socket，服务端用的socketServer。SocketServer通过bind()方法绑定在某个端口上，并且调用accept()方法等待连接。客户端Socket构造时需要传入一个IP地址和端口号，再调用connect方法连接服务端SocketServer，随后开始数据数据传输。这里要注意服务端负责连接的socket和数据传输的socket是两个socket。通过分析源码我们发现socket基本都是基于TCP的，TCP的socket本质就是一个文件流，所以一个服务有多少个连接和fd（文件描述符）的限制有很大的关系。接下来我们梳理了IO模型，我们先是梳理了阻塞与非阻塞，同步与异步的概念。随后我们引入了五种IO模型，它们分别是阻塞IO（BIO）、非阻塞IO（NIO）、多路复用IO、信号驱动IO和异步IO。其中除了异步IO其他都是同步IO。阻塞IO和多路复用IO是阻塞IO，其他都是非阻塞IO，这里要注意的是多路复用IO是阻塞在selector上的，对于应用进程来说是非阻塞的。最后我们详细梳理了这五种IO模型以及部分的时序图，深入对这五个网络模型的理解。以上就是这一小节的全部内容了，接下来我们将开始梳理Java网络编程的“执牛耳框架”Netty。加油加油，冲冲冲。😏</p>
<h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/liangjf/p/9900928.html">为什么有监听socket和连接socket,为什么产生两个socket</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/9293?cid=100007101">趣谈网络协议</a></p>
</li>
<li><p>java 进阶训练营第四课</p>
</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/NIO%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">NIO与网络编程</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Java%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84%E6%A2%B3%E7%90%86/">Java知识结构梳理</a>
                    
                      <a class="hover-with-bg" href="/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">学习总结</a>
                    
                      <a class="hover-with-bg" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/09/22/reactor-model-and-netty-getting-start/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">网络编程 — Reactor模型与Netty入门</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/09/04/network-basic-2/">
                        <span class="hidden-mobile">网络基础 — 深入理解TCP协议</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
