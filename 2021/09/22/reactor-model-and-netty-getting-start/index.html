

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/blogFavicon.png">
  <link rel="icon" href="/img/blogFavicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  
    <meta name="description" content="">
  
  <meta name="author" content="Daiwei">
  <meta name="keywords" content="">
  
  <title>网络编程 — Reactor模型与Netty入门 - Daiwei‘s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.8","typing":{"enable":true,"typeSpeed":100,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Daiwei's blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://gitee.com/realDaiwei/img/raw/master/LakePinatubo_ZH-CN5947011761_1920x1080.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="网络编程 — Reactor模型与Netty入门">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-09-22 22:05" pubdate>
        2021年9月22日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      24
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">网络编程 — Reactor模型与Netty入门</h1>
            
            <div class="markdown-body">
              <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面我们介绍了网络的基础知识，socket网络编程和IO模型，这一小节我们来入门Netty。对于很多程序员来说，Netty是非常遥远的。很多程序员认为平时的开发过程中基本不会使用到Netty，如果你也是这么认为的那就大错特错了。因为我们虽然不会直接写Netty的代码，但是我们每天都在间接使用Netty，大到我们的RPC框架dubbo、大数据的Hadoop，小到Redis的工具包，几乎所有实现网络通信的框架都是基于Netty实现的。所以学习Netty掌握Netty不论是对于我们来说都是开发网络程序，还是排查网络问题，亦或是框架设计思想上的提升都有莫大的帮助。这一小节我们先从最基本的Netty的结构模型开始，先建立一个Netty的基本的认知，随后我们编写Netty的HelloWorld加深对Netty的一些模块点的理解。我们发车啦～</p>
<h1 id="为什么是Netty"><a href="#为什么是Netty" class="headerlink" title="为什么是Netty"></a>为什么是Netty</h1><p>Netty是目前最流行的由JBOSS提供的一个Java开源NIO框架，Netty提供异步的、事件驱动的网络应用程序框架和工具，用来快速开发高性能、高可靠的网络服务器和客户端程序。</p>
<h2 id="Netty的优点"><a href="#Netty的优点" class="headerlink" title="Netty的优点"></a>Netty的优点</h2><p>Netty提供了相对十分简单易用的API，非常适合网络编程。Netty是完全基于NIO实现的，Netty提供了所有IO操作都是异步非阻塞的，通过<code>Future-Listener</code>机制，用户可以方便的主动获取或者通过通知机制获得IO操作结果。Netty无疑是NIO的老大，它的健壮性、可定制性、可拓展性和强大的功能性能在同类框架中都是首屈一指的。Netty的优点可以总结如下：</p>
<ol>
<li><p><strong>API使用简单，开发门槛低。</strong></p>
</li>
<li><p><strong>功能强大，预置了多种编解码功能，支持多种主流协议。</strong></p>
</li>
<li><p><strong>定制功能强大，可以通过ChannelHandler对通信框架进行灵活地扩展。</strong></p>
</li>
<li><p><strong>性能高，通过与其他业绩主流NIO框架对比，Netty的综合性能最优。</strong></p>
</li>
<li><p><strong>成熟、稳定，Netty修复了已经发现的JDK NIO bug，业务开发人员不需要在开发过程中因为NIO的BUG而烦恼。</strong></p>
</li>
<li><p><strong>社区活跃，版本迭代周期短，发现的bug可以被及时修复，同时，更多的新功能会加入。</strong></p>
</li>
<li><p><strong>经历了大规模的商业应用，质量得到验证。</strong></p>
</li>
</ol>
<blockquote>
<p>高性能的协议服务器的特性：<br><strong>高吞吐、低延迟、低开销、零拷贝、可扩容、松耦合（网络逻辑和业务逻辑分离）、使用方便、可维护性好。</strong></p>
<p>Netty的兼容特性：</p>
<ul>
<li><p>JDK兼容性：</p>
<ul>
<li>Netty 3.x ：JDK5</li>
<li>Netty 4.x ：JDK6</li>
<li>Netty 5.x：已经废弃</li>
</ul>
</li>
<li><p>协议兼容性:</p>
<ul>
<li>兼容大部分通用协议</li>
<li>支持自定义协议</li>
</ul>
</li>
<li><p>基于Netty可实现构建实现众多服务类型，包括但不仅限于：</p>
<ul>
<li>HTTP Server</li>
<li>HTTPS Server</li>
<li>WebSocket Server</li>
<li>TCP Server</li>
<li>UDP Server</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="不尽如人意的NIO"><a href="#不尽如人意的NIO" class="headerlink" title="不尽如人意的NIO"></a>不尽如人意的NIO</h2><p>我们都知道Java有自己实现的nio，同时Netty也是基于Java nio实现的。有的同学可能还是会说，我看socket就挺好，简单原生，我就是喜欢用自己去封装，不用Netty行不行呢？当然是可以的，但是我还是建议你使用Netty进行网络开发，具体的原因那还得从Java nio自身说起。<strong>在JDK1.8的NIO中依然存在一些问题</strong>，这些问题在编写NIO程序时候需要格外注意⚠️：</p>
<ul>
<li><strong>NIO跨平台的兼容性问题</strong>。NIO是底层API，它的实现依赖于操作系统针对IO操作的APIs，所以Java能在所有操作系统中实现统一的接口，并用一致的行为来操作IO是很伟大的。<strong>使用NIO经常发现代码在Linux上正常运行，但在Windows上就会出现问题</strong>。所以编写程序，特别是NIO程序，特别是NIO，需要在程序支持的所有操作系统上进行功能测试，否则你可能会碰到一些莫名其妙的问题。NIO2看起来很理想，但是<strong>NIO2只支持jdk1.7+，若你的程序在Java1.6上运行，则无法使用NIO2</strong>。另外，Java7的NIO2中没有提供DatagramSocket的支持，所以NIO2只支持TCP程序，不支持UDP程序。</li>
<li><strong>NIO对缓冲区的聚合和分散操作可能会导致内存泄漏</strong>。很多Channel的实现支持Gather和Scatter。这个功能允许从多个ByteBuffer中读入或写入，这样做可以有更好的性能。操作系统底层知道如何处理这些写入/读出，并且能以最有效的方式处理。如果要分割的数据在多个不同的ByteBuffer中，使用Gather/Scatter是比较好的方式。</li>
</ul>
<blockquote>
<p>scatter/gather指的在多个缓冲区上实现一个简单的I/O操作，比如从通道中读取数据到多个缓冲区，或从多个缓冲区写入数据到通道；</p>
<ol>
<li>scatter（分散）：指的是<strong>从通道中读取数据分散到多个缓存区Buffer的过程</strong>，该过程会将每个缓存区填满，直至通道中无数据或缓冲区没有空间。</li>
<li>gatter（聚集）：指的是<strong>将多个缓冲区Buffer聚集起来写入到通道的过程</strong>，该过程类似于将多个缓冲区的内容连接起来写入通道。</li>
</ol>
</blockquote>
<ul>
<li><strong>Squashing the famous epoll bug（压碎著名的epoll bug）</strong>，Linux-like OSs的<strong>选择器使用的是epoll-bug也可能会导致无效的状态选择和100%的CPU利用率</strong>。要解决<strong>epoll-bug的唯一方法是回收旧的选择器，将先前注册的通道实例转移到新创建的选择器上</strong>。NIO对epoll问题的解决方案是有限制的，Netty提供了更好的解决方案。</li>
</ul>
<h1 id="Netty-模型介绍"><a href="#Netty-模型介绍" class="headerlink" title="Netty 模型介绍"></a>Netty 模型介绍</h1><p>Netty的线程模型也不是一上来现在的主从Reactor模型，也有一个思考进化的过程。在Doug Lee编写的《Scalable IO in Java》中有很好的表述，说明了整个线程模型的变化过程。学习Netty的线程模型非常推荐去看看英文版本，不论是对加深对Netty线程的理解，还是对逐步的结构设计都有很大的启发作用。</p>
<blockquote>
<p>在介绍之前我们先需要介绍几个基本的概念：</p>
<ul>
<li><p><strong>Channel</strong>，通道，Java NIO中的基础概念，代表一个<strong>打开的连接，可以执行读取/写入IO操作</strong>。Netty对Channel的所有IO操作都是非阻塞的。</p>
</li>
<li><p><strong>ChannelFuture</strong>，Java的Future接口，只能查询操作的完成情况，或者阻塞当前线程等待操作完成。Netty封装一个ChannelFuture接口，我们可以将回调方法传给ChannelFutrue，在操作执行完成时自动执行。</p>
</li>
<li><p><strong>Event &amp; Handler</strong>， <strong>Netty基于事件驱动</strong>，事件和处理器可以关联到入站和出战数据流。</p>
</li>
<li><p><strong>Encoder &amp; Decoder</strong>，处理网络IO时，需要<strong>进行序列化与反序列化</strong>，转换Java对象与字节流。对入站数据进行解码，基类是<code>ByteToMessageDecoder</code>。对出战数据进行编码，基类是<code>MessageToByteEncoder</code>。</p>
</li>
<li><p><strong>ChannelPipeline</strong>，数据处理管道就是<strong>事件处理器链</strong>。有顺序，同一Channel的出战处理器和入站处理器在同一列表中。</p>
</li>
</ul>
</blockquote>
<h2 id="基础模型抽象"><a href="#基础模型抽象" class="headerlink" title="基础模型抽象"></a>基础模型抽象</h2><p>对于网络服务都有一个通用的处理结构即<code>read</code>、<code>decode</code>、<code>processService</code>、<code>encode</code>、<code>send</code>。当然他们内部的逻辑并不一样，例如对应不同的请求数据类型会有不一样的编解码形式，不同的业务逻辑也会有不一样的处理方式。但是他们处理流程的结构都是相通的。</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20210919113913.png" srcset="/img/loading.gif"></p>
<p>正因为这第一层抽象，我们可以得到一个经典抽象结构，即一个客户端连接多个Service，一个Service对接多个Handler，并且每个Handler都有自己的线程。</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20210919123721.png" srcset="/img/loading.gif"></p>
<p>这个结构就对应我们前面介绍的更多的连接中的<strong>多线程</strong>的解决方案。即每个连接都由一个handler快速处理。但是这样的结构也存在明显的弊端，就是扩展性不够。不能随着外部资源的提升增加性能，随着连接的增加Server连接越来越多的服务，整个负载受到Server连接数量的限制。对于Netty整个发展的过程我们可以有以下一些拓展思考。</p>
<blockquote>
<p>以下这些内容都是从Scalable in Java里面摘取出来的，是Reactor模型设计上的一些思考，我觉得对于一些结构上的设计非常具有启发意义，值得反复品。其中有一句话非常指的思考🤔。</p>
<p>Divide-and-conquer is usually the best approach for achieving any scalability goal</p>
<p>--</p>
<p>分治思想通常是处理的可拓展性问题的最好方法。</p>
<p><strong>对于拓展性我们可以从下面几个方面思考</strong>：</p>
<ul>
<li>在增加负载的情况下，性能缓慢的降级（连接更多的客户端）。</li>
<li>可以随着硬件资源的提升，不断提升整体性能（CPU、内存、硬盘和带宽等）。</li>
<li>还有一些可用性和性能指标<ul>
<li>低延迟。</li>
<li>能在最高负载下稳定运行。</li>
<li>可以调节性能指标。</li>
</ul>
</li>
<li>分治思想</li>
</ul>
<p>这里谈到了分治思想，前面Doug Lee 也提到了分治思想是处理扩展性问题的最好解决办法，那我们一起看看分治思想又是怎么在IO中体现的吧。Java NIO 中的分治思想：</p>
<ul>
<li>将大任务切分成多个小任务，并且每个小任务都是非阻塞的。</li>
<li>事件驱动，当任务达到就可以被处理，通常用一个IO事件触发条件。</li>
<li>基本的Java NIO机制支持。<ul>
<li>非阻塞的读和写。</li>
<li>分派任务和IO事件进行关联。     </li>
</ul>
</li>
<li>无穷无尽的拓展性<ul>
<li>可以依据任务驱动设计模式设计更多的处理器。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="事件驱动模型"><a href="#事件驱动模型" class="headerlink" title="事件驱动模型"></a>事件驱动模型</h2><p>上面我们提到了事件驱动。<strong>事件驱动就是基于事件触发拉起程序的执行</strong>。例如Java里面的AWT即Java桌面窗口程序，如果你写过JWT或者说是.net桌面应用程序，那肯定知道如果想要这些程序正常的执行一定将点击事件和一个处理器绑定，当用户点击某个button就会触发执行特定Handler。我们的web前端交互也是这样的，只不过这些操作前端帮我们处理了，然后前端直接触发对应的接口逻辑。整个过程如下图展示：</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20210919154652.png" srcset="/img/loading.gif"></p>
<p>事件驱动相较于其他的一些方式有更高的效率。<strong>通常来说一段逻辑的执行由某个事件触发。这意味着更少的资源消耗，并不需要对于每个客户端都用一个线程处理，线程资源可以池化公用</strong>，<strong>同时也会由更少的上下文切换和更少的锁</strong>。如果基于这样的设计就需要添加一个dispatcher，使用dispatcher将事件分派到对应的handler，但是dispatcher可能成为性能的瓶颈，因为每个连接都需要通过这里分派到对应的处理器处理，这个部分还需要开放事件和handler的绑定，可以在项目启动时或程序运行期间进行事件和handler的绑定。</p>
<h2 id="Reactor单线程模型"><a href="#Reactor单线程模型" class="headerlink" title="Reactor单线程模型"></a>Reactor单线程模型</h2><p>我们的模型并没有直接采用这种模式而是使用了响应（Reactor）模式，也就是我们经常的提到的Netty的Reactor模型。Reactor和我们的响应式还是很相似的，首先是<strong>事件驱动，有一个或者多个并发输入源，有一个Service Handler和多个EventHandlers。这个Service Handler会同步的将输入的请求多路复用并分发给相应的EventHandler。</strong></p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20210919172031.png" srcset="/img/loading.gif"></p>
<p>上面这个版本是Reactor的单线程版本，一个客户端连接上acceptor后，然后分派给对应的Handler处理执行。但是一个连接连接上acceptor之后，所有的I/O操作都在一个线程上完成，此时线程职责包括：<strong>接收新连接请求、读写操作</strong>等。一个客户端连接上后，<strong>在处理完成send之前，acceptor都处于阻塞状态</strong>，这极大的影响了Reactor的整体性能。依据这个逻辑我们Netty构建出来的Reactor模型如下：</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20210921105854.png" srcset="/img/loading.gif"></p>
<p>Netty对于这种模式的编码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">EventLoopGroup eventGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);<br>ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>serverBootstrap.group(eventGroup);<br></code></pre></td></tr></table></figure>

<h2 id="Reactor多线程模型"><a href="#Reactor多线程模型" class="headerlink" title="Reactor多线程模型"></a>Reactor多线程模型</h2><p>Reactor多线程模型和Reactor单线程模型的区别就在于<strong>处理连接的是一个线程，而处理具体业务逻辑是另外一组线程</strong>，这样的好处就是，<strong>一个连接acceptor同时可以处理多个连接事件</strong>。</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20210919194246.png" srcset="/img/loading.gif"></p>
<p>Reactor多线程模型在绝大多数场景下都能满足性能需求。但是这个模型中，<strong>只有一个线程负责监听和处理所有的客户端连接</strong>。如果遇到连接风暴，一个线程是很有可能扛不住的。同时通过我们前面介绍过的TCP三次握手，一个连接的背后会有多次的握手交互，所以一个线程的Reactor的压力还是很大的。Netty的Reactor多线程模型如下：</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20210921121722.png" srcset="/img/loading.gif"></p>
<p>Netty对于Reactor多线程版本的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">EventLoopGroup eventGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>serverBootstrap.group(eventGroup);<br></code></pre></td></tr></table></figure>

<p><strong>在连接了很多的客户端的情况下，一个acceptor线程可能会成为整个系统的瓶颈。</strong>为了解决这个潜在的性能问题，又有了下面的第三种Reactor模型。</p>
<h2 id="Reactor主从多线程模式"><a href="#Reactor主从多线程模式" class="headerlink" title="Reactor主从多线程模式"></a>Reactor主从多线程模式</h2><p>Reactor主从多线程模式的特点是，<strong>服务端处理客户端的连接不再是一个单独的线程，而是一个独立的线程池</strong>。acceptor接收到客户端TCP连接请求并处理完成后（这里的处理包括握手、认证等操作），一旦链路建立成功，就将链路注册到后端的 subReactor线程池I/O线程上，由I/O线程负责后续的操作。一下就是这个模型的示意图。</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20210920004557.png" srcset="/img/loading.gif"></p>
<p>到此，我们的线程模型演变到最终的主从Reactor模式，分为两个Reactor，<strong>第一个Reactor处理连接有关的操作，而第二个Reactor负责处理业务有关的操作</strong>。当连接很多客户端时候，整个连接压力被均匀的分摊到mainReactor的多个线程上，再配合subReactor将业务处理分发到各个worker线程上，使得整个模型在比较高的负载下依旧有很高的性能表现。并且是可以通过提升机器性能来提升整体服务的性能，可根据实际需要来配置合适的性能范围。按照这个模型建立的Netty模型如下：</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20210921124236.png" srcset="/img/loading.gif"></p>
<p>Netty对上面主从的Reactor模式的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>EventLoopGroup workGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>serverBootstrap.group(bossGroup, workerGroup);<br></code></pre></td></tr></table></figure>

<h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><p>在梳理过前面的模型之后，我们来写一个简单的Demo，快速上手Netty。这次我们写一个客户端和服务端互相说Hello的程序，代码相较于Socke程序会有有点长，要耐心看完～。使用的Netty版本如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.netty<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>netty-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.51.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>服务端的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by Daiwei on 2021/9/21</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServer</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> port = <span class="hljs-number">8801</span>;<br>        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        EventLoopGroup workGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">try</span> &#123;<br>            ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>            bootstrap.group(bossGroup, workGroup)<br>                    .channel(NioServerSocketChannel.class)<br>                    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">512</span>)<br>                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-keyword">true</span>)<br>                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> HelloHandler());<br>                        &#125;<br>                    &#125;);<br>            ChannelFuture future = bootstrap.bind(port).sync();<br>            System.out.println(<span class="hljs-string">&quot;服务启动完成, 监听 127.0.0.1:&quot;</span> + port);<br>            future.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            bossGroup.shutdownGracefully();<br>            workGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * helloHandler 处理器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从channel中读数据。执行一些业务操作，或者加入一些hook触发后续业务。</span><br><span class="hljs-comment">     * 同时可以通过channel发送数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx 上下文</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msg 从channel中读到的数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ByteBuf byteBuf = (ByteBuf) msg;<br>        System.out.println(<span class="hljs-string">&quot;message[&quot;</span>+ byteBuf.toString(StandardCharsets.UTF_8) +<span class="hljs-string">&quot;] received！hello there and &quot;</span> +<br>                <span class="hljs-string">&quot;message is from [&quot;</span> + ctx.channel().remoteAddress().toString() + <span class="hljs-string">&quot;]&quot;</span>);<br>        ByteBuf toClientMsg = Unpooled.copiedBuffer( <span class="hljs-string">&quot;hello!&quot;</span>.getBytes(StandardCharsets.UTF_8));<br>        ctx.channel().writeAndFlush(toClientMsg);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在处理过程中捕捉到了异常执行这个方法，输出异常，关闭资源</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx 上下文</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cause 异常信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ctx.close();<br>        <span class="hljs-keyword">super</span>.exceptionCaught(ctx, cause);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>客户端代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by Daiwei on 2021/9/21</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClient</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String host = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br>        <span class="hljs-keyword">int</span> port = <span class="hljs-number">8801</span>;<br>        NioEventLoopGroup eventLoopGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();<br>            bootstrap.group(eventLoopGroup).channel(NioSocketChannel.class)<br>                    .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> ClientHelloHandler());<br>                &#125;<br>            &#125;);<br>            ChannelFuture channelFuture = bootstrap.connect(host, port).sync();<br>            channelFuture.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            eventLoopGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 客户端的ChannelHandler</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientHelloHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ByteBuf buf = (ByteBuf) msg;<br>        System.out.println(<span class="hljs-string">&quot;receive message [&quot;</span> + buf.toString(StandardCharsets.UTF_8) + <span class="hljs-string">&quot;] from server!&quot;</span>);<br>    	ctx.close();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当有channel连接上发送消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello server!&quot;</span>.getBytes(StandardCharsets.UTF_8)));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        cause.printStackTrace();<br>        <span class="hljs-keyword">super</span>.exceptionCaught(ctx, cause);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">Server端输出：</span><br><span class="hljs-string">服务启动完成,</span> <span class="hljs-string">监听</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8801</span><br><span class="hljs-string">message[hello</span> <span class="hljs-string">server!]</span> <span class="hljs-string">received！and</span> <span class="hljs-string">message</span> <span class="hljs-string">is</span> <span class="hljs-string">from</span> [<span class="hljs-string">/127.0.0.1:55370</span>]<br><span class="hljs-meta">---</span><br><span class="hljs-string">Client端输出：</span><br><span class="hljs-string">receive</span> <span class="hljs-string">message</span> [<span class="hljs-string">hello!</span>] <span class="hljs-string">from</span> <span class="hljs-string">server!</span><br></code></pre></td></tr></table></figure>

<p>上面这个例子是最基础的一个入门的demo，但是相比于Socket还是复杂了不少😂。先启动服务端启动并监听8801端口，服务端启动后输出日志信息“服务启动完成, 监听端口 127.0.0.1:8801”。随后我们启动客户端，客户端连接127.0.0.1:8081，随后连接成功后，客户端的Netty回调<code>channelActive</code>这个方法，然后客户端发送一个“hello server”消息。然后服务端接收到消息并将信息输出到console，然后服务端向客户端发送消息“hello”。客户端收到消息之后，将消息输入到console并关闭channel断开连接。</p>
<h1 id="组件和运行流程介绍"><a href="#组件和运行流程介绍" class="headerlink" title="组件和运行流程介绍"></a>组件和运行流程介绍</h1><p>对于接触过Netty的同学，上面的例子会感觉非常简单，没有接触过Netty的小伙伴来说，这个Demo接触下来还是有一些难度的，尤其一些陌生的类。这些陌生的类都是Netty的核心组件，接下来我们来介绍这些组件的基本功能和Netty的运行流程。</p>
<h2 id="基本组件"><a href="#基本组件" class="headerlink" title="基本组件"></a>基本组件</h2><p>其中我们的核心组件包括<code>EventLoop</code>、<code>Bootstrap&amp;ServerBootstrap</code>、<code>Channel</code>、<code>ChannelHandler</code>、<code>ChannelPipeline</code>、<code>ChannelFuture</code>等。这些核心组件支撑起了Netty基本的主从Reactor结构。</p>
<ul>
<li><p><strong>EventLoop</strong>：<strong>EventLoop用于处理Channel的I/O操作</strong>。一个单一的<code>EventLoop</code>通常会处理多个<code>Channel</code>事件。一个<code>EventLoopGroup</code>可以含有多于一个<code>EventLoop</code>和提供了一种迭代用于检索清单中的下一个。</p>
</li>
<li><p><strong>Bootstrap&amp;ServerBootstrap</strong>：<strong>Netty应用程序通过设置</strong><code>bootstrap</code><strong>引导类来完成，该类提供了一个用于应用网络配置的容器</strong>。Bootstrap服务端的是<code>ServerBootstrap</code>，客户端是<code>Bootstrap</code>。</p>
</li>
<li><p><strong>Channel</strong>：Netty中的接口 Channel 定义了与 socket 丰富的交互的操作集：<code>bind</code>，<code>close</code>，<code>config</code>，<code>connect</code>，<code>isActive</code>，<code>isOpen</code>，<code>isWritable</code>，<code>read</code>，<code>write</code>等等。</p>
</li>
<li><p><strong>ChannelHandler</strong>：<strong>ChannelHandler 支持非常多的协议，并且提供用于数据处理的容器，ChannelHandler中的方法由特定的事件触发</strong>，常用的一个接口是<code>ChannelInboundHandler</code>，该类型主要方法入站读数据（socket读事件）。</p>
</li>
<li><p><strong>ChannelPipeline</strong>：<strong>ChannelPipeline提供了一个容器给ChannelHandler链并提供了一个API调用，用于管理沿着链入站和出站事件的流动</strong>。每个Channel都有自己的ChannelPipeline，当Channel创建时自动创建的。下图即可说明两者的关系。</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20210921211125.png" srcset="/img/loading.gif"></p>
</li>
<li><p><strong>ChannelFuture</strong>：<strong>Netty 所有的I/O操作都是异步的</strong>。因为一个操作可能无法立即返回，我们需要一种方法在以后获取他的结果，出于这个目的，Netty提供了接口<code>ChannelFuture</code>的<code>addListener</code>方法。</p>
</li>
</ul>
<p>Netty是一个非阻塞、事件驱动的网络框架。Netty实际上是使用Threads（多线程）处理I/O事件的，对于熟悉多线程编程可能需要关注代码同步。但是这样并不好，同步会严重影响到程序的性能，线程间的同步操作也容易产生bug。Netty的设计保证了处理事件不会又同步，因为处理某个Channel事件是被添加到一个EventLoop中的，以后该Channel事件都是由该EventLoop的线程处理，并且每个线程之间资源是隔离的，也就是说Netty不需要进行线程间的同步资源竞争操作。EventLoop在EventLoopGroup中，他们的关系可以理解为线程和线程池的关系。</p>
<h2 id="运行流程分析"><a href="#运行流程分析" class="headerlink" title="运行流程分析"></a>运行流程分析</h2><p>我们梳理完核心组件之后，在看前面的代码就清晰很多了，我们上面列举的核心组件也基本在代码中都有使用。他们通过ServerBootstrap联系在一起，通过<code>Group()</code>方法将两个<code>EventLoopGroup</code>实例（NioEventLoopGroup）组成主从Reactor，然后使用<code>option()</code>方法配置可调参数，使用<code>channel()</code>函数指定监听的SocketChannel类型。随后使用<code>childChannel(new ChannelInitializer&lt;&gt;&#123;...&#125;)</code> 构造出后续的<code>Pipeline</code>、<code>channelHandler</code>等。<strong>默认情况下每有一个连接创建，这个部分都会创建一次</strong>。最后将整个服务绑定在某个监听端口，然后返回一个<code>ChannelFuture</code>对象。这个服务端就算是启动完毕。因为EventLoopGroup本质上是个线程池，所以最后要优雅的关闭回收资源即<code>shutdwonGracefully()</code>，以下这张图是Server端的Netty主从Reactor的工作示意图。</p>
<blockquote>
<p>ServerSocketChannel，SocketChannel之间的关系和ServerSocket与Socket之间的关系类似。 </p>
</blockquote>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20210921223233.png" srcset="/img/loading.gif"></p>
<p>整个工作描述如下：</p>
<ol>
<li>Netty抽象出两组线程池，<strong>BossGroup 专门负责接收客户端的连接，workerGroup 专门负责网络的读写</strong>。他们的类型都是NioEventLoopGroup。</li>
<li>NioEventLoopGroup相当于一个<strong>事件循环组，这个组中包含了很多个事件循环</strong>，每个事件循环是NioEventLoop。</li>
<li>NioEventLoop标识一个不断循环的执行处理任务的线程，<strong>每个NioEventLoop都有一个selector，用于监听绑定在其上的socket网络通信</strong>。</li>
<li>NioEventLoopGroup可以有多个线程，即包含多个NioEventLoop。</li>
<li>每个BossNioEventLoop循环的步骤分为3步：<ol>
<li><strong>轮询accept事件</strong>。</li>
<li><strong>处理accept事件，与client建立连接，生成NioSocketChannel，并将其注册到某个worker NioEventLoop上的selector。</strong></li>
<li><strong>处理任务队列的任务，即runAllTasks。</strong></li>
</ol>
</li>
<li>每个WorkerNioEventLoop循环执行的步骤：<ol>
<li><strong>轮询read/write事件。</strong></li>
<li><strong>处理I/O事件，即read/write事件，在对应NioSocketChannel处理。</strong></li>
<li><strong>处理任务队列的任务，即runAllTasks。</strong></li>
</ol>
</li>
<li><strong>每个worker NIOEventLoop处理业务会使用pipeline，pipeline中包含了channel</strong>，即通过pipeline可以获取到对应的通道，管道中维护了很多的处理器。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这一小节我们先抛出了一个疑问？为什么是Netty，随后我们梳理了Netty的优点和Java NIO 的缺点，总结得出好用强大且拓展性高的Netty是我们首选的网络编程工具这一结论。随后我们介绍了Netty的模型的演进，这一部分我们一起顺着Doug Lee在《Scalable IO in Java》中的观点，把Netty的模型梳理了一边。一开始我们是一个简单的多个客户端连接一个Server，然后Server调用一个包含读取发送，编解码和业务处理的调用链。很明显这个结构不具备高可用性和高拓展性。其实我们的网络程序和Java AWT程序有异曲同工之处，他们都可以是一个事件驱动。基于事件驱动整体可以获得更高的效率，更少的上下文切换，但是编码会相较变得稍复杂一些。Reactor的单线程版本出现了，这个版本当一个acceptor监听到服务后，dispatcher再将任务分派给对应的处理流程进行处理。这个模型存在一个问题就是处理过程从始至终都是单线程的，在这个连接未完成处理之前，acceptor始终无法处理下一个连接。正因为如此有了Reactor的多线程版本，多线程版本和单线程版本的最大区别就是单线程同时只能处理一个连接，而处理事件的是一个线程池，一个acceptor可以同时处理多个连接。但是面对海量连接，一个acceptor还是会存在性能问题。因此我们将一个Reactor切分开来，主Reactor负责连接，从Reactor负责业务处理，并且他们都是使用线程池进行处理，使得整体的吞吐能力大幅提升。这也就是我们Netty参照的主从Reactor模式。最后我们编写了一个Netty的HelloWorld，随后我们介绍了其中的基础组件和Netty整体的工作流程。这个部分我们没有深入源码细讲，因为会有专门的源码分析篇进行解读分析。加油，未来可期！</p>
<h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><ul>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39710966/article/details/114201686">java nio epoll bug_JAVA NIO存在的问题</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/371352">Java NIO中的通道Channel（二）分散/聚集 Scatter/Gather</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf">Scalable IO in Java（Doug Lea）</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?biz=MzIwNTI2ODY5OA==&mid=2649938635&idx=1&sn=fc22d218fb1529e8f4c1fcb659838d75">Netty 入门，这一篇文章就够了</a></p>
</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/NIO%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">NIO与网络编程</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Java%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84%E6%A2%B3%E7%90%86/">Java知识结构梳理</a>
                    
                      <a class="hover-with-bg" href="/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">学习总结</a>
                    
                      <a class="hover-with-bg" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/09/15/socket-and-io/">
                        <span class="hidden-mobile">网络编程 — Socket编程与IO模型</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
