

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/blogFavicon.png">
  <link rel="icon" href="/img/blogFavicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  
    <meta name="description" content="">
  
  <meta name="author" content="Daiwei">
  <meta name="keywords" content="">
  
  <title>网络基础 — 网络模型与网络协议 - Daiwei‘s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.8","typing":{"enable":true,"typeSpeed":100,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Daiwei's blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://gitee.com/realDaiwei/img/raw/master/sergey-pesterev-llGiAyYthDw-unsplash.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="网络基础 — 网络模型与网络协议">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-09-04 14:22" pubdate>
        2021年9月4日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      10.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      36
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">网络基础 — 网络模型与网络协议</h1>
            
            <div class="markdown-body">
              <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从这一小节，我们开始梳理网络相关的知识结构。网络对于程序员非常重要，可以说离开了网络软件程序就失去了70%的魔力。但是程序员对于网络相关的领域是又爱又恨，爱是因为网络赋予程序无限的可能性，恨是因为网络对软件开发来说几乎是透明的，不用刻意的去调整网络，我们也能进行业务的开发。掌握网络相关的知识并不容易，网络相关的领域的知识内容复杂且涉及范围广。可是如果要成为一个优秀的开发工程师，进行网络相关的开发，就必须对这个部分有一个清晰的结构化的认知。这一小节，我们会从网络的TCP五层模型和OSI七层结构模型开始梳理介绍，随后介绍每一层和每一层具有代表性的网络协议，最后我们简单的聊一聊一个数据包是怎么在网络上传输的。</p>
<h1 id="网络模型基础"><a href="#网络模型基础" class="headerlink" title="网络模型基础"></a>网络模型基础</h1><p>这个模型我相信大家在大学都学过，基本上网络的知识都是围绕着这个网络结构展开的。其中我们学习过两种网络模型，一种是OSI七层模型，另外一种是TCP/IP五层模型。其中OSI七层模型包括<strong>应用层、表示层、会话层、传输层、网络层、数据链路层和物理层</strong>。而TCP/IP五层模型包括<strong>应用层、传输层、网络层、数据链路层和物理层。</strong>OSI七层模型更加侧重功能，而TCP/IP更加侧重于协议。</p>
<blockquote>
<p>OSI七层和TCP/IP五层的区别：</p>
<ol>
<li><p>TCP/IP 是一个协议簇；而OSI是一个模型，且TCP/IP的开发时间在OSI之前。</p>
</li>
<li><p>TCP/IP是由一些交互性的模块做成的分层次的协议，其中每个模块提供特定的功能；OSI则指定了哪个功能是属于哪一层的。</p>
</li>
<li><p>TCP/IP是五层结构，而OSI是七层结构。OSI的最上面的三层在TCP中用应用层表示。</p>
</li>
</ol>
</blockquote>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20210813004056.png" srcset="/img/loading.gif"></p>
<p>TCP/IP的五层分别为：<strong>应用层、传输层、网络层、数据链路层和物理层。</strong>前面我们提到TCP/IP五层结构是由一些交互性的模块做成的分层次的协议，那么他们每一层有哪些协议？以下列举了我们接触的比较多的网络协议。</p>
<ul>
<li><p>应用层：<code>HTTP</code>、<code>HTTPS</code>、<code>FTP</code>、<code>SMTP</code>、<code>Telnet</code>…</p>
</li>
<li><p>传输层：<code>TCP</code>、<code>UDP</code></p>
</li>
<li><p>网络层：<code>IP</code>、<code>ICMP</code>…</p>
</li>
<li><p>数据链路层：<code>ARP</code>…</p>
</li>
<li><p>物理层：…</p>
</li>
</ul>
<p>OSI七层模型分为：<strong>应用层、表示层、会话层、传输层、网络层、数据链路层和物理层</strong>。OSI更偏向哪个功能属于哪一层。那么这些网络功能都在那层呢？</p>
<ul>
<li><p>应用层：文件传输、电子邮件、文件服务、虚拟终端等。</p>
</li>
<li><p>表示层：数据格式化、代码转换、数据加密。</p>
</li>
<li><p>会话层：解除或建立与其他接点的联系。</p>
</li>
<li><p>传输层：提供端对端的接口。</p>
</li>
<li><p>网络层：为数据包选择路由。</p>
</li>
<li><p>数据链路层：传输有地址帧，错误检测的功能。</p>
</li>
<li><p>物理层：以二进制数据形式在物理媒体上传输数据。</p>
</li>
</ul>
<p>将这两个模型总结成如下表格：</p>
<table>
<thead>
<tr>
<th>OSI模型</th>
<th>TCP/IP五层模型</th>
<th>功能</th>
<th>协议</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>应用层</td>
<td>文件传输、电子邮件等</td>
<td>HTTP、FTP、SMTP、Telnet等</td>
</tr>
<tr>
<td>表示层</td>
<td>数据格式化，代码转换，数据加密</td>
<td>无</td>
<td></td>
</tr>
<tr>
<td>会话层</td>
<td>建立或者解除与其他连接点的联系</td>
<td>无</td>
<td></td>
</tr>
<tr>
<td>传输层</td>
<td>传输层</td>
<td>提供端对端的接口</td>
<td>UDP、TCP</td>
</tr>
<tr>
<td>网络层</td>
<td>网络层</td>
<td>为数据包提供路由</td>
<td>IP、ICMP等</td>
</tr>
<tr>
<td>数据链路层</td>
<td>数据链路层</td>
<td>传输有地址帧、错误检测</td>
<td>ARP等</td>
</tr>
<tr>
<td>物理层</td>
<td>物理层</td>
<td>二进制物理介质传输数据</td>
<td>ISO2110、IEEE802、IEEE802.2等网络传输协议</td>
</tr>
</tbody></table>
<h1 id="一个数据包的奇幻之旅"><a href="#一个数据包的奇幻之旅" class="headerlink" title="一个数据包的奇幻之旅"></a>一个数据包的奇幻之旅</h1><p>我们上面介绍了网络模型，但是这些网络模型又和实际的传输有什么关系呢？当我们访问一个网站，背后的数据又是怎么进行传输的呢？我在读书的时候也都知道有网络协议，但是让我说一些传输的细节，我却很难答上来，这个部分我们简单介绍一个数据包的传输过程，建立起一个数据传输过程的基本认知。</p>
<h2 id="封包与拆包"><a href="#封包与拆包" class="headerlink" title="封包与拆包"></a>封包与拆包</h2><p>在网络上传输的并不是直接的数据，而是一个个数据包。每个数据包经过发送端都会被带上一些特殊信息，这些特殊信息在到达中间或目标设备是会被读取，这些特殊信息就是协议头。<strong>数据包在发送端添加协议头的过程叫做封包</strong>，<strong>数据包在接收端被拆分读取分析的过程叫做拆包</strong>。如果我们传输的应用层使用的是HTTP协议，传输过程和封包拆包示例如下。</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20210830001441.png" srcset="/img/loading.gif"></p>
<h2 id="MAC头与IP头"><a href="#MAC头与IP头" class="headerlink" title="MAC头与IP头"></a>MAC头与IP头</h2><p>如果我们要把一个数据包从一个网络设备发送到另一个网络设备，IP头必不可少，但是为了在到达目标局域网后快速找到目标接收端，我们的数据包还需要MAC头，IP头和MAC之间的关系类似于我们信封上的收件地址和收件人姓名。数据包有了这两个协议头，就可以通过网络从一端传输到另一端。以下是这两个协议头的细节图。</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20210830232718.png" srcset="/img/loading.gif"></p>
<p>在MAC头里面，显示<strong>目标MAC地址</strong>，然后是<strong>源MAC地址</strong>，然后有一个协议类型，用来说明里面的IP协议类型。IP头里面的版本号，目前主流的还是IPv4。IP头里面还有个8位标识协议，这里指的是传输层协议类型，也就是TCP，还是UPD协议。这里最重要的是源IP地址和目标IP地址。（IP协议下面有详细介绍。）</p>
<p>在数据包在网络上<strong>传输过程中，这个IP头和MAC头在有些时候并不是一尘不变的，随着网段的切换，这个IP头和MAC头也会切换。</strong>在任何一台机器上，当要访问另一个IP地址的时候，都先要判断目标IP地址和当前机器的IP地址，是否在同一个网段。</p>
<ul>
<li><strong>如果在同一个网段</strong>，这就好比在公司你访问你旁边同事电脑一样，这里数据包的传输过程中不用进过网关就能访问。在封包过程中，<strong>直接将源地址和目标地址放入IP头中，然后通过ARP获得MAC地址，将源头MAC和目的MAC地址放入MAC头</strong>，然后发送出去就好了。</li>
<li><strong>如果不是同一个网关，这个时候就要先把数据包发给网关Gateway</strong>。网关Gateway地址一定是和源IP地址是同一个网段的。往往不是第一个地址就是第二个地址。</li>
</ul>
<blockquote>
<p>网关是一个三层转发设备，往往是一个<strong>路由器、三层交换机或是防火墙。它是一个网段的入口也是出口</strong>，就很类似与我们现实生活中的海关，这个出口<strong>连接着多个网段</strong>。如果一个<strong>数据包传输过程中跨网段</strong>，网关<strong>匹配上</strong>IP地址和MAC地址之后，<strong>三层设备会读取数据包并根据目标IP地址</strong>，匹配转发的网段，匹配到之后，三层设备会<strong>重新给数据包打上下一个目标地址的IP头和MAC头</strong>直到跳到目标设备或在网络中被丢弃为止。</p>
</blockquote>
<h2 id="路由过程分析"><a href="#路由过程分析" class="headerlink" title="路由过程分析"></a>路由过程分析</h2><p>接下来我们通过分析在同一网段和在不同网段场景下，数据包在网络中的路由过程是怎样。在这个过程中数据包的IP头和MAC头又会发生哪些变化。</p>
<h3 id="转发网关路由场景分析"><a href="#转发网关路由场景分析" class="headerlink" title="转发网关路由场景分析"></a>转发网关路由场景分析</h3><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210904143156.png" srcset="/img/loading.gif"></p>
<p>上面这张图，我们可以发现服务器A要访问服务器B，其中左边的路由器为路由器A，右侧的路由器为路由器B。目标服务器<code>192.168.4.101/24</code>和源服务器<code>192.168.1.101/24</code>不在同一个网段，因而需要先把数据包发送给网关。其中网关已经配置好了为<code>192.168.1.1/24</code>，同时通过<code>ARP</code>获取网关的MAC地址 ，然后发送数据包。其中包中的MAC头和IP头信息如下。</p>
<blockquote>
<ul>
<li><p>源MAC：服务器的A的MAC地址。</p>
</li>
<li><p>目标MAC：<code>192.168.1.1</code>这个网口的MAC地址。</p>
</li>
<li><p>源IP：<code>192.168.1.101</code></p>
</li>
<li><p>目标IP: <code>192.168.4.101</code></p>
</li>
</ul>
</blockquote>
<p>当数据包到达网关<code>192.168.1.1</code>后，路由器A通过查询路由表发现，如果需要访问<code>192.168.4.101</code>需要从<code>192.168.56.1</code>这个口出去，到达下一跳<code>192.168.56.2</code>。因此路由器通过ARP获得<code>192.168.56.2</code>的MAC地址，并将包发出去，其中包中的MAC头和IP头信息如下：</p>
<blockquote>
<ul>
<li><p>源MAC：<code>192.168.56.1</code>的MAC地址。</p>
</li>
<li><p>目标MAC：<code>192.168.56.2</code>的MAC地址。</p>
</li>
<li><p>源IP：<code>192.168.1.101</code></p>
</li>
<li><p>目标IP: <code>192.168.4.101</code></p>
</li>
</ul>
</blockquote>
<p>当数据包到达<code>192.168.56.2</code>这个网口，后来路由B通过查询路由表，如果想要<code>192.168.4.101/24</code>目标IP，需要从<code>192.168.4.1/24</code>这个口出去并且目标IP也是我们要反问的服务器B，因此这一跳也是最后一跳。通过ARP协议获取<code>192.168.4.1/24</code>的MAC地址后把数据包发出去，其中包中的MAC头信息和IP头信息如下：</p>
<blockquote>
<ul>
<li><p>源MAC：<code>192.168.4.1/24</code> 的MAC地址。</p>
</li>
<li><p>目标MAC：<code>192.168.4.101/24</code> 的MAC地址。</p>
</li>
<li><p>源IP：<code>192.168.1.101</code></p>
</li>
<li><p>目标IP: <code>192.168.4.101</code></p>
</li>
</ul>
</blockquote>
<p>通过这个过程可以看出，每到一个新的局域网，<strong>MAC地址都是要变的，但是IP地址不变</strong>。在IP头里面，不会保存任何网关的IP地址，<strong>所谓下一跳，是要将目标IP转换为MAC地址放入MAC头，目标IP地址在整个过程过程中不会发生改变。</strong>这是转发网关的路由过程。</p>
<h3 id="NAT网关路由场景分析"><a href="#NAT网关路由场景分析" class="headerlink" title="NAT网关路由场景分析"></a>NAT网关路由场景分析</h3><p><img src="https://gitee.com/realDaiwei/img/raw/master/20210904143249.png" srcset="/img/loading.gif"></p>
<p>这个场景和上面场景有一些不同，其中访问的源服务器A和目标的服务器B的IP地址是相同的。他们两个在不同的局域网中，这个场景很像我日常访问学校选课系统一样。服务器A是我们自己电脑，现在我们要访问学校的选课系统，选课系统部署在机房的局域网中，选课系统服务器B的IP地址为<code>192.168.1.101/24</code>，碰巧我们宿舍的电脑在宿舍这个局域网内也是<code>192.168.1.101/24</code>这个IP地址。<strong>它为了能对外提供服务，还需要一个外网地址</strong><code>192.168.56.2/24</code>。现在我们服务器A要向服务器B发送数据包，首先服务器A先从DNS解析获取服务器B域名对应的IP地址即<code>192.168.56.2/24</code>。这个地址不是和服务器A在一个局域网，所以我们将数据包发送给网关。数据包中的IP地址和MAC地址如下：</p>
<blockquote>
<ul>
<li><p>源MAC：服务器的A的MAC地址。</p>
</li>
<li><p>目标MAC：<code>192.168.1.1</code>这个网口的MAC地址。</p>
</li>
<li><p>源IP：<code>192.168.1.101</code></p>
</li>
<li><p>目标IP: <code>192.168.56.2</code></p>
</li>
</ul>
</blockquote>
<p>数据包到达网关<code>192.168.1.1</code>后，通过查询路由表，应该走<code>192.168.56.1/24</code>这个口出去，并且目标<code>192.168.56.2</code>就是下一跳。通过ARP获取到<code>192.168.56.2/24</code>的MAC地址，并且将数据包发送出去。</p>
<blockquote>
<p> 这里需要注意⚠️，这里我们的网关是NAT网关，在外网上传输如果使用<code>192.168.1.101</code>局域网的IP地址，接收端无法知道通过一个局域网的IP地址定位到发送端，所以这里我们的源IP地址应该是NAT网关的地址，<strong>回来的数据包发送到这个网关只要通过一定的映射关系就能找到回来的数据包中的IP地址对应的服务器。这也就是NAT网关的特殊之处，其中NAT的全称为（Network Address Translation）。</strong></p>
</blockquote>
<p>这里我们的数据包的头信息如下，不难发现这个时候我们源IP地址和MAC地址已经变成了NAT网关A的IP地址和MAC地址。</p>
<blockquote>
<ul>
<li><p>源MAC：<code>192.168.56.1/24</code>的MAC地址。</p>
</li>
<li><p>目标MAC：<code>192.168.56.2/24</code>的MAC地址。</p>
</li>
<li><p>源IP：<code>192.168.56.1</code></p>
</li>
<li><p>目标IP：<code>192.168.56.2</code></p>
</li>
</ul>
</blockquote>
<p>包到达<code>192.168.56.2</code>NAT网关之后，<code>192.168.56.2</code>的外网地址映射的是内网服务器B的地址为<code>192.168.1.101/24</code>，通过ARP获取服务器B的MAC地址之后，将数据包发送给服务器B，注意这里的网关是NAT网关，所以这里的<strong>源的MAC地址会替换成局域网的NAT网关MAC地址</strong>，其中数据包中头信息如下：</p>
<blockquote>
<ul>
<li><p>源MAC：<code>192.168.1.1</code> 的MAC地址。</p>
</li>
<li><p>目标MAC：<code>192.168.1.101 </code>的MAC地址。</p>
</li>
<li><p>源IP：<code>192.168.56.1</code></p>
</li>
<li><p>目标IP：<code>192.168.1.101</code></p>
</li>
</ul>
</blockquote>
<p>至此，NAT网关的路由场景路由结束了。我们仔细观察不难发现，NAT网关和转发网关的区别在于NAT会做IP地址的映射转换，可以让多个设备通过一个IP地址进行数据访问。极大了解决了IPv4地址总量不足的问题。但是正是NAT网关的存在，这导致如果我们没有将服务地址映射到公网上，我们就无法通过外网直接访问我们私人服务。同时，我们访问外网服务，一个局域网内的设备使用的都是一个IP地址，即出口NAT网关地址。</p>
<blockquote>
<p> 这里还有一个注意的点：NAT转换的时候还有一个NAPT协议，即<strong>Network Address Port Translation</strong>，数据包发出的时候，NAT路由会将数据包中的<strong>局域网IP和端口</strong>转换为<strong>NAT的公共IP和NAT动态分配的端口</strong>，并且建立映射关系。等数据包回来的时候，NAT路由会<strong>依据这个转换后的NAT动态端口</strong>转换为局域网的IP地址和端口。</p>
<p>数据包出： <strong>局域网IP:端口 ==NAT==&gt; NAT公共IP:动态端口</strong>。</p>
<p>数据包入： <strong>NAT公共IP:动态端口 ==NAT ==&gt; 局域网IP:端口</strong>。</p>
</blockquote>
<p>这里还有一个没有介绍的点，就是我们的<code>路由策略</code>和<code>路由算法</code>，其中有我们可以配置的静态路由策略和在路由过程中的动态路由算法。如果有感兴趣的朋友，可以查询有关资料深入，这里就不展开了，展开了又能讲一大堆了。😅😅</p>
<h1 id="协议？你我之间的约定！"><a href="#协议？你我之间的约定！" class="headerlink" title="协议？你我之间的约定！"></a>协议？你我之间的约定！</h1><p>我刚开始接触到协议的时候，了解到什么TCP/IP协议，UDP协议各种各样的协议都有种不明觉厉的感觉。但是随着我深入的学习，编写自己的RPC的网络协议的时候，发现协议并没有想象中的那么神秘，协议只不过是收发端约定的规则而已，更像是我们写信中，大家约定的书信格式一样。没了协议双方网络能通么？当然是可以的，只不过我不知道你发的是什么信息了。因此我们这的协议是网络协议的简称，<strong>网络通信计算机双方必须共同遵循的一组约定</strong>，如怎样建立连接、怎么样互相识别等。只有遵守了这个约定，计算机之间才能互相通信交流。我们将从数据链路层自下向上依次梳理各个层代表协议。物理层过于物理，这里我们就不梳理了。</p>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>数据链路层也叫MAC层，MAC层的全程是<strong>Medium Access Control</strong>，即媒体访问控制。<strong>其实就是控制媒体上发数据的时候，谁先发、谁后发的问题。防止发生混乱，即多路访问</strong>。主要有以下三种协议：<strong>信道划分</strong>、<strong>轮流协议</strong>和<strong>随机接入协议</strong>。</p>
<h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p>ARP协议是一个工作在数据链路层的协议。ARP协议解决了什么样问题呢？我们都知道在网络包传输需要一个IP地址和一个MAC，如果IP地址可以类比成你的地址，MAC地址就是你的名字。IP地址我们可以通过查询DNS服务器获得，那么MAC地址怎么办？这个时候就需要ARP协议。<strong>通过IP协议获取目标设备的MAC地址，这就是ARP协议的工作目标。</strong></p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20210814144601.png" srcset="/img/loading.gif"></p>
<p>那如果如果通过IP地址获取的目标的MAC地址呢？其实很简单，<strong>在局域网中发送一个ARP请求，这个请求是以广播的形式发出去的，如果某一台机器收到ARP请求，并且发现要查询的IP地址和自己的一致，则返回自己的MAC地址</strong>。发送端收到这个目标机器的MAC地址后，为了避免每次都要发ARP包询问MAC地址，发送端会将这个地址缓存一段时间，方便后续的使用。</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20210814145303.png" srcset="/img/loading.gif"></p>
<p>其中ARP协议发送的报文结构如下所示：</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20210814145551.png" srcset="/img/loading.gif"></p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>网络层是OSI模型中的第三层，介于传输层和数据链路层之间，它在数据链路层提供的两个相邻端点之间的<strong>数据帧</strong>的传输功能上，进一步管理网络中的数据通信，将数据设法从源端经过若干个中间节点传输到目的地端，从而<strong>向传输层提供基本的端到端的数据传输服务</strong>。我们熟知的<code>IP</code>和<code>ICMP</code>（ping命令）协议就工作在这一层。</p>
<h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><p>IP协议是TCP/IP协议族的核心协议，其中包括两个方面：</p>
<ul>
<li>IP头部信息。IP头部信息出现在每个IP数据报中，用于指定IP通信的<strong>源端IP地址、目标端IP地址</strong>，以及<strong>指定部分通信行为</strong>。</li>
<li>IP数据报的路由和转发。IP数据报的路由和转发发生在除目标机器之外的所有主机和路由器上。他们决定数据报是否应该转发以及如何转发。</li>
</ul>
<blockquote>
<p>IP 协议的核心即定义了<strong>数据包从哪来到哪去，以及这个过程中在网络终端上的转发行为</strong>。</p>
</blockquote>
<h5 id="IP协议特点"><a href="#IP协议特点" class="headerlink" title="IP协议特点"></a>IP协议特点</h5><p>IP协议是TCP/IP协议簇的基石，它为上层协议提供<strong>无状态、无连接、不可靠</strong>的服务。</p>
<ul>
<li><p><strong>无状态是指IP通行双方不传输数据的状态信息，因此所有IP数据报的发送、传输都是相互独立的，没有上下文关系</strong>。这种服务最大的缺点就是无法处理乱序和重复的IP数据报。面向连接的协议，比如TCP协议，能够自己处理乱序的、重复的报文段，它递交给上层协议的内容绝对是正确且有序的。</p>
<p>无状态服务的有点也很明显：<strong>简单、高效</strong>。我们无需为保持维护通信状态而消耗系统资源，也无需在每次传输时都携带状态。</p>
</li>
<li><p>无连接是指IP<strong>通信双方都不会长久的维持对方的任何信息</strong>，这样<strong>上层协议在每次发送数据的时候都必须指明对方的IP地址。</strong></p>
</li>
<li><p><strong>不可靠指的是IP协议不能保证数据包一定能准确的到达，它只是承诺尽最大努力</strong>。很多情况都可以导致IP数据报发送失败，比如，某个路由器发现数据包在网络上存在时间太长，就会将它丢弃，并返回一个ICMP错误消息给发送端。</p>
</li>
</ul>
<blockquote>
<p> 因此IP服务上层协议往往需要自己实现数据确认，超时重传等机制，以达到安全可靠传输的目的。典型实现TCP协议。</p>
</blockquote>
<h4 id="IPv4协议头"><a href="#IPv4协议头" class="headerlink" title="IPv4协议头"></a>IPv4协议头</h4><p>IPv4的协议头如下所示，一般长度为20个字节(如下面的5层)，也有可能包含变长部分总长超过20个字节。</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20210817010024.png" srcset="/img/loading.gif"></p>
<ul>
<li><p>4位头部长度标识这个这个IP报文头长度，标识能<strong>有多少个4个字节，因此IP报文头最长 15 * 4 = 60个字节。</strong></p>
</li>
<li><p>8位服务类型包括一个三位的优先权字段，4位的TOS字段和1位保留字段（必须置0）。4位TOS字段分别为：<strong>最小延时，最大吞吐量，最高可靠性和最小费用</strong>。其中最多有一位可以置1，应用程序应该根据实际需要来设置。比如SSH和Telnet这样登录需要最小延时服务，而传输文件的ftp则需要最大吞吐服务。</p>
</li>
<li><p>16位总长度指的是整个IP数据报的长度，以字节为单位。因此IP数据报文最长为65535个字节，但是由于MTU的限制，数据报文长度超过MTU限制就会进行分片传输。</p>
</li>
</ul>
<blockquote>
<p>IP协议的 MTU 是物理设备上的限制，它限制了路径上能够发送数据包大小的上限。</p>
</blockquote>
<ul>
<li>16位标识唯一标识主机发送地每一个数据报。<strong>其初始值由系统随机生成，每发送一个数据报，其值就加一，该值在数据报分片时被复制到每个分片中，因此同一个数据报中的所有分片都具有相同的标识。</strong></li>
<li>3位标识字段第一位保留。<strong>第二表示”禁止分片”**。如果设置了这个位，</strong>IP服务将不对数据报进行分片<strong>，在这种情况下，如果IP数据报超过MTU限制，</strong>后续的数据报会被丢弃<strong>并返回一个ICMP的差错报文。</strong>第三位表示”更多分片”<strong>。除了数据报的</strong>最后一个分片以外，其他分片都要把它置为1。**</li>
<li>13位分片偏移是分片相对原始IP数据报开始处的偏移，实际的偏移量则是左移动3位(*8)后得到，因此除了最后一个分片以外，每个IP分片的数据部分长度必须数8的倍数。</li>
<li>8位生存时间（TTL）是<strong>数据报到达目的地之前允许经过的路由器跳数。TTL在发送时被设置（常见值64）</strong>。数据报文在转发过程中<strong>每经过一个路由，该值就被路由器减1</strong>，当TTL减为0时，数据包会被丢弃，并且向源发送一个ICMP差错报文。TTL可以防止数据报陷入路由循环。</li>
<li>8位协议用来区分上层协议，其中 ICMP是1，TCP是6，UDP是17。</li>
<li>32位源端地址和32位目标端地址 。我们前面提到了<strong>IP协议是无状态，无连接的</strong>。因此<strong>每次发送数据都要携带目标端的IP地址，同样为了能让目标段给源端发响应数据包，IP头中还会带一个源端地址</strong>。这两个IP地址在某个局域网内传输时候，不会发生改变。但是经过网关的时候，NAT协议会将源和目标的MAC地址和IP地址进行替换。</li>
<li>IPv4最后一个选项是一个可变的最多为40个字节的可选信息。因为头部固定占了20个字节且IP头最大可以有60个字节，所以这个可选信息最多40个字节。这个部分可以记录以下几种信息：<ul>
<li>记录路由，沿途进过的路由。</li>
<li>时间戳，可用于计算每个路由之间的传输时间。</li>
<li>路由选择(松散路由选择、严格路由选择)，指定路由过程中必须经过或全部必须经过的路由。</li>
</ul>
</li>
</ul>
<h4 id="路由与转发"><a href="#路由与转发" class="headerlink" title="路由与转发"></a>路由与转发</h4><p>IP协议的一个核心的任务是数据报文的路由，即决定数据报到目标机器的路径。</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20210817233637.png" srcset="/img/loading.gif"></p>
<p>简单分析上面的图从左下角的IP输入队列开始。</p>
<ul>
<li><p>当IP模块接收到来自数据链路层的IP数据报，它<strong>首先对该数据报的头部做CRC校验</strong>，确认无误后就分析头部的具体信息。</p>
</li>
<li><p>如果该IP数据报的头部中目标IP地址是本机的某个IP地址，或者是广播地址，即<strong>该数据包是给本机的，则IP模块就根据数据报头部中的协议字段来决定将它派发给某个上层应用协议</strong>，<strong>如果不是</strong>发现这个数据报不是给本机的，则也<strong>调用数据报转发子模块来处理</strong>该数据报。</p>
</li>
<li><p>数据报转发模块会检测系统是否<strong>允许转发，如果不允许，数据报将会被丢弃。如果允许，数据转发模块将会对数据报进行一些操作，然后交给IP报文输出模块</strong>。</p>
</li>
</ul>
<blockquote>
<p>转发模块会做如下操作：</p>
<ol>
<li><p>检查数据报文头部的TTL值，如果<strong>TTL值已经是0，则丢弃该数据报。</strong></p>
</li>
<li><p>检查数据头部的<strong>严格路由选择</strong>选项，如果该选项被设置，则检查数据报的目标IP地址是否是本机的某个IP，如果<strong>不是</strong>，发送一个<strong>ICMP差错报文给发送端。</strong></p>
</li>
<li><p>如果有必要，则给源端发送一个ICMP重定向报文，以告诉它一个更合理的下一跳路由。</p>
</li>
<li><p><strong>将TTL的值减1</strong>。</p>
</li>
<li><p><strong>处理IP头部</strong>选项</p>
</li>
<li><p>如果有必要，执行<strong>IP分片</strong>操作。</p>
</li>
</ol>
</blockquote>
<ul>
<li>IP数据报<strong>应该发送至哪个下一跳路由（或目标主机）</strong>，以及经过哪个网卡来发送，就是IP路由过程，即图中“计算下一跳路由模块。IP模块实现数据报路由的核心数据结构是<strong>IP路由表</strong>。这个表按照数据报的目标IP地址分类，同一类型的IP数据报将会被发往相同的下一跳路由或目标主机。</li>
<li>IP输出队列中存放的是<strong>所有等待发送的IP数据报。</strong></li>
<li>图中的虚线箭头显示了路由表更新的过程，这一过程指的通过路由协议或者route命令调整路由表，使之更快适应新的网络拓扑结构，成为IP路由策略。</li>
</ul>
<blockquote>
<p>IP的路由策略：</p>
<ol>
<li><p>查找路由表中的数据报的<strong>目标IP地址完全匹配</strong>的主机IP地址。如果找到，就使用该路由项，没找到转步骤2。</p>
</li>
<li><p>查找路由表中的数据报<strong>目标IP地址具有相同网络ID</strong>的网络IP地址。如果找到，就使用该路由项，没找到转步骤3。</p>
</li>
<li><p>选择<strong>默认路由项</strong>，这通常意味着数据报的下一跳是网关。</p>
</li>
</ol>
</blockquote>
<h3 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h3><p>我们通常在网络不是很好的时候，习惯使用<code>ping</code>命令去检查下网络的情况。而ping命令则是基于ICMP协议工作的。<code>ICMP</code> 全称 I<strong>nternet Control Message Protocol</strong>。即<strong>互联网控制报文协议</strong>。这里面的具体怎么“控制”的呢？网络包在异常复杂的网络环境中传输时，常常会遇到各种各样的问题。当遇到问题的时候，我们不能直接忽视问题。而是需要去探查问题的情况，然后<strong>根据结果来调整传输策略</strong>。I<strong>CMP报文是封装在IP包里面的</strong>，并且本身足够<strong>轻量</strong>以方便探测。</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20210904143454.png" srcset="/img/loading.gif"></p>
<p>ICMP报文有很多种类型，不同的类型有不同的代码。<strong>最常用的类型是主动请求为8，主动请求的应答为0。</strong></p>
<h4 id="查询报文类型"><a href="#查询报文类型" class="headerlink" title="查询报文类型"></a>查询报文类型</h4><p>ICMP查询报文类型，即<strong>主动探测网络的报文类型</strong>。我们常用的ping命令就是<strong>查询报文，是一种主动请求，并且获得主动应答的ICMP协议。</strong>因此ping发出的包也是符合ICMP协议格式的，只不过它在后面增加了自己的格式。</p>
<p>对于ping 主动请求，进行网络抓包，称为<code>ICMP ECHO REQUEST</code>。同理主动请求的回复，称为<code>ICMP ECHO REPLY</code>。比起原生的 ICMP，这里多了两个字段，一个是标识符号，另外一个是序号，在选项数据中，ping 还会<strong>存放发送请求的时候，来计算往返时间，说明路程的长短。</strong></p>
<h4 id="差错报文类型"><a href="#差错报文类型" class="headerlink" title="差错报文类型"></a>差错报文类型</h4><p>如果一切顺利，我们我们收到主动请求回复，但是<strong>如果不顺利，那么我们就会收到差错报文</strong>，<strong>不同的异常情况也对应着不同的差错报文类型</strong>。其中比较常见的例子：<strong>终点不可达为 3， 源抑制为 4，超时为 11，重定向为 5</strong>。</p>
<ul>
<li><p>终点不可达：就是字面意思，目标不可达。</p>
</li>
<li><p>源抑制：让源站放慢发送速度。</p>
</li>
<li><p>时间超时：超过了网络包的生存时间，但是网络包还是没有达到目标端。</p>
</li>
<li><p>重定向：下次发给另外一个路由。</p>
</li>
</ul>
<h4 id="Traceroute：差错报文类型的使用"><a href="#Traceroute：差错报文类型的使用" class="headerlink" title="Traceroute：差错报文类型的使用"></a>Traceroute：差错报文类型的使用</h4><p>我之前会用<code>traceroute</code>命令去查看，数据包经过了哪些路由器，经过了多少跳。而<code>traceroute</code><strong>通过设置特殊的TTL，来追踪去往目的地沿途经过的路由器</strong>。当使用traceroute命令指向某个地址时，它会发送一个UDP的数据包，并且<strong>将TTL设置为1</strong>。这样遇到第一个路由，路由就会发现这个数据包“<strong>生命结束</strong>”了，并返回一个<strong>ICMP的差错报文类型是时间超时</strong>，这个报文里面就带有了这个路由器的IP地址。然后<strong>源端发送第二个UDP数据包，并将TTL设置为2</strong>。这个时候遇到第二个路由时就会返回一个ICMP差错报文。同理这样就可以一步步拿到沿途经过的路由IP。当然也有路由器压根就不会返回 ICMP差错报文，所以我们会看到输出“*<strong>”了。</strong>traceroute 还有一个作用就是故意不设置不分片，从而测试网络路径的MTU。</p>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>传输层位于TCP/IP协议族中的第4层，这一层的协议为应用进程提供端到端的通信服务。它提供面向连接的数据流支持、可靠连接、流量控制和多路重用等服务。这一层主要的协议有<code>TCP</code>和<code>UDP</code>。</p>
<h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><p>UDP是<code>User Datagram Protocol</code>的简称，中文名是<strong>用户数据报协议</strong>。UDP是一种无连接传输层协议，提供<strong>简单不可靠的信息传送服务</strong>。它在传输过程中并不会与目标端建立一个“连接”，只是简单的把数据包丢入网络中，然后任其自生自灭。如果把UDP比喻成人的话，UDP就像是一个相信世界美好的孩子。相信网路链路的“美好”即相信发出即可送达，没有经验也不会去处理一些拥塞，丢包的异常场景。</p>
<blockquote>
<p>这里提到了一个“连接”，这个连接是抽象的，并不是真的有两个通信端之间有一个类似“网线”一样的东西，他们只是靠通信的两端维护一定的数据结构保持某种状态，来记录和维护这样一个“连接”的状态。</p>
</blockquote>
<p>UDP的包头如下，通过包头我们也不难发现这是个简单没有什么复杂“想法”的协议。</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20210820000409.png" srcset="/img/loading.gif"></p>
<h4 id="UDP的特点与使用场景"><a href="#UDP的特点与使用场景" class="headerlink" title="UDP的特点与使用场景"></a>UDP的特点与使用场景</h4><p>通过上面对UDP的介绍我们很容易就可以了解到UDP的特点：</p>
<ul>
<li><strong>轻量</strong>、<strong>简单</strong>。</li>
<li><strong>不能应对复杂的网络情况</strong>，没有流量控制，没有应答机制，不能处理丢包、重发、错序等问题。</li>
</ul>
<p>UDP虽然简单，但是简单也有简单的用法。基于这些特点，我们也可以用在以下的场景中：</p>
<ol>
<li><p><strong>需要资源少，网络情况比较好的内网，或者对于丢包不敏感的应用</strong>。DHCP协议就是基于UDP的，DHCP中一般获取IP地址都是内网请求，而且可以重复多次获取请求。</p>
</li>
<li><p><strong>不需要一对一建立连接，而是可以进行广播的应用</strong>。UDP不面向连接的功能，可以使用承载广播或者多播的协议。DHCP就是一种广播形式的协议。</p>
</li>
<li><p><strong>需要处理速度快，延时低，可以容忍少数丢包，但是要求即便网络拥塞也不能降低速率</strong>。UDP简单、处理速度快，在例如直播、游戏等实时性要求比较高的场景中，丢了一两个包也无关紧要，但是如果延时过高则很难接受，这种场景中也基本使用UDP进行传输。</p>
</li>
</ol>
<blockquote>
<p>简单并不代表低级，简单同时也意味着更高的可拓展性。</p>
</blockquote>
<p>同时因为UDP简单，可自定义拓展性也更高，因此现在也有不少基于UDP特性拓展出来上层协议和应用领域。</p>
<ol>
<li><p><strong>QUIC（全称 Quick UDP Internet Connections，快速UDP互联网连接）是Google 提出的一种基于UDP改进的通信协议</strong>，其目的是降低网络通行的延迟，提供更好的用户互动体验。QUIC在应用层上，会自己实现快速连接，减少重传时延，自适应拥塞控制。</p>
</li>
<li><p><strong>流媒体协议</strong>，现在很多直播协议是基于RTMP的，RTMP是基于TCP实现的流媒体协议，但是流媒体协议要求较高的实时性，现在很多直播平台都基于UDP实现了自己的流媒体传输协议。</p>
</li>
<li><p><strong>实时游戏领域</strong>，同理，如果想要更高的实时性，TCP并不是一个好的选择，基于UDP的实现的传输协议能带来更好的实时性游戏体验。</p>
</li>
<li><p><strong>IoT 物联网</strong>，物联网领域的终端往往都是嵌入式的系统，内存小性能差，可能维护一个TCP连接对于这些系统来说都是一个不小的开销。而且物联网也要求较高的实时性，Google 旗下的 Nest 建立的 Thread Group 推出的 Thread 物联网通行协议就是基于UDP的。</p>
</li>
<li><p><strong>移动通信领域</strong>。在4G网络里，移动流量上网的数据面对的协议 GTP-U是基于UDP的，因为移动通信协议本身就比较复杂，如果基于TCP，TCP的机制就会显得非常多余。</p>
</li>
</ol>
<h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>前面我们介绍的<code>UDP</code>协议是面向无连接，不可靠的协议。而与<code>UDP</code>协议刚好相反，<code>TCP</code>是面向连接，提供可靠的传输层协议。其中我们熟知的<code>HTTP</code>、<code>FTP</code>、<code>SMTP</code>、<code>TELNET</code>和<code>SSH</code>等应用层协议都是基于<strong>可靠的TCP协议</strong>进行传输的。在复杂的网络环境中，保证可靠且高效的传输并非是一件容易的事。TCP协议通过<strong>三次握手四次挥手</strong>来建立稳定可靠的连接，通过<strong>应答机制、滑动窗口和拥塞窗口</strong>等流量控制手段来保证传输的可靠性。最后通过各种<strong>拥塞算法</strong>实现对网络带宽的充分利用。由于TCP协议涉及内容篇幅较长，我们会在下一小结进行详细分析和解读。😉</p>
<blockquote>
<p> TCP协议的算法设计能带来很多思想层面的启示。✊🏼</p>
</blockquote>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>在传输层的上层应用层有很多的协议，这些协议基于TCP的可靠传输和UDP的简单低延迟的特点，可以“玩出了很多花样“，其中有我们熟悉的用于邮件收发的<code>SMTP</code>协议，文件传输的<code>FTP</code>协议和用于服务器的<code>SSH</code>、<code>TELNET</code>协议等。当然还有我们最熟悉的用于WEB服务的<code>HTTP</code>协议。这里我们就不对<code>HTTP</code>协议的细节进行展开了，毕竟这个协议我们每天开发过程中多多少少都会用到。但是有一个问题我们聊到，就是<code>HTTP1</code>和<code>HTTP2</code>之间的区别。说实话<code>HTTP2</code>我也用的少，我们日常开发中的请求也基本都是<code>HTTP1</code>。</p>
<h3 id="HTTP1与HTTP2-之间的区别"><a href="#HTTP1与HTTP2-之间的区别" class="headerlink" title="HTTP1与HTTP2 之间的区别"></a>HTTP1与HTTP2 之间的区别</h3><p>HTTP/2（超文本传输协议第2版，最初命令为HTTP2.0），是HTTP协议的第二个版本，使用于万维网。HTTP/2是HTTP协议自1999年HTTP 1.1 发布后的首个更新，主要基于SPDY协议（是Google开发的基于TCP的应用层协议，用以最小网络延迟，提升网速，优化用户使用体验）。主要区别集中于下面四个方面：</p>
<ol>
<li><p><code>HTTP/2</code> 采用二进制格式而非文本格式。</p>
</li>
<li><p><code>HTTP/2</code> 是完全多路复用的，而非有序并阻塞的，只需要一个连接即可实现并行。</p>
</li>
<li><p>通过压缩包头，<code>HTTP/2</code>降低了开销。</p>
</li>
<li><p><code>HTTP/2</code>让服务器可以将主动的“推送”到客户端缓存中。</p>
</li>
</ol>
<h4 id="二进制协议"><a href="#二进制协议" class="headerlink" title="二进制协议"></a>二进制协议</h4><p>最新的<code>HTTP</code>版本在功能和属性（例如从文本协议转换为二进制协议）方面已经有了重大发展，<code>HTTP1.x</code>用于处理文本命令已完成请求-响应周期。<code>HTTP/2</code>将使用二进制命令执行相同的任务，此属性减轻了框架的复杂性，并简化了由于包含文本和可选空格的命令而导致混淆的命令和实现。<strong>使用HTTP/2实现的浏览器会将相同的文本命令转换为二进制命令，然后再通过网络传输。</strong></p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20210828235701.png" srcset="/img/loading.gif"></p>
<h4 id="请求多路复用"><a href="#请求多路复用" class="headerlink" title="请求多路复用"></a>请求多路复用</h4><p><code>HTTP/1.x</code>有个问题叫线端阻塞（head-of-blocking），它是指一个连接（connection）一次只提交一个请求的效率比较高，多了就会变慢。<code>HTTP/1.1</code>试过用流水线（pipelining）来解决这个问题，但是效果并不理想（数据量较大或者速度较高的响应，会阻碍排在他后面的请求），此外，由于网络媒介（intermediary）和服务器不能很好的支持流水线，导致部署起来困难重重。<strong>而多路传输（Multiplexing）能很好的解决这些问题，因为它能同时处理很多个消息的请求和响应</strong>；甚至可以在传输过程中将一个消息和另一个掺杂在一起。所以客户端只需要一个连接就能加载一个页面。</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20210829005226.png" srcset="/img/loading.gif"></p>
<h4 id="标头压缩"><a href="#标头压缩" class="headerlink" title="标头压缩"></a>标头压缩</h4><p><code>HTTP/2</code>压缩大量冗余头帧。它使用HPACK规范作为标头压缩的简单安全方法。客户端和服务器都在维护在先前的客户端-服务器请求中使用的标头列表。<strong>HPACK 在将每个标头传输到服务器之前先压缩每个标头的单独值，然后服务器在先前传输的标头值列表中查找编码信息，以重建完整的标头信息。</strong></p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20210829005245.png" srcset="/img/loading.gif"></p>
<h4 id="HTTP-2服务器推送"><a href="#HTTP-2服务器推送" class="headerlink" title="HTTP/2服务器推送"></a>HTTP/2服务器推送</h4><p><strong>此功能使用服务器可以向客户端发送其他未缓存的信息，但这些信息会在以后的请求中得到预期</strong>。例如客户端请求资源X，并且可以理解资源Y被请求文件引用，则服务器可以选择将Y与X一起推送，而不是等待适当的客户端请求。</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20210829005612.png" srcset="/img/loading.gif"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个部分我们介绍了大家大学基本上都记过的计算机网络模型，其中包括OSI七层模型，TCP/IP五层模型，其中OSI七层模型更多的是针对<strong>特定的功能</strong>来进行划分的，而TCP/IP五层模型则更多的针对的是<strong>协议划分</strong>，我们软件开发也更侧重于TCP/IP的五层模型。其中我们介绍了每一层都有哪些代表协议，不知道你现在还能不能记起来。在第二个部分，我们介绍了一个数据包是流转于模型的每一层之间，并且介绍了这个数据包是如何在网络上进行传输的。在最后一个大模块中，我们顺着模型从下往上介绍了每一层具有代表性的网络协议。在数据链路层，我们介绍了用于获取mac地址的ARP协议，网络层介绍了扛把子IP协议和网络探子ICMP协议，传输层则介绍了傻白甜的UDP协议和给TCP协议挖的一个坑。最后应用层，我们简单提了下HTTP/1和HTTP/2之间的区别。通过这一小节的梳理，基本上对网络也有了一个大体认知。下一节我们将深入梳理TCP协议，看看TCP是如何保证数据包又好又快地在复杂的网络环境中传输的。</p>
<h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><ul>
<li><p><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/8094">趣谈网络协议（从物理层到MAC层：如何在宿舍里自己组网玩联机游戏？）</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/8445">趣谈网络协议（ICMP与ping：投石问路的侦察兵）</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41727218/article/details/82461089">IP协议详解</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://book.douban.com/subject/26941639/">网络是怎么连接的</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://haicoder.net/note/http-interview/http-interview-http1-http2.html">HTTP1与HTTP2区别</a></p>
</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/NIO%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">NIO与网络编程</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Java%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84%E6%A2%B3%E7%90%86/">Java知识结构梳理</a>
                    
                      <a class="hover-with-bg" href="/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">学习总结</a>
                    
                      <a class="hover-with-bg" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/08/02/icebreaker-of-JIT/">
                        <span class="hidden-mobile">JVM 进阶 — 即时编译入门</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
