

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/blogFavicon.png">
  <link rel="icon" href="/img/blogFavicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  
    <meta name="description" content="">
  
  <meta name="author" content="Daiwei">
  <meta name="keywords" content="">
  
  <title>核心组件源码剖析 — Channel - Daiwei‘s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.8","typing":{"enable":true,"typeSpeed":100,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Daiwei's blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://gitee.com/realDaiwei/img/raw/master/eagan-hsu-dguqz2wBG4Y-unsplash.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="核心组件源码剖析 — Channel">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-11-05 08:38" pubdate>
        2021年11月5日 早上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      28
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">核心组件源码剖析 — Channel</h1>
            
            <div class="markdown-body">
              <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一小节我们梳理了NioEventLoop，通过梳理我们知道，NioEventLoop本质上就是封装的执行线程，线程通过NioEventLoopGroup构造创建。NioEventLoop通过<code>select()</code>方法监听selectKey触发对应连接，读/写事件。并在每次的循环中执行一定的任务队列中的任务。而每次事件的触发都是基于Channel实现的。这里的Channel不是NIO中的Channel，而是我们Netty中封装了NIO Channel实现的Channel。这一小节我们将深入理解Channel的一些功能原理和具体的一些实现细节。</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Channel是Netty抽象出来的对网络I/O进行读写的相关接口，与NIO中的Channel接口类似。Channel的主要功能有<strong>网络I/O的读写</strong>、<strong>客户端发起连接</strong>、<strong>主动关闭连接</strong>、<strong>获取通信双方网络地址</strong>等。Channel接口下有一个重要的抽象类—AbstractChannel，一些公共的基础方法都在这个抽象类中实现，一些特定的功能可以通过各个不同的实现类去实现，最大限度的实现了接口的功能和接口的重用。</p>
<p>AbstractChannel融合了Netty的<strong>线程模型</strong>、<strong>事件驱动模型</strong>。但由于网络I/O模型及各种协议种类比较多，除了TCP协议，Netty还支持很多其他的连接协议，并且每种协议都有传统阻塞I/O和NIO（非阻塞IO）的版本区别。不同阻塞类型的连接有不同的Channel类型与之对应，因此AbstractChannel并没有直接与网络I/O相关的直接操作。每种阻塞与非阻塞Channel在AbstractChannel上都会继续抽象一层，如AbstractNioChannel，既是Netty重新封装的Epoll SockeChannel实现，也是其他非阻塞I/O Channel的抽象层。</p>
<h1 id="AbstractChannel-源码分析"><a href="#AbstractChannel-源码分析" class="headerlink" title="AbstractChannel 源码分析"></a>AbstractChannel 源码分析</h1><p>AbstractChannel 抽象类包括以下几个重要属性：</p>
<ul>
<li><p><code>EventLoop</code>：每个Channel对应一条EventLoop线程。</p>
</li>
<li><p><code>DefaultChannelPipeline</code>：一个Handler的容器，也可以将其理解为一个Handler链。Handler主要处理数据的编/解码和业务逻辑。</p>
</li>
<li><p><code>Unsafe</code>：实现具体的连接与读/写数据，如网络的读/写、链路关闭、发起连接等。命名为<strong>Unsafe表示不对外提供使用，并非不安全。</strong></p>
</li>
</ul>
<p>下图是AbstractChannel的功能图，从图中可以看出，Unsafe属性的功能非常全面，并且AbstractChannel中有一个Unsafe抽象类—AbstractUnsafe。</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20211021084256.png" srcset="/img/loading.gif"></p>
<p>AbstractUnSafe的大部分方法都采用了<strong>模版设计模式</strong>，具体细节由其子类完成。例如bind()方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.channel.AbstractChannel.AbstractUnsafe#bind</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;<br>    assertEventLoop();<br><br>    <span class="hljs-keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// See: https://github.com/netty/netty/issues/576</span><br>    <span class="hljs-keyword">if</span> (Boolean.TRUE.equals(config().getOption(ChannelOption.SO_BROADCAST)) &amp;&amp;<br>        localAddress <span class="hljs-keyword">instanceof</span> InetSocketAddress &amp;&amp;<br>        !((InetSocketAddress) localAddress).getAddress().isAnyLocalAddress() &amp;&amp;<br>        !PlatformDependent.isWindows() &amp;&amp; !PlatformDependent.maybeSuperUser()) &#123;<br>        <span class="hljs-comment">// Warn a user about the fact that a non-root user can&#x27;t receive a</span><br>        <span class="hljs-comment">// broadcast packet on *nix if the socket is bound on non-wildcard address.</span><br>        logger.warn(<br>            <span class="hljs-string">&quot;A non-root user can&#x27;t receive a broadcast packet if the socket &quot;</span> +<br>            <span class="hljs-string">&quot;is not bound to a wildcard address; binding to a non-wildcard &quot;</span> +<br>            <span class="hljs-string">&quot;address (&quot;</span> + localAddress + <span class="hljs-string">&quot;) anyway as requested.&quot;</span>);<br>    &#125;<br>	<br>    <span class="hljs-keyword">boolean</span> wasActive = isActive();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 模版设计模式，调用子类NioServerSocketChannel的doBind()方法。</span><br>        doBind(localAddress);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-comment">//绑定失败回调</span><br>        safeSetFailure(promise, t);<br>        closeIfClosed();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>	<span class="hljs-comment">//从非活跃状态到活跃状态触发了active事件</span><br>    <span class="hljs-keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;<br>        invokeLater(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                pipeline.fireChannelActive();<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-comment">// 绑定成功回调通知</span><br>    safeSetSuccess(promise);<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="AbstractNioChannel源码剖析"><a href="#AbstractNioChannel源码剖析" class="headerlink" title="AbstractNioChannel源码剖析"></a>AbstractNioChannel源码剖析</h1><p>AbstractNioChannel也是一个抽象类，不过他在AbstractChannel的基础上有封装了一层属性和方法，AbstractChannel没有涉及NIO的任何属性和具体方法，包括AbstractUnsafe。AbstractNioChannel有以下三个重要属性：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SelectableChannel ch; <span class="hljs-comment">// 真正用到的NIO Channel</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> readInterestOp; <span class="hljs-comment">// 监听感兴趣的事件</span><br><span class="hljs-keyword">volatile</span> SelectionKey selectionKey; <span class="hljs-comment">// 注册到Selector后获取的Key</span><br></code></pre></td></tr></table></figure>

<p><code>SelectableChannel</code>是java.nio.SocketChannel和java.nio.ServerSocketChannel公共的抽象类，同时它也是Java NIO Channel的接口实现。<code>readInterestOp</code>用于区分当前Channel监听的事件类型。<code>selectionKey</code>它是将Channel注册到Selector上后的返回值。从这些属性不难看出，在AbstractChannel中，已经将Netty的Channel和Java NIO的channel关联起来了。AbstractNioChannel的方法都很简洁，下面是一个很重要的方法<code>doRegister()</code>的源码剖析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.channel.nio.AbstractNioChannel#doRegister</span><br><span class="hljs-comment">//doRegister()方法在AbstractUnsafe的io.netty.channel.AbstractChannel.AbstractUnsafe#register0被调用</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doRegister</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">boolean</span> selected = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//通过javaChannel()方法获取具体的Nio Channel，把Channel注册到其EventLoop线程的Selector上，</span><br>            <span class="hljs-comment">// 注册返回后的 selectionKey，为其设置channel感兴趣的事件。</span><br>            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException e) &#123;<br>            <span class="hljs-keyword">if</span> (!selected) &#123;<br>                <span class="hljs-comment">// Force the Selector to select now as the &quot;canceled&quot; SelectionKey may still be</span><br>                <span class="hljs-comment">// cached and not removed because no Select.select(..) operation was called yet.</span><br>                <span class="hljs-comment">//调用select方法来清空selectionKey的缓存</span><br>                eventLoop().selectNow();<br>                selected = <span class="hljs-keyword">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// We forced a select operation on the selector before but the SelectionKey is still cached</span><br>                <span class="hljs-comment">// for whatever reason. JDK bug ?</span><br>                <span class="hljs-keyword">throw</span> e;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>doRegister()方法在AbstractUnsafe的register0()方法中被调用。在AbstractNioChannel中有一个非常重要的子类—AbstractNioUnsafe，是AbstractUnsafe类的Nio实现，主要实现了<code>connect()</code>、<code>flush0()</code>等方法。它还实现了NioUnsafe接口，实现了其<code>finishConnect()</code>、<code>forceFlush()</code>、<code>ch()</code>等方法，其中，<code>forceFlush()</code>与<code>flush0()</code>最终调用的NioSocketChannel的<code>doWrite()</code>方法，来完成缓存数据写入Socket的工作。<code>connect()</code> 和 <code>finishConnect()</code> 这两个方法只有在Netty客户端中才会用到。下面是对这两个方法的解析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.channel.nio.AbstractNioChannel.AbstractNioUnsafe#connect</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">final</span> SocketAddress remoteAddress, <span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;<br>    <span class="hljs-comment">// 设置任务为不可取消状态，并确认Channel已经打开</span><br>    <span class="hljs-keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//确保没有正在进行的连接</span><br>        <span class="hljs-keyword">if</span> (connectPromise != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// Already a connect in process.</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConnectionPendingException();<br>        &#125;<br>		<span class="hljs-comment">// 获取之前的状态</span><br>        <span class="hljs-keyword">boolean</span> wasActive = isActive();<br>        <span class="hljs-comment">// 在远程连接之前，会出现以下三种结果。</span><br>        <span class="hljs-comment">// 1、连接成功，返回true</span><br>        <span class="hljs-comment">// 2、暂时没有连接上，服务端没有返回ACK应答，连接结果不确定，返回false</span><br>        <span class="hljs-comment">// 3、连接失败，直接抛出I/O异常。</span><br>        <span class="hljs-comment">// 由于协议和IO模型的不同，连接方式也不一样，因此具体的实现方式由其子类来实现。</span><br>        <span class="hljs-keyword">if</span> (doConnect(remoteAddress, localAddress)) &#123;<br>            <span class="hljs-comment">//连接成功后会触发ChannelActive事件</span><br>            <span class="hljs-comment">//最终将会NioSocketChannel中的selectionKey</span><br>            <span class="hljs-comment">//设置为SelectionKey.OP_READ</span><br>            <span class="hljs-comment">//用于监听网络读操作位</span><br>            fulfillConnectPromise(promise, wasActive);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            connectPromise = promise;<br>            requestedRemoteAddress = remoteAddress;<br><br>            <span class="hljs-comment">//获取连接超时时间</span><br>            <span class="hljs-comment">// Schedule connect timeout.</span><br>            <span class="hljs-keyword">int</span> connectTimeoutMillis = config().getConnectTimeoutMillis();<br>            <span class="hljs-keyword">if</span> (connectTimeoutMillis &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">//根据连接超时时间设置定时任务</span><br>                connectTimeoutFuture = eventLoop().schedule(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                        ChannelPromise connectPromise = AbstractNioChannel.<span class="hljs-keyword">this</span>.connectPromise;<br>                        <span class="hljs-keyword">if</span> (connectPromise != <span class="hljs-keyword">null</span> &amp;&amp; !connectPromise.isDone()<br>                            &amp;&amp; connectPromise.tryFailure(<span class="hljs-keyword">new</span> ConnectTimeoutException(<br>                                <span class="hljs-string">&quot;connection timed out: &quot;</span> + remoteAddress))) &#123;<br>                            <span class="hljs-comment">//如果发现连接并没有完成，则关闭连接句柄，释放资源</span><br>                            <span class="hljs-comment">//设置异常堆并发起取消注册操作</span><br>                            close(voidPromise());<br>                        &#125;<br>                    &#125;<br>                &#125;, connectTimeoutMillis, TimeUnit.MILLISECONDS);<br>            &#125;<br><br>            <span class="hljs-comment">//增加连接结果监听器</span><br>            promise.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    <span class="hljs-comment">// 如果接收连接完成的通知，则判断是否被取消</span><br>                    <span class="hljs-comment">// 如果被取消则关闭连接句柄，释放资源，发起取消注册操作</span><br>                    <span class="hljs-keyword">if</span> (future.isCancelled()) &#123;<br>                        <span class="hljs-keyword">if</span> (connectTimeoutFuture != <span class="hljs-keyword">null</span>) &#123;<br>                            connectTimeoutFuture.cancel(<span class="hljs-keyword">false</span>);<br>                        &#125;<br>                        connectPromise = <span class="hljs-keyword">null</span>;<br>                        close(voidPromise());<br>                    &#125;<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        promise.tryFailure(annotateConnectException(t, remoteAddress));<br>        <span class="hljs-comment">//关闭连接句柄，释放资源，发起取消注册操作。</span><br>        <span class="hljs-comment">//从多路复用器上移除</span><br>        closeIfClosed();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>finishConnect()方法解读分析：</p>
<p>finishConnect() 只是在连接完成后调用，用于设置一些状态操作位置，并不是结束连接的字面意思。。不是关闭连接不是关闭连接的意思。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// io.netty.channel.nio.AbstractNioChannel.AbstractNioUnsafe#finishConnect</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finishConnect</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Note this method is invoked by the event loop only if the connection attempt was</span><br>    <span class="hljs-comment">// neither cancelled nor timed out.</span><br>	<span class="hljs-comment">// 只有EventLoop线程才能调用finishConnect()方法</span><br>    <span class="hljs-comment">// 此方法在NioEventLoop的processSelectedKey()方法中调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">assert</span> <span class="hljs-title">eventLoop</span><span class="hljs-params">()</span>.<span class="hljs-title">inEventLoop</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">boolean</span> wasActive = isActive();<br>        <span class="hljs-comment">// 判断连接结果（由其子类完成）</span><br>        <span class="hljs-comment">// 通过SocketChannel的finishConnect()方法判断连接结果</span><br>        <span class="hljs-comment">// 连接成功返回true</span><br>        <span class="hljs-comment">// 连接失败抛出异常</span><br>        <span class="hljs-comment">// 链路被关闭，链路中断等异常也属于连接失败。</span><br>        doFinishConnect();<br>        <span class="hljs-comment">// 负责将SocketChannel修改为监听读操作位</span><br>        fulfillConnectPromise(connectPromise, wasActive);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-comment">// 连接失败，关闭连接句柄，释放资源，发起取消注册操作。</span><br>        fulfillConnectPromise(connectPromise, annotateConnectException(t, requestedRemoteAddress));<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// Check for null as the connectTimeoutFuture is only created if a connectTimeoutMillis &gt; 0 is used</span><br>        <span class="hljs-comment">// See https://github.com/netty/netty/issues/1770</span><br>        <span class="hljs-keyword">if</span> (connectTimeoutFuture != <span class="hljs-keyword">null</span>) &#123;<br>            connectTimeoutFuture.cancel(<span class="hljs-keyword">false</span>);<br>        &#125;<br>        connectPromise = <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="AbstractNioByteChannel源码剖析"><a href="#AbstractNioByteChannel源码剖析" class="headerlink" title="AbstractNioByteChannel源码剖析"></a>AbstractNioByteChannel源码剖析</h1><p>AbstractNioChannel拥有NIO的Channel，<strong>具备NIO的注册、连接等功能</strong>。但IO的读写交给了其子类，Netty对IO的读写分配POJO对象与ByteBuf和FileRegion，因此在AbstractNioChannel的基础上继续抽象一层，分为AbstractNioMessageChannel与AbstractNioByteChannel。这一个部分我们详细深入AbstractNioByteChannel。它发送和读取的对象是ByteBuf与FileRegion类型。</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20211025084533.png" srcset="/img/loading.gif"></p>
<p>首先flushTask为Task任务，主要负责刷新发送缓存链表中的数据，由于<code>write()</code>的数据没有直接写在Socket中，而是写在ChannelOutboundBuffer缓存中，所以当调用<code>flush()</code>方法的时，会把数据写入Socket中并向网络中发送。因此当缓存中的数据未发送完成时，需要将任务添加到EventLoop线程中，等待EventLoop线程的再次发送。</p>
<blockquote>
<p><strong>wirte 只是写入了缓存中，只有flush()才是写入了Socket发送。</strong></p>
</blockquote>
<p>doWrite()与doWriteInteral()方法在AbstractChannel的<code>flush0()</code>方法中被调用，主要功能是从ChannelOutboundBuffer缓存中获取待发送的数据，进行循环发送，发送的结果分为下面三种：</p>
<ol>
<li><strong>发送成功，跳出循环直接返回。</strong></li>
<li><strong>由于TCP缓存区已满，成功发送的字节数为0，跳出循环，并将写操作OP_WRITE事件添加到选择Key兴趣事件集中。</strong></li>
<li><strong>默认当写了16此数据还未发送完成时，把选择Key的OP_WRITE事件从兴趣事件集合中移除，并添加一个flushTask任务，先去执行其他任务，当监测到此任务时再发送。</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.channel.nio.AbstractNioByteChannel#doWrite</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doWrite</span><span class="hljs-params">(ChannelOutboundBuffer in)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">//写请求自循环次数，默认为16次</span><br>    <span class="hljs-keyword">int</span> writeSpinCount = config().getWriteSpinCount();<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">//获取当前Channel的缓存ChannelOutboundBuffer中的当前待刷新消息</span><br>        Object msg = in.current();<br>        <span class="hljs-comment">//所有消息都发送成功了</span><br>        <span class="hljs-keyword">if</span> (msg == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//清空 Channel 选择Key兴趣事件集中的OP_WRITE写事件</span><br>            <span class="hljs-comment">// Wrote all messages.</span><br>            clearOpWrite();<br>            <span class="hljs-comment">// Directly return here so incompleteWrite(...) is not called.</span><br>            <span class="hljs-comment">//直接返回，没必要再添加写任务</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//发送数据</span><br>        writeSpinCount -= doWriteInternal(in, msg);<br>    &#125; <span class="hljs-keyword">while</span> (writeSpinCount &gt; <span class="hljs-number">0</span>);<br>	<span class="hljs-comment">// 当因缓冲区满了而发送失败时 doWriteInternal 返回 Integer.MAX_VALUE</span><br>    <span class="hljs-comment">// 此时 writeSpinCount &lt; 0 为 true</span><br>    <span class="hljs-comment">// 当发送16次还未发送完，但每次都写成功时，writeSpinCount为0</span><br>    incompleteWrite(writeSpinCount &lt; <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.nio.AbstractNioByteChannel#doWriteInternal</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doWriteInternal</span><span class="hljs-params">(ChannelOutboundBuffer in, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> ByteBuf) &#123;<br>        ByteBuf buf = (ByteBuf) msg;<br>        <span class="hljs-comment">//若可读字节数为0，则从缓存区中移除</span><br>        <span class="hljs-keyword">if</span> (!buf.isReadable()) &#123;<br>            in.remove();<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>		<span class="hljs-comment">// 实际发送字节数据</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> localFlushedAmount = doWriteBytes(buf);<br>        <span class="hljs-keyword">if</span> (localFlushedAmount &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 更新字节数据的发送进度</span><br>            in.progress(localFlushedAmount);<br>            <span class="hljs-keyword">if</span> (!buf.isReadable()) &#123;<br>                <span class="hljs-comment">//若可读字节数为0，则从缓存区中移除</span><br>                in.remove();<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> FileRegion) &#123;<br>        <span class="hljs-comment">//如果是文件FileRegion消息</span><br>        FileRegion region = (FileRegion) msg;<br>        <span class="hljs-keyword">if</span> (region.transferred() &gt;= region.count()) &#123;<br>            in.remove();<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>		<span class="hljs-comment">//实际写操作</span><br>        <span class="hljs-keyword">long</span> localFlushedAmount = doWriteFileRegion(region);<br>        <span class="hljs-keyword">if</span> (localFlushedAmount &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 更新数据的发送速度</span><br>            in.progress(localFlushedAmount);<br>            <span class="hljs-keyword">if</span> (region.transferred() &gt;= region.count()) &#123;<br>                <span class="hljs-comment">//则从缓存中移除</span><br>                in.remove();<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//不支持发送其他类型数据</span><br>        <span class="hljs-comment">// Should not reach here.</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error();<br>    &#125;<br>    <span class="hljs-keyword">return</span> WRITE_STATUS_SNDBUF_FULL;<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.nio.AbstractNioByteChannel#incompleteWrite</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">incompleteWrite</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> setOpWrite)</span> </span>&#123;<br>    <span class="hljs-comment">// Did not write completely.</span><br>    <span class="hljs-keyword">if</span> (setOpWrite) &#123;<br>        <span class="hljs-comment">// 将OP_WRITE写操作事件添加到Channel的选择Key兴趣事件集中</span><br>        setOpWrite();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// It is possible that we have set the write OP, woken up by NIO because the socket is writable, and then</span><br>        <span class="hljs-comment">// use our write quantum. In this case we no longer want to set the write OP because the socket is still</span><br>        <span class="hljs-comment">// writable (as far as we know). We will find out next time we attempt to write if the socket is writable</span><br>        <span class="hljs-comment">// and set the write OP if necessary.</span><br>        <span class="hljs-comment">//清楚Channel选择Key兴趣事件集中的OP_WRITE写操作事件</span><br>        clearOpWrite();<br>		<span class="hljs-comment">// 将写操作任务添加到EventLoop线程上，以便后续继续发送</span><br>        <span class="hljs-comment">// Schedule flush again later so other tasks can be picked up in the meantime</span><br>        eventLoop().execute(flushTask);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>NioByteUnsafe的read()方法的实现思路大致分为以下3步：</p>
<ol>
<li><p>获取Channel的配置对象、内存分配器<code>RecvByteBufAllocator.Handler</code>。</p>
</li>
<li><p>进入for循环。循环体本身的作用：使用内存分配器获取数据容器<code>ByteBuf</code>，调用<code>doReadBytes()</code>方法将数据读取到容器中，如果本次循环没有读到数据或者数据链路已经关闭，则跳出循环。另外，当循环次数达到属性<code>METADATA</code>的<code>defaultMaxMessagePerRead</code>次数（默认为16次）时，也会跳出循环。由于TCP传输会产生粘包问题，因此每次读取都会触发<code>channelRead</code>事件，进而调用业务逻辑处理Handler。</p>
</li>
<li><p>跳出循环后，表示本次读取已经完成。调用<code>allocHandler</code>的<code>readComplete()</code>方法，并读取记录，用于下次分配合理内存。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//获取pipeline通道配置、channel管道</span><br>    <span class="hljs-keyword">final</span> ChannelConfig config = config();<br>    <span class="hljs-comment">//socketChannel已经关闭</span><br>    <span class="hljs-keyword">if</span> (shouldBreakReadReady(config)) &#123;<br>        clearReadPending();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">final</span> ChannelPipeline pipeline = pipeline();<br>    <span class="hljs-comment">// 获取内容分配器，默认为PooledByteBufAllocator</span><br>    <span class="hljs-keyword">final</span> ByteBufAllocator allocator = config.getAllocator();<br>    <span class="hljs-keyword">final</span> RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();<br>    <span class="hljs-comment">//清空上一次读取的字节数，每次读取时均重新计算</span><br>    <span class="hljs-comment">//字节Buf分配器，并计算字节buf分配器 Handler</span><br>    allocHandle.reset(config);<br><br>    ByteBuf byteBuf = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">boolean</span> close = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-comment">// 分配内存</span><br>            byteBuf = allocHandle.allocate(allocator);<br>            <span class="hljs-comment">// 读取通道接收缓冲区的数据</span><br>            allocHandle.lastBytesRead(doReadBytes(byteBuf));<br>            <span class="hljs-keyword">if</span> (allocHandle.lastBytesRead() &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// nothing was read. release the buffer.</span><br>                <span class="hljs-comment">// 若没有数据可以读，则释放内存</span><br>                byteBuf.release();<br>                byteBuf = <span class="hljs-keyword">null</span>;<br>                close = allocHandle.lastBytesRead() &lt; <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (close) &#123;<br>                    <span class="hljs-comment">//当读到-1时，表示Channel通道已经关闭，没有必要再继续读。</span><br>                    <span class="hljs-comment">// There is nothing left to read as we received an EOF.</span><br>                    readPending = <span class="hljs-keyword">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>			<span class="hljs-comment">// 更新读取消息计数器</span><br>            allocHandle.incMessagesRead(<span class="hljs-number">1</span>);<br>            readPending = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-comment">//通知通道处理器处理数据，触发Channel通道的fireChannelRead事件</span><br>            pipeline.fireChannelRead(byteBuf);<br>            byteBuf = <span class="hljs-keyword">null</span>;<br>        &#125; <span class="hljs-keyword">while</span> (allocHandle.continueReading());<br>		<span class="hljs-comment">// 读取操作完毕</span><br>        allocHandle.readComplete();<br>        pipeline.fireChannelReadComplete();<br>		<br>        <span class="hljs-keyword">if</span> (close) &#123;<br>            <span class="hljs-comment">// 如果Socket通道关闭，则关闭读操作</span><br>            closeOnRead(pipeline);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-comment">// 处理读异常</span><br>        handleReadException(pipeline, byteBuf, t, close, allocHandle);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// Check if there is a readPending which was not processed yet.</span><br>        <span class="hljs-comment">// This could be for two reasons:</span><br>        <span class="hljs-comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method</span><br>        <span class="hljs-comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// See https://github.com/netty/netty/issues/2254</span><br>        <span class="hljs-keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;<br>            <span class="hljs-comment">// 若读操作完毕，且没有配置自动读，则选择Key兴趣集中移除读操作事件。</span><br>            removeReadOp();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="AbstractNioMessageChannel-源码剖析"><a href="#AbstractNioMessageChannel-源码剖析" class="headerlink" title="AbstractNioMessageChannel 源码剖析"></a>AbstractNioMessageChannel 源码剖析</h1><p><strong>AbstractNioMessageChannel写入和读取的数据类型是Object，而不是字节流**</strong>。**<strong>在读数据时，AbstractNioMessageChannel数据不存在粘包问题</strong>，因此AbstractNioMessageChannnel在read()方法中先循环数据包，再触发channelRead事件。在写数据的时，AbstractNioMessageChannel数据逻辑简单。它把缓存outboundBuffer中的数据包依此写入Channel中。如果Channel中写满了，或循环写、默认写的次数为子类Channel属性METADATA中的<code>defaultMaxMessagesPerRead</code>次数，则在Channel的SelectionKey上设置OP_WRITE事件，随后推出，其后OP_WRITE事件处理逻辑和Byte字节流写逻辑一样。read()和doWrite()方法代码解读如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">assert</span> <span class="hljs-title">eventLoop</span><span class="hljs-params">()</span>.<span class="hljs-title">inEventLoop</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 获取Channel的配置对象</span><br>    <span class="hljs-keyword">final</span> ChannelConfig config = config();<br>    <span class="hljs-keyword">final</span> ChannelPipeline pipeline = pipeline();<br>    <span class="hljs-comment">// 获取计算内存分配Handler</span><br>    <span class="hljs-keyword">final</span> RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();<br>    <span class="hljs-comment">// 清空上次的记录</span><br>    allocHandle.reset(config);<br><br>    <span class="hljs-keyword">boolean</span> closed = <span class="hljs-keyword">false</span>;<br>    Throwable exception = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-comment">// 调用子类的doReadMessages()方法</span><br>                <span class="hljs-comment">// 读取数据包，并放入readBuf链表中</span><br>                <span class="hljs-comment">// 当成功读取时返回 1</span><br>                <span class="hljs-keyword">int</span> localRead = doReadMessages(readBuf);<br>                <span class="hljs-comment">// 已无数据，跳出循环</span><br>                <span class="hljs-keyword">if</span> (localRead == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 链路关闭，跳出循环</span><br>                <span class="hljs-keyword">if</span> (localRead &lt; <span class="hljs-number">0</span>) &#123;<br>                    closed = <span class="hljs-keyword">true</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>				<span class="hljs-comment">// 记录成功读取的次数</span><br>                allocHandle.incMessagesRead(localRead);<br>                <span class="hljs-comment">// 默认不能超过16次</span><br>            &#125; <span class="hljs-keyword">while</span> (continueReading(allocHandle));<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            exception = t;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> size = readBuf.size();<br>        <span class="hljs-comment">// 循环处理读取的数据包</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i ++) &#123;<br>            readPending = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-comment">// 触发ChannelRead事件</span><br>            pipeline.fireChannelRead(readBuf.get(i));<br>        &#125;<br>        readBuf.clear();<br>        <span class="hljs-comment">//记录当前读取记录，以便下次分配合理内存</span><br>        allocHandle.readComplete();<br>        <span class="hljs-comment">// 触发 readComplete 事件</span><br>        pipeline.fireChannelReadComplete();<br><br>        <span class="hljs-keyword">if</span> (exception != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 处理异常情况下关闭Channel</span><br>            closed = closeOnReadError(exception);<br>            pipeline.fireExceptionCaught(exception);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (closed) &#123;<br>            inputShutdown = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-comment">// 处理Channel正常关闭</span><br>            <span class="hljs-keyword">if</span> (isOpen()) &#123;<br>                close(voidPromise());<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// Check if there is a readPending which was not processed yet.</span><br>        <span class="hljs-comment">// This could be for two reasons:</span><br>        <span class="hljs-comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method</span><br>        <span class="hljs-comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// See https://github.com/netty/netty/issues/2254</span><br>        <span class="hljs-comment">//读操作完毕，且没有配置自动读</span><br>        <span class="hljs-keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;<br>            <span class="hljs-comment">// 移除读操作事件</span><br>            removeReadOp();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.nio.AbstractNioMessageChannel#doWrite</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doWrite</span><span class="hljs-params">(ChannelOutboundBuffer in)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">final</span> SelectionKey key = selectionKey();<br>    <span class="hljs-comment">// 获取Key的兴趣集</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> interestOps = key.interestOps();<br><br>    <span class="hljs-keyword">int</span> maxMessagesPerWrite = maxMessagesPerWrite();<br>    <span class="hljs-comment">// 当前校验最大写的次数是否大于0</span><br>    <span class="hljs-keyword">while</span> (maxMessagesPerWrite &gt; <span class="hljs-number">0</span>)<br>        Object msg = in.current();<br>        <span class="hljs-keyword">if</span> (msg == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//如果当前数据没有数据需要发送，直接跳出循环</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">boolean</span> done = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-comment">//获取配置中，循环写的最大次数</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = config().getWriteSpinCount() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>                <span class="hljs-comment">// 调用子方法进行循环写操作，成功返回true</span><br>                <span class="hljs-keyword">if</span> (doWriteMessage(msg, in)) &#123;<br>                    done = <span class="hljs-keyword">true</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>			<span class="hljs-comment">// 若发送成功，则将其从缓存链表中移除，继续发送循环获取下一个数据</span><br>            <span class="hljs-keyword">if</span> (done) &#123;<br>                maxMessagesPerWrite--;<br>                in.remove();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">// 判断如果遇到异常是否要继续写</span><br>            <span class="hljs-keyword">if</span> (continueOnWriteError()) &#123;<br>                maxMessagesPerWrite--;<br>                in.remove(e);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">throw</span> e;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (in.isEmpty()) &#123;<br>        <span class="hljs-comment">// Wrote all messages.</span><br>        <span class="hljs-comment">// 数据已全部发送发送完成，从兴趣集中移除 OP_WRITE 事件</span><br>        <span class="hljs-keyword">if</span> ((interestOps &amp; SelectionKey.OP_WRITE) != <span class="hljs-number">0</span>) &#123;<br>            key.interestOps(interestOps &amp; ~SelectionKey.OP_WRITE);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Did not write all messages.</span><br>        <span class="hljs-comment">// 如果数据还没写完，将OP_WRITE加入到兴趣集中</span><br>        <span class="hljs-keyword">if</span> ((interestOps &amp; SelectionKey.OP_WRITE) == <span class="hljs-number">0</span>) &#123;<br>            key.interestOps(interestOps | SelectionKey.OP_WRITE);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="NioSocketChannel-源码剖析"><a href="#NioSocketChannel-源码剖析" class="headerlink" title="NioSocketChannel 源码剖析"></a>NioSocketChannel 源码剖析</h1><p>前面分析Channel都是抽象类，NioSocketChannel是AbstractNioByteChannel的子类，也是<code>io.netty.channel.socket.SocketChannel</code>的实现类。<strong>Netty服务的每个连接都会生成一个NioSocketChannel对象</strong>。NioSocketChannel在AbstractNioByteChannel的基础上封装了NIO中的SocketChannel，实现了IO的读写连接操作，其核心功能如下。</p>
<ul>
<li><p>SocketChannel在NioSocketChannel构造方法中由<code>SelectorProvider.provider().openSocketChannel()</code>创建，提供javaChannel()方法以获取SocketChannel。</p>
</li>
<li><p>实现<code>doReadByte()</code>方法，从SocketChannel中读取数据。</p>
</li>
<li><p>重写<code>doWrite()</code>方法、实现doWriteBytes()方法，将数据写入Socket中。</p>
</li>
<li><p>实现<code>doConnect()</code>方法和客户端连接。</p>
</li>
</ul>
<p>下图为NioSocketChannel 的核心功能脑图，注明了这些功能会在哪些地方会被调用，从图中可以看出，大部分方法都是被其辅助对象Unsafe调用。</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20211029084754.png" srcset="/img/loading.gif"></p>
<p>I/O的读写的核心代码解读如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.channel.socket.nio.NioSocketChannel#doReadBytes</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doReadBytes</span><span class="hljs-params">(ByteBuf byteBuf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">// 获取计算内存分配器Handle</span><br>    <span class="hljs-keyword">final</span> RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();<br>    <span class="hljs-comment">// 设置尝试读取字节数为buf的可写字节数</span><br>    allocHandle.attemptedBytesRead(byteBuf.writableBytes());<br>   	<span class="hljs-comment">// 从Channel中读取字节数并写入buf中，返回读取的字节数</span><br>    <span class="hljs-keyword">return</span> byteBuf.writeBytes(javaChannel(), allocHandle.attemptedBytesRead());<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.socket.nio.NioSocketChannel#doWriteBytes</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doWriteBytes</span><span class="hljs-params">(ByteBuf buf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">// 获取buf的可读字节数</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> expectedWrittenBytes = buf.readableBytes();<br>    <span class="hljs-comment">// 把buf写入Socket缓存中，返回写入的字节数</span><br>    <span class="hljs-keyword">return</span> buf.readBytes(javaChannel(), expectedWrittenBytes);<br>&#125;<br><br><span class="hljs-comment">//io.netty.channel.socket.nio.NioSocketChannel#doWrite</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doWrite</span><span class="hljs-params">(ChannelOutboundBuffer in)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">//获取SocketChannel</span><br>    SocketChannel ch = javaChannel();<br>    <span class="hljs-comment">// 获取配置属性 writeSpinCount(循环写入的最大次数)</span><br>    <span class="hljs-keyword">int</span> writeSpinCount = config().getWriteSpinCount();<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">// 缓存中数据为空，无数据可写</span><br>        <span class="hljs-keyword">if</span> (in.isEmpty()) &#123;<br>            <span class="hljs-comment">// All written so clear OP_WRITE</span><br>            <span class="hljs-comment">// 清除写事件并直接返回</span><br>            clearOpWrite();<br>            <span class="hljs-comment">// Directly return here so incompleteWrite(...) is not called.</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>		<span class="hljs-comment">// 获取一次最大可写字节数</span><br>        <span class="hljs-comment">// Ensure the pending writes are made of ByteBufs only.</span><br>        <span class="hljs-keyword">int</span> maxBytesPerGatheringWrite = ((NioSocketChannelConfig) config).getMaxBytesPerGatheringWrite();<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 缓存由多个Entry组成，每次写时都可能写多个entry</span><br><span class="hljs-comment">         * 具体一次性该发送多少数据</span><br><span class="hljs-comment">         * 由ByteBuffer数组的最大长度和一次最大可写字节数决定</span><br><span class="hljs-comment">         */</span><br>        ByteBuffer[] nioBuffers = in.nioBuffers(<span class="hljs-number">1024</span>, maxBytesPerGatheringWrite);<br>        <span class="hljs-keyword">int</span> nioBufferCnt = in.nioBufferCount();<br><br>        <span class="hljs-comment">// Always use nioBuffers() to workaround data-corruption.</span><br>        <span class="hljs-comment">// See https://github.com/netty/netty/issues/2761</span><br>        <span class="hljs-keyword">switch</span> (nioBufferCnt) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                <span class="hljs-comment">// 非ByteBuffer 数据，交给父类实现</span><br>                <span class="hljs-comment">// We have something else beside ByteBuffers to write so fallback to normal writes.</span><br>                writeSpinCount -= doWrite0(in);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: &#123;<br>                <span class="hljs-comment">// Only one ByteBuf so use non-gathering write</span><br>                <span class="hljs-comment">// Zero length buffers are not added to nioBuffers by ChannelOutboundBuffer, so there is no need</span><br>                <span class="hljs-comment">// to check if the total size of all the buffers is non-zero.</span><br>                ByteBuffer buffer = nioBuffers[<span class="hljs-number">0</span>];<br>                <span class="hljs-comment">// buf 可读的字节数</span><br>                <span class="hljs-keyword">int</span> attemptedBytes = buffer.remaining();<br>                <span class="hljs-comment">// 将buf发送到Socket缓存中</span><br>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> localWrittenBytes = ch.write(buffer);<br>                <span class="hljs-comment">// 如果发送失败</span><br>                <span class="hljs-keyword">if</span> (localWrittenBytes &lt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 将写事件添加到事件兴趣集中</span><br>                    incompleteWrite(<span class="hljs-keyword">true</span>);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>               <span class="hljs-comment">/**</span><br><span class="hljs-comment">                * 根据成功写入字节数和尝试写入字节数调整下次最大可写字节数</span><br><span class="hljs-comment">                * 当两者相等时，若写入字节数 * 2 大于当前最大可写入字节数</span><br><span class="hljs-comment">                * 则下次最大可写入字节数等于尝试写入字节数 * 2</span><br><span class="hljs-comment">                * 并且当写入最大字节数 &gt; 4096时，下次最大可写入字节数等于尝试写入字节数/2</span><br><span class="hljs-comment">                */</span><br>                adjustMaxBytesPerGatheringWrite(attemptedBytes, localWrittenBytes, maxBytesPerGatheringWrite);<br>                <span class="hljs-comment">// 从缓存中移除写入字节数</span><br>                in.removeBytes(localWrittenBytes);<br>                <span class="hljs-comment">// 循环写入次数 -1</span><br>                --writeSpinCount;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">default</span>: &#123;<br>                <span class="hljs-comment">// Zero length buffers are not added to nioBuffers by ChannelOutboundBuffer, so there is no need</span><br>                <span class="hljs-comment">// to check if the total size of all the buffers is non-zero.</span><br>                <span class="hljs-comment">// We limit the max amount to int above so cast is safe</span><br>                <span class="hljs-keyword">long</span> attemptedBytes = in.nioBufferSize();<br>                <span class="hljs-comment">// 这里和上面的不同点是这里使用多通道写，而上面使用的单个buffer写</span><br>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> localWrittenBytes = ch.write(nioBuffers, <span class="hljs-number">0</span>, nioBufferCnt);<br>                <span class="hljs-keyword">if</span> (localWrittenBytes &lt;= <span class="hljs-number">0</span>) &#123;<br>                    incompleteWrite(<span class="hljs-keyword">true</span>);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <span class="hljs-comment">// Casting to int is safe because we limit the total amount of data in the nioBuffers to int above.</span><br>                adjustMaxBytesPerGatheringWrite((<span class="hljs-keyword">int</span>) attemptedBytes, (<span class="hljs-keyword">int</span>) localWrittenBytes,<br>                                                maxBytesPerGatheringWrite);<br>                in.removeBytes(localWrittenBytes);<br>                --writeSpinCount;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (writeSpinCount &gt; <span class="hljs-number">0</span>);<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 未全发送完；</span><br><span class="hljs-comment">     * 若 writeSpinCount &lt; 0 说明Socket缓冲区已经满了，未发送成功。</span><br><span class="hljs-comment">     * 若 writeSpinCount = 0 说明Netty数据量太大了16次循环未写完</span><br><span class="hljs-comment">     */</span><br>    incompleteWrite(writeSpinCount &lt; <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="NioServerSocketChannel-源码剖析"><a href="#NioServerSocketChannel-源码剖析" class="headerlink" title="NioServerSocketChannel 源码剖析"></a>NioServerSocketChannel 源码剖析</h1><p><strong>NioServerSocektChannel是AbstractNioMessageChannel的子类，由于NioServerSocektChannel由服务端使用</strong>，<strong>并且只负责监听Socket的接入，不关心IO读写</strong>，所以与NioServerChannel相比要简单很多，它封装了NIO中的ServerSocketChannel，并通过newSocket()方法打开ServerSocketChannel。它的多路复用器注册与NioSocketChannel的多路复用注册一样，由父类AbstractNioChannel实现。下面重点关注它是如何监听新加入的连接的（需要由doReadMessages()方法来完成）。具体代码解析如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.channel.socket.nio.NioServerSocketChannel#doReadMessages</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doReadMessages</span><span class="hljs-params">(List&lt;Object&gt; buf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">// 调用serverSocketChannel.accept()监听新加入的连接</span><br>    SocketChannel ch = SocketUtils.accept(javaChannel());<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (ch != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//每一个新连接都会构建一个NioSocketChannel</span><br>            buf.add(<span class="hljs-keyword">new</span> NioSocketChannel(<span class="hljs-keyword">this</span>, ch));<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        logger.warn(<span class="hljs-string">&quot;Failed to create a new channel from an accepted socket.&quot;</span>, t);<br>		<span class="hljs-comment">// 如果连接出现异常则关闭</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            ch.close();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t2) &#123;<br>            logger.warn(<span class="hljs-string">&quot;Failed to close a socket.&quot;</span>, t2);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="鸟瞰Channel"><a href="#鸟瞰Channel" class="headerlink" title="鸟瞰Channel"></a>鸟瞰Channel</h1><p>我们梳理部分Channel的一些重要的实现类和一些重要的方法，我们很容易发现，Channel的主要方法都是围绕网络IO的读写，客户端发起连接、关闭连接等功能。AbstractChannel通过模版方法实现做一些基础的实现，子类通过继承的方式完成具体的实现，提高代码的复用率。</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20211103081228.png" srcset="/img/loading.gif"></p>
<p>这几个实现类的特点：</p>
<ul>
<li><p>AbstractChannel ：基础父类，<strong>没有直接参与网络直接有关操作，但是提供了部分模版方法</strong>。并且提供了Unsafe内部类。</p>
</li>
<li><p>AbstractNioChannel：每种IO类型都会在AbstractChannel上在进行一层封装，针对每种IO类型的特点进行封装，例如AbstractNioChannel中提供了三个重要属性：<code>SelectableChannel</code><strong>NIO真正用到的Channel</strong>、<code>readInterestOp</code><strong>监听感兴趣的事件</strong>，<code>selectionKey</code><strong>注册到Selector后获取的Key。</strong></p>
</li>
<li><p>AbstractNioByteChannel：它是AbstractNioChannel的子类，但是并不是最终的实现类。<strong>它具备NIO注册、连接等功能</strong>。IO读写会交给子类来处理，<strong>在NioByteChannel中发送和读写的对象类型是ByteBuf和FileRegion。</strong></p>
</li>
<li><p>NioSocketChannel：AbstractNioByteChannel的子类，也是我们最常使用到的Channel实现类。<strong>Netty服务的每次连接都会生成一个NioSocketChannel对象</strong>。并在AbstractNioByteChannel的基础上实现了IO的读写连接功能。</p>
</li>
<li><p>AbstractNioMessageChannel：同样也是AbstractNioChannel的子类，和AbstractNioByteChannel类似，但是<strong>它读写的对象是Object对象。因此它不会存在粘包的问题。</strong></p>
</li>
<li><p>NioServerSocketChannel：AbstractNioMessageChannel的子类，是一个仅仅只处理新连接的Channel，在<code>doReadMessages</code>的实现类中，也是<strong>关于新连接的处理</strong>。创建连接、读写方法都会进行异常处理。</p>
</li>
</ul>
<p>其中有一个特殊的点抽象类中具体的连接与读写都是使用Unsafe实现的。同样的子类中也会对Unsafe接口继承或是实现。<strong>Unsafe表示不对外提供功能，并非不安全。</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这一小节我们简单梳理了Netty的Channel，我们不难发现，Channel完成了对NIO的Channel的实现与拓展。我们从AbstractChannel开始进行梳理，AbstractChannel 实现了Channel接口，提供了一些类的基础模版实现和一些Channel中的基础字段，例如标识Channel唯一的ChannelId、实现具体操作连接，数据读写的Unsafe、Channel容器Pipeline等。随后向下梳理了AbstractNioChannel的源码分析，AbstractNioChannel也是一个抽象类。这个抽象类是NioChannel的抽象类，这个类继承拓展了AbstractChannel。这个类正对NioChannel进行了拓展和补充。随后我们依据读取数据类型的不同，分析梳理了AbstractNioByteChannel 和AbstractNioMessageChannel。前者使用byteBuf读写的是二进制数据，因此存在粘包问题，后者读写Object数据，不存在粘包问题。这一层我们分析了他们读写方法，他们的读写方法在大体结构上是相似的，但是在读取具体数据的实现细节上又有不同。在往下一层就是我们最常使用到的NioSocketChannel 和NioServerSocketChannel，其中NioSocketChannel中对读写连接操作都有具体的实现，NioServerSocketChannel中则是抛出UnsupportedOperationException(); NioServerSocketChannel则会用来监听Socket接入的Accept连接操作。 因此我们在日常Netty开发中，会使用NioServerSocketChannel通常配置处理连接的bossGroup使用，而NioSocketChannel则会在配置处理读写的workerGroup时使用。</p>
<h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/35246428/">Netty源码剖析与应用</a></li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/NIO%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">NIO与网络编程</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Java%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84%E6%A2%B3%E7%90%86/">Java知识结构梳理</a>
                    
                      <a class="hover-with-bg" href="/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">学习总结</a>
                    
                      <a class="hover-with-bg" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
                    
                      <a class="hover-with-bg" href="/tags/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">源码剖析</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/10/16/netty-source-code-nioEventLoop/">
                        <span class="hidden-mobile">核心组件源码剖析 — NioEventLoop</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
