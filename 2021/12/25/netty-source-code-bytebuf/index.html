

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/blogFavicon.png">
  <link rel="icon" href="/img/blogFavicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  
    <meta name="description" content="">
  
  <meta name="author" content="Daiwei">
  <meta name="keywords" content="">
  
  <title>Netty核心组件源码剖析 — ByteBuf - Daiwei‘s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.8","typing":{"enable":true,"typeSpeed":100,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Daiwei's blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://gitee.com/realDaiwei/img/raw/master/khamkeo-vilaysing-WtwSsqwYlA0-unsplash.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Netty核心组件源码剖析 — ByteBuf">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-12-25 16:51" pubdate>
        2021年12月25日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      11.1k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      49
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Netty核心组件源码剖析 — ByteBuf</h1>
            
            <div class="markdown-body">
              <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一小节中，我们介绍channel，channel 的主要功能有处理网络IO读写，处理连接。这里需要注意的是channel仅仅是负责读写操作，在NIO中真正负责传输数据的是Buffer（缓冲区）。在NIO中，缓冲区的作用也是用来临时存储数据，可以理解为I/O数据的中转站。缓冲区直接对接channel，为其提供写入和读取的数据。通过操作buffer批量进行数据传输提高效率。在NIO中主要有八种缓冲区(ByteBuffer、CharBuffer、ShortBuffer，IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer)。在网络中传输中，字节是基本单位，NIO使用的ByteBuffer作为Byte的字节容器，但是NIO中实现过于复杂，因此Netty又写了一套ByteBuf来代替NIO的ByteBuffer，这一小节我们将深入ByteBuf源码，探究ByteBuf底层原理与实现细节。</p>
<h1 id="ByteBuffer-快速回顾"><a href="#ByteBuffer-快速回顾" class="headerlink" title="ByteBuffer 快速回顾"></a>ByteBuffer 快速回顾</h1><p>所有的缓冲区都有4个属性：<code>capacity</code>、<code>limit</code>、<code>position</code>、<code>mark</code>，并遵循：mark &lt;= position &lt;= limit &lt;= capacity。</p>
<table>
<thead>
<tr>
<th>capactiy</th>
<th>容量，即可以容纳的最大数据量；在缓冲区创建时被设定并且不能改变。</th>
</tr>
</thead>
<tbody><tr>
<td>limit</td>
<td>表示缓冲区的当前终点，不能对缓冲区超过极限的位置进行读写操作，且极限是可以修改的。</td>
</tr>
<tr>
<td>position</td>
<td>位置，下一个要被读或写的元素的索引，每次读写缓冲区数据都会改变该值，为下次读写做准备</td>
</tr>
<tr>
<td>mark</td>
<td>标记，调用mark()来设置mark=position，再次调用reset()可以让position恢复到标记的位置</td>
</tr>
</tbody></table>
<h2 id="实例化方法"><a href="#实例化方法" class="headerlink" title="实例化方法"></a>实例化方法</h2><p>ByteBuffer 是一个抽象类不能被实例化，ByteBuffer也提供了基础的构造方法，这些构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//java.nio.ByteBuffer#ByteBuffer(int, int, int, int, byte[], int)</span><br>ByteBuffer(<span class="hljs-keyword">int</span> mark, <span class="hljs-keyword">int</span> pos, <span class="hljs-keyword">int</span> lim, <span class="hljs-keyword">int</span> cap,   <span class="hljs-comment">// package-private</span><br>       		<span class="hljs-keyword">byte</span>[] hb, <span class="hljs-keyword">int</span> offset)<br>&#123;<br>    <span class="hljs-keyword">super</span>(mark, pos, lim, cap);<br>    <span class="hljs-keyword">this</span>.hb = hb;<br>    <span class="hljs-keyword">this</span>.offset = offset;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个构造方法中需要传入6个入参，除了我们上面介绍的4个参数，还有hb（heap buffer）和offset（偏移量）。同时ByteBuffer类提供了4个静态工厂方法来获得ByteBuffer的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Allocates a new direct byte buffer.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt; The new buffer&#x27;s position will be zero, its limit will be its</span><br><span class="hljs-comment"> * capacity, its mark will be undefined, and each of its elements will be</span><br><span class="hljs-comment"> * initialized to zero.  Whether or not it has a</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> #hasArray backing array&#125; is unspecified.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  capacity</span><br><span class="hljs-comment"> *         The new buffer&#x27;s capacity, in bytes</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span>  The new byte buffer</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span>  IllegalArgumentException</span><br><span class="hljs-comment"> *          If the &lt;tt&gt;capacity&lt;/tt&gt; is a negative integer</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//java.nio.ByteBuffer#allocateDirect</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title">allocateDirect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectByteBuffer(capacity);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Allocates a new byte buffer.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt; The new buffer&#x27;s position will be zero, its limit will be its</span><br><span class="hljs-comment"> * capacity, its mark will be undefined, and each of its elements will be</span><br><span class="hljs-comment"> * initialized to zero.  It will have a &#123;<span class="hljs-doctag">@link</span> #array backing array&#125;,</span><br><span class="hljs-comment"> * and its &#123;<span class="hljs-doctag">@link</span> #arrayOffset array offset&#125; will be zero.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  capacity</span><br><span class="hljs-comment"> *         The new buffer&#x27;s capacity, in bytes</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span>  The new byte buffer</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span>  IllegalArgumentException</span><br><span class="hljs-comment"> *          If the &lt;tt&gt;capacity&lt;/tt&gt; is a negative integer</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//java.nio.ByteBuffer#allocate</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (capacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HeapByteBuffer(capacity, capacity);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Wraps a byte array into a buffer.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt; The new buffer will be backed by the given byte array;</span><br><span class="hljs-comment"> * that is, modifications to the buffer will cause the array to be modified</span><br><span class="hljs-comment"> * and vice versa.  The new buffer&#x27;s capacity will be</span><br><span class="hljs-comment"> * &lt;tt&gt;array.length&lt;/tt&gt;, its position will be &lt;tt&gt;offset&lt;/tt&gt;, its limit</span><br><span class="hljs-comment"> * will be &lt;tt&gt;offset + length&lt;/tt&gt;, and its mark will be undefined.  Its</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> #array backing array&#125; will be the given array, and</span><br><span class="hljs-comment"> * its &#123;<span class="hljs-doctag">@link</span> #arrayOffset array offset&#125; will be zero.  &lt;/p&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  array</span><br><span class="hljs-comment"> *         The array that will back the new buffer</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  offset</span><br><span class="hljs-comment"> *         The offset of the subarray to be used; must be non-negative and</span><br><span class="hljs-comment"> *         no larger than &lt;tt&gt;array.length&lt;/tt&gt;.  The new buffer&#x27;s position</span><br><span class="hljs-comment"> *         will be set to this value.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  length</span><br><span class="hljs-comment"> *         The length of the subarray to be used;</span><br><span class="hljs-comment"> *         must be non-negative and no larger than</span><br><span class="hljs-comment"> *         &lt;tt&gt;array.length - offset&lt;/tt&gt;.</span><br><span class="hljs-comment"> *         The new buffer&#x27;s limit will be set to &lt;tt&gt;offset + length&lt;/tt&gt;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span>  The new byte buffer</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span>  IndexOutOfBoundsException</span><br><span class="hljs-comment"> *          If the preconditions on the &lt;tt&gt;offset&lt;/tt&gt; and &lt;tt&gt;length&lt;/tt&gt;</span><br><span class="hljs-comment"> *          parameters do not hold</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//java.nio.ByteBuffer#wrap(byte[], int, int)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title">wrap</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] array,</span></span><br><span class="hljs-function"><span class="hljs-params">                              <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> length)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HeapByteBuffer(array, offset, length);<br>    &#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException x) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Wraps a byte array into a buffer.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt; The new buffer will be backed by the given byte array;</span><br><span class="hljs-comment"> * that is, modifications to the buffer will cause the array to be modified</span><br><span class="hljs-comment"> * and vice versa.  The new buffer&#x27;s capacity and limit will be</span><br><span class="hljs-comment"> * &lt;tt&gt;array.length&lt;/tt&gt;, its position will be zero, and its mark will be</span><br><span class="hljs-comment"> * undefined.  Its &#123;<span class="hljs-doctag">@link</span> #array backing array&#125; will be the</span><br><span class="hljs-comment"> * given array, and its &#123;<span class="hljs-doctag">@link</span> #arrayOffset array offset&gt;&#125; will</span><br><span class="hljs-comment"> * be zero.  &lt;/p&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  array</span><br><span class="hljs-comment"> *         The array that will back this buffer</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span>  The new byte buffer</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//java.nio.ByteBuffer#wrap(byte[])</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title">wrap</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] array)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> wrap(array, <span class="hljs-number">0</span>, array.length);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这4个构造方法描述如下：</p>
<ul>
<li><p><code>allocateDirect(int capacity)</code>：不使用JVM堆栈而是通过操作系统来创建内存块用作缓冲区，它与当前操作系统能更好的耦合，因此能进一步提高I/O操作速度。但是分配直接缓冲区的系统开销很大，因此<strong>只有在缓冲区较大并长期存在或者需要经常重用</strong>时，才使用这种直接缓冲区。</p>
</li>
<li><p><code>allocate(int capacity)</code>：从堆空间中分配一个容量大小为capacity的byte数组作为缓冲区的byte数据存储器。</p>
</li>
<li><p><code>wrap(byte[] array)</code>：<strong>缓冲区的数据会存放在byte数组中</strong>，bytes数组或buff缓冲区任何一方中数据的改动都会影响另一方。其实ByteBuffer底层本来就是一个bytes数组负责来保存buffer缓冲区中的数据，通过allocate方法系统会帮你构造一个byte数组。</p>
</li>
<li><p><code>wrap(byte[] array, int offset, int length)</code>：在上一个方法的基础上可以指定偏移量和长度，这个offset也就是包装后byteBuffer的postion，length是limit-postion的大小，我们可以计算得出limit的位置为length+postion(offset)。</p>
</li>
</ul>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>byteBuffer提供了一些常用的方法，通过这些方法我们可以操作设置我们的buffer，也可以通过这些方法完成buffer的读写。这些方法的简单介绍如下：</p>
<ul>
<li><p><code>limit(), limit(10)</code>：读取或者设置limit的值，并且4个基础属性都有这个方法。这两个方法一个get，一个set。</p>
</li>
<li><p><code>reset()</code>：把position设置成mark的值，相当于之前做过一个标记，现在要退回之前标记的地方。</p>
</li>
<li><p><code>clear()</code>：<strong>position=0；limit=capacity；mark=-1</strong>；将指针位置初始化，但是并不影响底层数据。</p>
</li>
<li><p><code>flip()</code>：<strong>limit=position；position=0；mark=-1</strong>；翻转，也就是让flip之后的position到limit这块区域变成之前的0到position这块，flip操作就是将一个准备写数据状态的缓冲区，变成一个准备读状态的缓冲区。</p>
</li>
<li><p><code>rewind()</code>：把postion设置为0，mark设置为-1，不改变limit的值。（从头开始。。）</p>
</li>
<li><p><code>remaining()</code>：return limit - position; 返回limit和position之间的相对位置差。</p>
</li>
<li><p><code>hasRemaining()</code>：return position &lt; limit 返回是否还有未读内容。</p>
</li>
<li><p><code>compact()</code>：把从position到limit中的内容移到0到limit-position的区域，position和limit的取值也分别变成limit-position、capacity。如果先把position设置到limit，再compact，那么相当于clear。（把还没读的部分压缩到最前面。真“压缩”）</p>
</li>
<li><p><code>get()</code>：相对读，从position位置读取一个byte，并将position+1，为下次读写作准备。</p>
</li>
<li><p><code>get(int index)</code>：绝对读，读取byteBuffer底层的bytes中下标为index的byte，不改变position。</p>
</li>
<li><p><code>get(byte[] dst, int offset, int length)</code>：从position位置开始相对读，读length个byte，并写入dst下标从offset到offset+length的区域。</p>
</li>
<li><p><code>put(byte b)</code>：相对写，向position的位置写入一个byte，并将position + 1，为下次读写作准备。</p>
</li>
<li><p><code>put(int index，byte b)</code>：绝对写，向byteBuffer底层的bytes中下标为index的位置插入byte b，不改变postion。</p>
</li>
</ul>
<h1 id="ByteBuf-源码剖析"><a href="#ByteBuf-源码剖析" class="headerlink" title="ByteBuf 源码剖析"></a>ByteBuf 源码剖析</h1><p>在网络传输中，字节是基础单位，NIO使用ByteBuffer作为Byte容器，前面我们也对其进行了简单的回顾，但是NIO的实现过于复杂，因此Netty写了一套Channel代替NIO的Channel，也写了一套ByteBuf代替NIO的ByteBuffer。和ByteBuffer一样。Netty实现的ByteBuf的子类也非常多，这里我们只针对ByteBuf进行详细的剖析。下图展示了ByteBuf的主要特性，图中列出的类都是在本小节中要重点梳理的类。其中前三个特性针对ByteBuffer的缺点进行了改进。</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20211115082712.png" srcset="/img/loading.gif"></p>
<p>NIO ByteBuffer 只有一个位置指针position，在<strong>切换读写状态时，需要手动调用flip()方法或rewind()方法，已改变position的值</strong>，而且ByteBuffer的长度是固定的，一旦分配完成就不能再进行扩容和收缩，当需要放入对象大于ByteBuffer的容量时会发生异常。每次编码都要进行可写空间校验。Netty的AbstractByteBuf将<strong>读写指针分离</strong>，同时在写操作进行<strong>自动扩容</strong>。对其使用而言，无须关心底层实现，且操作简便、代码无冗余。NIO ByteBuffer的duplicate()方法可以复制对象，复制后的对象与原对象共享缓冲区的内存，但其position指针独立维护。Netty的ByteBuf也采用了这功能，并设计了内存池。内存池是由一定大小和数量的内存块ByteBuf组成的，这些内块的大小默认为16MB。当从Channel中读取数据时候，无需每次都分配新的ByteBuf，只需要从大的内存块中共享一份内存，并初始化其大小及独立维护读/写指针即可。Netty采用对象引用计数，需要手动回收。每复制一份ByteBuf或派生出新的ByteBuf，其引用都需要增加。</p>
<h2 id="AbstractByteBuf-源码剖析"><a href="#AbstractByteBuf-源码剖析" class="headerlink" title="AbstractByteBuf 源码剖析"></a>AbstractByteBuf 源码剖析</h2><p>AbstractByteBuf是ByteBuf的子类，它定义了一些公共属性，如读索引、写索引、mark、最大容量等。AbstractByteBuf实现了一套读写操作的模版方法，其缓冲区真正的数据读写由其子类完成。AbstractByteBuf的核心功能如下，接下来我们对其的核心功能进行源码剖析。</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20211115082620.png" srcset="/img/loading.gif"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 读索引    </span><br><span class="hljs-keyword">int</span> readerIndex;<br><span class="hljs-comment">// 写索引</span><br><span class="hljs-keyword">int</span> writerIndex;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 标记读索引</span><br><span class="hljs-comment"> * 在解码时，由于消息不完整，无法处理。</span><br><span class="hljs-comment"> * 需要将 readerIndex 复位</span><br><span class="hljs-comment"> * 此时需要给索引先做个标记</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> markedReaderIndex;<br><span class="hljs-comment">// 标记读索引</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> markedWriterIndex;<br><span class="hljs-comment">// 最大容量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxCapacity;<br></code></pre></td></tr></table></figure>

<p>AbstractByteBuf的写操作 writeBytes()方法涉及扩容，在扩容时，除了合法的校验，还需要计算新的容量值，若内存大小为2的整数次幂，则AbstractByteBuf的子类比较好分配内存，因此扩容后的大小必须是2的整数次幂。具体代码解读如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.buffer.AbstractByteBuf#writeBytes</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ByteBuf <span class="hljs-title">writeBytes</span><span class="hljs-params">(ByteBuf src, <span class="hljs-keyword">int</span> srcIndex, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>    <span class="hljs-comment">//确保可以写，当容量不足时自动扩容。</span><br>    ensureWritable(length);<br>    <span class="hljs-comment">//缓冲区真正的写操作由子类实现</span><br>    setBytes(writerIndex, src, srcIndex, length);<br>    <span class="hljs-comment">//调整写索引</span><br>    writerIndex += length;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">//io.netty.buffer.AbstractByteBuf#ensureWritable0</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureWritable0</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minWritableBytes)</span> </span>&#123;<br>    <span class="hljs-comment">//获取ByteBuf对象的引用计数</span><br>    <span class="hljs-comment">// 确认当前写入后的大小要小于总容量，并确保可以访问。</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> writerIndex = writerIndex();<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> targetCapacity = writerIndex + minWritableBytes;<br>    <span class="hljs-comment">// using non-short-circuit &amp; to reduce branching - this is a hot path and targetCapacity should rarely overflow</span><br>    <span class="hljs-keyword">if</span> (targetCapacity &gt;= <span class="hljs-number">0</span> &amp; targetCapacity &lt;= capacity()) &#123;<br>        ensureAccessible();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果需要校验边界，并且当前写入后的capacity小于0 或者写入后的capacity大于最大容量，抛出异常</span><br>    <span class="hljs-keyword">if</span> (checkBounds &amp;&amp; (targetCapacity &lt; <span class="hljs-number">0</span> || targetCapacity &gt; maxCapacity)) &#123;<br>        ensureAccessible();<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(String.format(<br>            <span class="hljs-string">&quot;writerIndex(%d) + minWritableBytes(%d) exceeds maxCapacity(%d): %s&quot;</span>,<br>            writerIndex, minWritableBytes, maxCapacity, <span class="hljs-keyword">this</span>));<br>    &#125;<br><br>    <span class="hljs-comment">// 自动扩容</span><br>    <span class="hljs-comment">// maxFastWritableBytes: 返回不用复制和重新分配的最快、最大可写字节数。</span><br>    <span class="hljs-comment">// 如果当前最大可写字节数 &gt;= 要写入的字节数，直接返回当前写索引位置 + 最大可写字节数，</span><br>    <span class="hljs-comment">// 否则就要调用calculateNewCapacity计算出扩容后的大小。</span><br>    <span class="hljs-comment">// Normalize the target capacity to the power of 2.</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> fastWritable = maxFastWritableBytes();<br>    <span class="hljs-keyword">int</span> newCapacity = fastWritable &gt;= minWritableBytes ? writerIndex + fastWritable<br>        : alloc().calculateNewCapacity(targetCapacity, maxCapacity);<br><br>    <span class="hljs-comment">// 调整容量为最新的容量大小。</span><br>    <span class="hljs-comment">// Adjust to the new capacity.</span><br>    capacity(newCapacity);<br>&#125;<br><br><span class="hljs-comment">//io.netty.buffer.AbstractByteBufAllocator#calculateNewCapacity</span><br><span class="hljs-comment">// 当threshold小于阈值（4MB）时，新的容量（capacity）都是以64为基数向左移位计算出来的</span><br><span class="hljs-comment">// 然后通过位计算，得到下一个大于原容量且最接近的2次幂容量大小。</span><br><span class="hljs-comment">// 如果新的容量capacity大于阈值4MB的时候，不会以2倍的方式扩容，而是以 + threshold（4MB）的方式扩容。</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculateNewCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minNewCapacity, <span class="hljs-keyword">int</span> maxCapacity)</span> </span>&#123;<br>    checkPositiveOrZero(minNewCapacity, <span class="hljs-string">&quot;minNewCapacity&quot;</span>);<br>    <span class="hljs-keyword">if</span> (minNewCapacity &gt; maxCapacity) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(String.format(<br>            <span class="hljs-string">&quot;minNewCapacity: %d (expected: not greater than maxCapacity(%d)&quot;</span>,<br>            minNewCapacity, maxCapacity));<br>    &#125;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> threshold = CALCULATE_THRESHOLD; <span class="hljs-comment">// 4 MiB page</span><br>	<span class="hljs-comment">// 如果新的容量等于阈值，直接返回。</span><br>    <span class="hljs-keyword">if</span> (minNewCapacity == threshold) &#123;<br>        <span class="hljs-keyword">return</span> threshold;<br>    &#125;<br><br>    <span class="hljs-comment">//如果新的容量值大于4MB</span><br>    <span class="hljs-comment">// If over threshold, do not double but just increase by threshold.</span><br>    <span class="hljs-keyword">if</span> (minNewCapacity &gt; threshold) &#123;<br>        <span class="hljs-comment">// 先获取离minNewCapacity最近的4MB的整数倍数，且小于minNewCapacity</span><br>        <span class="hljs-keyword">int</span> newCapacity = minNewCapacity / threshold * threshold;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 次数新的容量值不会倍增，因为4MB以上内存比较大，</span><br><span class="hljs-comment">         * 如果继续倍增，可能会带来额外的内存浪费</span><br><span class="hljs-comment">         * 只能在此基础上+4MB，并判断是否大于maxCapacity</span><br><span class="hljs-comment">         * 如果小于maxCapacity 返回 maxCapacity 否则返回newCapacity+threshold </span><br><span class="hljs-comment">         **/</span><br>        <span class="hljs-keyword">if</span> (newCapacity &gt; maxCapacity - threshold) &#123;<br>            newCapacity = maxCapacity;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            newCapacity += threshold;<br>        &#125;<br>        <span class="hljs-keyword">return</span> newCapacity;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果容量小于4MB，以64为基础倍增。</span><br>    <span class="hljs-comment">// 64 &lt;= newCapacity is a power of 2 &lt;= threshold</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> newCapacity = MathUtil.findNextPositivePowerOfTwo(Math.max(minNewCapacity, <span class="hljs-number">64</span>));<br>    <span class="hljs-keyword">return</span> Math.min(newCapacity, maxCapacity);<br>&#125;<br><br><span class="hljs-comment">//io.netty.util.internal.MathUtil#findNextPositivePowerOfTwo</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findNextPositivePowerOfTwo</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">assert</span> value &gt; Integer.MIN_VALUE &amp;&amp; value &lt; <span class="hljs-number">0x40000000</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">32</span> - Integer.numberOfLeadingZeros(value - <span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>读操作 readBytes() 方法源码分析如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.buffer.AbstractByteBuf#readBytes</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ByteBuf <span class="hljs-title">readBytes</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] dst, <span class="hljs-keyword">int</span> dstIndex, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>    <span class="hljs-comment">// 检测当前ByteBuf是否可读，检测其可读长度是否小于length</span><br>    checkReadableBytes(length);<br>    <span class="hljs-comment">//和写一样，具体读由子类实现。</span><br>    getBytes(readerIndex, dst, dstIndex, length);<br>    <span class="hljs-comment">//修改读索引位置。</span><br>    readerIndex += length;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>readBytes()方法调用getBytes()方法从当前的读索引开始，将length个字节复制到目标，byte数组中。由于不同的子类对应不同的复制操作，因此AbstractByteBuf中的getBytes()是一个抽象方法，留给子类实现。下面是一个具体子类PooledHeapByteBuf对getBytes()的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.buffer.PooledHeapByteBuf#getBytes</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ByteBuf <span class="hljs-title">getBytes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">byte</span>[] dst, <span class="hljs-keyword">int</span> dstIndex, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>    <span class="hljs-comment">// 检查目标数组是否够用，再检查ByteBuf的可读内容是否足够。</span><br>    checkDstIndex(index, length, dstIndex, dst.length);<br>    <span class="hljs-comment">//将ByteBuf中的内容复制到dst数组中。</span><br>    System.arraycopy(memory, idx(index), dst, dstIndex, length);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>另一子类PooledDirectByteBuf对getBytes()方法的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.buffer.PooledDirectByteBuf#getBytes(int, byte[], int, int)</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ByteBuf <span class="hljs-title">getBytes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">byte</span>[] dst, <span class="hljs-keyword">int</span> dstIndex, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>    <span class="hljs-comment">// 检查</span><br>    checkDstIndex(index, length, dstIndex, dst.length);<br>    <span class="hljs-comment">// 将NIO的ByteBuffer中的内容获取到dst数组中。</span><br>    _internalNioBuffer(index, length, <span class="hljs-keyword">true</span>).get(dst, dstIndex, length);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">final</span> ByteBuffer <span class="hljs-title">_internalNioBuffer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> length, <span class="hljs-keyword">boolean</span> duplicate)</span> </span>&#123;<br>    <span class="hljs-comment">// 根据readIndex获取偏移量offset</span><br>    index = idx(index);<br>    <span class="hljs-comment">// 从memory中复制一份内存对象，两者共享缓存区，但其位置指针单独维护。</span><br>    ByteBuffer buffer = duplicate ? newInternalNioBuffer(memory) : internalNioBuffer();<br>    <span class="hljs-comment">// 设置新的 byteBuffer位置及其最大长度。</span><br>    buffer.limit(index + length).position(index);<br>    <span class="hljs-keyword">return</span> buffer;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过上面的梳理，对AbstractByteBuf的核心部分已经有了一个大致的了解，下面通过对AbstractReferenceCountedByteBuf类进行深入剖析来了解Netty是如何运用引用计数法管理ByteBuf生命周期的。</p>
<h2 id="AbstractReferenceCountedByteBuf-源码剖析"><a href="#AbstractReferenceCountedByteBuf-源码剖析" class="headerlink" title="AbstractReferenceCountedByteBuf 源码剖析"></a>AbstractReferenceCountedByteBuf 源码剖析</h2><p>Netty在进行I/O读写时候使用了堆外内存，实现了零拷贝，堆外直接内存DirectBuffer的分配与回收效率都远远低于JVM堆内存上对象的创建与回收速率。<strong>Netty使用引用计数法来管理Buffer的引用与释放。Netty采用了内存池设计，先分配一块大内存，然后不断地重复利用这块内存。</strong>例如，当从SocketChannel 中读取数据时，先在大内存块中切一小部分来使用，由于与大内存共享缓存区，所以需要增加大内存的引用值，当用完小内存后，再将其放回发内存块中，同时减少其引用值。</p>
<blockquote>
<p> 运用到引用计数法的ByteBuf大部分都需要继承AbstractReferenceCountedByteBuf类，该类有一个引用值属性—<strong>refCnt</strong>，其大部分功能与此属性有关系。</p>
</blockquote>
<p>由于ByteBuf操作可能存在多线程并发使用的情况，其refCnt属性的操作必须是线程安全的，因此采用了volatile 来修饰，以保证多线程可见。在Netty中，ByteBuf会被大量地创建，为了节省内存开销，通过AtomicIntegerFieldUpdater来更新refCnt的值，而没有采用AtomicInteger类型。因此AtomicInteger类型的创建的对象比int类型多占用16B的对象头，当有几十万或几百万ByteBuf对象时候，节约的内存可能有几十MB或几百MB。一下是AbstractReferenceCountedByteBuf的功能图。</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20211225165810.png" srcset="/img/loading.gif"></p>
<p>AbstractReferenceCountedByteBuf的大部分功能都是由updater属性完成，其核心属性解读如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调用Unsafe类的objectFieldOffset()方法 </span><br><span class="hljs-comment"> * 以获取某个字段相对于Jav对象的气势地址的偏移量</span><br><span class="hljs-comment"> * Netty为了提高性能，构建了Unsafe对象</span><br><span class="hljs-comment"> * 采用此偏移量访问ByteBuf的refCnt字段。</span><br><span class="hljs-comment"> * 并未直接使用AtomicIntegerFieldUpdater </span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> REFCNT_FIELD_OFFSET =<br>    ReferenceCountUpdater.getUnsafeOffset(AbstractReferenceCountedByteBuf.class, <span class="hljs-string">&quot;refCnt&quot;</span>);<br><span class="hljs-comment">// AtomicIntegerFieldUpdater 属性委托给ReferenceCountUpdater 来管理</span><br><span class="hljs-comment">// 主要用于更新和获取 refCnt 的值。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> AtomicIntegerFieldUpdater&lt;AbstractReferenceCountedByteBuf&gt; AIF_UPDATER =<br>    AtomicIntegerFieldUpdater.newUpdater(AbstractReferenceCountedByteBuf.class, <span class="hljs-string">&quot;refCnt&quot;</span>);<br><br><span class="hljs-comment">// 引用计数值的实际管理者</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ReferenceCountUpdater&lt;AbstractReferenceCountedByteBuf&gt; updater =<br>    <span class="hljs-keyword">new</span> ReferenceCountUpdater&lt;AbstractReferenceCountedByteBuf&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> AtomicIntegerFieldUpdater&lt;AbstractReferenceCountedByteBuf&gt; <span class="hljs-title">updater</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> AIF_UPDATER;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">long</span> <span class="hljs-title">unsafeOffset</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> REFCNT_FIELD_OFFSET;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 引用计数值，初始值为2，与调用refCnt()获取的实际值1有差别。</span><br><span class="hljs-comment">// Value might not equal &quot;real&quot; reference count, all access should be via the updater</span><br><span class="hljs-meta">@SuppressWarnings(&#123;&quot;unused&quot;, &quot;FieldMayBeFinal&quot;&#125;)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> refCnt = updater.initialValue();<br></code></pre></td></tr></table></figure>

<p>在旧的版本中，refCnt引用计数的值每次加1或减1，默认为1，大于0表示可用，等于0表示已释放。在Netty v4.1.38.Final版本中，refCnt的初始值为2，每次操作也不同。在下面源码剖析中会得到答案。</p>
<h2 id="ReferenceCountUpdater-源码剖析"><a href="#ReferenceCountUpdater-源码剖析" class="headerlink" title="ReferenceCountUpdater 源码剖析"></a>ReferenceCountUpdater 源码剖析</h2><p><code>ReferenceCountUpdater</code>是<code>AbstractReferenceCountedByteBuf</code>的辅助类，用于完成对引用计数制进行操作。虽然它的大部分功能都是和引用计数有关，但与Netty之前的版本相比有很大的改动，主要是Netty v4.1.38.Final 版本采用了乐观锁方式来修改refCnt，并在修改后进行校验。例如，retain()方法在增加了refCnt后，如果出现了溢出，则回滚并抛出异常。在旧版本中，采用的似乎原子性操作，不断地提前判断，并尝试调用compareAndSet。与之相比，新版本的吞吐量有所提高，但若还是采用refCnt的原有方式，从1开始每次加1或减1，则会引发一些问题，需要重新设计。这也是新版本改动较大的原因。一下是ReferenceCountUpdater的功能图。</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20211225165924.png" srcset="/img/loading.gif"></p>
<p>由duplicate()、slice()衍生的ByteBuf与原生对象共享底层的Buffer，原对象的引用可能需要增加，引用增加的方法为retain0()。</p>
<h3 id="retain-剖析解读"><a href="#retain-剖析解读" class="headerlink" title="retain() 剖析解读"></a>retain() 剖析解读</h3><p>retain0()方法为retain()方法的具体实现，其代码解析如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.util.internal.ReferenceCountUpdater#retain0</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> T <span class="hljs-title">retain0</span><span class="hljs-params">(T instance, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> increment, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> rawIncrement)</span> </span>&#123;<br>    <span class="hljs-comment">//乐观锁，先获取原值，再增加。</span><br>    <span class="hljs-keyword">int</span> oldRef = updater().getAndAdd(instance, rawIncrement);<br>    <span class="hljs-comment">// 如果原值不为偶数，则表示ByteBuf已经被释放，无法继续引用。</span><br>    <span class="hljs-keyword">if</span> (oldRef != <span class="hljs-number">2</span> &amp;&amp; oldRef != <span class="hljs-number">4</span> &amp;&amp; (oldRef &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalReferenceCountException(<span class="hljs-number">0</span>, increment);<br>    &#125;<br>    <span class="hljs-comment">// 如果增加后出现了溢出，回滚并抛出异常。</span><br>    <span class="hljs-comment">// don&#x27;t pass 0!</span><br>    <span class="hljs-keyword">if</span> ((oldRef &lt;= <span class="hljs-number">0</span> &amp;&amp; oldRef + rawIncrement &gt;= <span class="hljs-number">0</span>)<br>        || (oldRef &gt;= <span class="hljs-number">0</span> &amp;&amp; oldRef + rawIncrement &lt; oldRef)) &#123;<br>        <span class="hljs-comment">// overflow case</span><br>        updater().getAndAdd(instance, -rawIncrement);<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalReferenceCountException(realRefCnt(oldRef), increment);<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>旧版本代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> ByteBuf <span class="hljs-title">retain0</span><span class="hljs-params">(<span class="hljs-keyword">int</span> increment)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">int</span> refCnt = <span class="hljs-keyword">this</span>.refCnt;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> nextCnt = refCnt + increment;<br>        <span class="hljs-comment">// 先判断是否溢出</span><br>        <span class="hljs-keyword">if</span>（nextCnt &lt;= increment) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalReferenceCountException(refCnt, increment);<br>        &#125;<br>        <span class="hljs-comment">// 如果引用在for循环体中未被修改过，则用新的引用值替换。</span><br>        <span class="hljs-keyword">if</span> (refCntUpdater.compareAndSet(<span class="hljs-keyword">this</span>, refCnt, nextCnt) &#123;<br>        	<span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在进行引用计数的修改时，并不会先判断是否会出现溢出，而是先执行，执行完成之后再进行判断，如果溢出则进行回滚。在高并发情况下，与之前版本对比，Netty v4.1.38.Final的吞吐量会有明显的提升，但refCnt不是每次都进行加1或减1的操作，主要原因是修改前无法判断（因为场景没有加锁，所以修改前判断没有意义，可能正在修改时候已经不是判断时的值，还是会造成溢出。如果已经出现了溢出，再循环判断修改依旧没有意义了）。</p>
<h3 id="release-剖析解读"><a href="#release-剖析解读" class="headerlink" title="release() 剖析解读"></a>release() 剖析解读</h3><p>若有多条线程同时操作，则线程1调用ByteBuf的release()方法，线程2调用retain()方法，线程3调用release()方法，会导致ByteBuf出现多次销毁操作。若采用<strong>奇数表示销毁状态，偶数表示正常状态</strong>，则该问题得以解决，最终释放后会变成奇数。ByteBuf使用完后需要执行release()方法，release()方法的返回值为true或false，false表示还有引用存在，true表示无引用，此时会调用ByteBuf的deallocate()方法进行销毁。相关代码解读如下：</p>
<blockquote>
<p>奇偶数表示不同状态的巧妙使用。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.util.internal.ReferenceCountUpdater#release(T)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(T instance)</span> </span>&#123;<br>    <span class="hljs-comment">// 获取到refCnt的值，因为我们refCnt的初始值是2，并且每次更新以2为步长，始终为偶数</span><br>    <span class="hljs-comment">// 如果此时获取到的rawCnt引用数为2，说明只有一个引用，</span><br>    <span class="hljs-comment">// 因此这里只要尝试最终更新（即将引用数更新为奇数即可）或是循环CAS减去一个引用也行，</span><br>    <span class="hljs-comment">// 如果还剩余多个引用即rawCnt不为2，调用nonFinalRelease0减去一个引用数即可。</span><br>    <span class="hljs-keyword">int</span> rawCnt = nonVolatileRawCnt(instance);<br>    <span class="hljs-keyword">return</span> rawCnt == <span class="hljs-number">2</span> ? tryFinalRelease0(instance, <span class="hljs-number">2</span>) || retryRelease0(instance, <span class="hljs-number">1</span>)<br>        : nonFinalRelease0(instance, <span class="hljs-number">1</span>, rawCnt, toLiveRealRefCnt(rawCnt, <span class="hljs-number">1</span>));<br>&#125;<br><br><span class="hljs-comment">// 这段代码逻辑和上面的基本一致，只是这段代码可以传入减少多少个引用。</span><br><span class="hljs-comment">//io.netty.util.internal.ReferenceCountUpdater#release(T, int)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(T instance, <span class="hljs-keyword">int</span> decrement)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> rawCnt = nonVolatileRawCnt(instance);<br>    <span class="hljs-keyword">int</span> realCnt = toLiveRealRefCnt(rawCnt, checkPositive(decrement, <span class="hljs-string">&quot;decrement&quot;</span>));<br>    <span class="hljs-keyword">return</span> decrement == realCnt ? tryFinalRelease0(instance, rawCnt) || retryRelease0(instance, decrement)<br>        : nonFinalRelease0(instance, decrement, rawCnt, realCnt);<br>&#125;<br><br><span class="hljs-comment">//尝试最终释放，得益于refCnt偶数有效，计数无效，realCnt = rawCnt &gt;&gt;&gt; 1的机制，</span><br><span class="hljs-comment">// 设置refCnt为任意奇数，则表示当前被引用对象无效。</span><br><span class="hljs-comment">//io.netty.util.internal.ReferenceCountUpdater#tryFinalRelease0</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryFinalRelease0</span><span class="hljs-params">(T instance, <span class="hljs-keyword">int</span> expectRawCnt)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> updater().compareAndSet(instance, expectRawCnt, <span class="hljs-number">1</span>); <span class="hljs-comment">// any odd number will work</span><br>&#125;<br><br><span class="hljs-comment">// 非最终释放，如果减少的引用数，少于所有的引用数直接CAS进行操作，如果大于真正的引用数或CAS更新失败，</span><br><span class="hljs-comment">// 则直接调用retryRelease0进行循环更新</span><br><span class="hljs-comment">//io.netty.util.internal.ReferenceCountUpdater#nonFinalRelease0</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">nonFinalRelease0</span><span class="hljs-params">(T instance, <span class="hljs-keyword">int</span> decrement, <span class="hljs-keyword">int</span> rawCnt, <span class="hljs-keyword">int</span> realCnt)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (decrement &lt; realCnt<br>        <span class="hljs-comment">// all changes to the raw count are 2x the &quot;real&quot; change - overflow is OK</span><br>        &amp;&amp; updater().compareAndSet(instance, rawCnt, rawCnt - (decrement &lt;&lt; <span class="hljs-number">1</span>))) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> retryRelease0(instance, decrement);<br>&#125;<br><br><span class="hljs-comment">// 尝试进行释放，在这个方法里面是一个死循环，如果减去的引用数decrement是一个非常规的值，方法会直接异常退出，</span><br><span class="hljs-comment">// 如果decremnt的值和所有引用数相等，则会直接尝试最终释放（tryFinalRelease0），</span><br><span class="hljs-comment">// 方法会一直更新直至更新成功。</span><br><span class="hljs-comment">// 最后调用Thread.yield();让出线程执行权，增加在高并发竞争情况下的吞吐量。</span><br><span class="hljs-comment">//io.netty.util.internal.ReferenceCountUpdater#retryRelease0</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">retryRelease0</span><span class="hljs-params">(T instance, <span class="hljs-keyword">int</span> decrement)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">int</span> rawCnt = updater().get(instance), realCnt = toLiveRealRefCnt(rawCnt, decrement);<br>        <span class="hljs-keyword">if</span> (decrement == realCnt) &#123;<br>            <span class="hljs-keyword">if</span> (tryFinalRelease0(instance, rawCnt)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (decrement &lt; realCnt) &#123;<br>            <span class="hljs-comment">// all changes to the raw count are 2x the &quot;real&quot; change</span><br>            <span class="hljs-keyword">if</span> (updater().compareAndSet(instance, rawCnt, rawCnt - (decrement &lt;&lt; <span class="hljs-number">1</span>))) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalReferenceCountException(realCnt, -decrement);<br>        &#125;<br>        Thread.yield(); <span class="hljs-comment">// this benefits throughput under high contention</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//io.netty.util.internal.ReferenceCountUpdater#nonVolatileRawCnt</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nonVolatileRawCnt</span><span class="hljs-params">(T instance)</span> </span>&#123;<br>    <span class="hljs-comment">// 获取偏移量</span><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Once we compile against later versions of Java we can replace the Unsafe usage here by varhandles.</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> offset = unsafeOffset();<br>    <span class="hljs-comment">// 若偏移量正常，使用Unsafe的普通get</span><br>    <span class="hljs-comment">// 若偏移量获取异常，则选择Unsafe的volatile get</span><br>    <span class="hljs-keyword">return</span> offset != -<span class="hljs-number">1</span> ? PlatformDependent.getInt(instance, offset) : updater().get(instance);<br>&#125;<br><br><span class="hljs-comment">// 计算真正的应用数量，即 rawCnt &gt;&gt;&gt; 1，这里有一个判断</span><br><span class="hljs-comment">// rawCnt == 2 || rawCnt == 4 || (rawCnt &amp; 1) == 0</span><br><span class="hljs-comment">// 即判断当前rawCnt是否为偶数，为什么不直接使用rawCnt &amp; 1？</span><br><span class="hljs-comment">// 因为 == 相较于 &amp; 有明显的性能优势。通过 == 操作进行判断路径的压缩。</span><br><span class="hljs-comment">//io.netty.util.internal.ReferenceCountUpdater#toLiveRealRefCnt</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">toLiveRealRefCnt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rawCnt, <span class="hljs-keyword">int</span> decrement)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (rawCnt == <span class="hljs-number">2</span> || rawCnt == <span class="hljs-number">4</span> || (rawCnt &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> rawCnt &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// odd rawCnt =&gt; already deallocated</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalReferenceCountException(<span class="hljs-number">0</span>, -decrement);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>ReferenceCountUpdater</code> 主要运用JDK的CAS来修改计数器，为了提高性能，还引入了Unsafe类，可直接操作内存。至此，ByteBuf的引用计数告一段落，下面会对Netty的另一种零拷贝方式组合缓冲区视图 CompositeByteBuf进行详细剖析。</p>
<h2 id="CompositeByteBuf-源码剖析"><a href="#CompositeByteBuf-源码剖析" class="headerlink" title="CompositeByteBuf 源码剖析"></a>CompositeByteBuf 源码剖析</h2><p>CompositeByteByteBuf的主要功能是组合多个ByteBuf，对外提供统一的<code>redaIndex</code>和<code>writeIndex</code>。由于它只是<strong>将多个ByteBuf的实例组装到一起形成了一个统一的视图</strong>，并没有对ByteBuf中的数据进行拷贝，因此也属于Netty零拷贝的一种，主要应用与编解码。例如，将消息头和消息体两个ByteBuf组合到一块进行编码，可能会觉得Netty有写缓存区，其本身就会存在多个ByteBuf，此时只需把两个ByteBuf分别写入缓冲区 ChannelOutboundBuffer即可，没必要使用组合ByteBuf。但是在将ByteBuf写入缓存区之前，需要将整个消息进行编码解码，如消息长度，此时需要把两个ByteBuf合并成一个，无须额外处理接可以知道其整体长度，因此使用CompositeByteBuf是非常合适的。在解码时，由于Socket通信传输数据会产生粘和半包问题，因此需要一个读半包字节的容器，这个容器采用CompositeByteBuf比较合适。将每次从Socket中读取到的数据直接放入此容器中，少了一次数据拷贝。Netty的解码类ByteToMessageDecoder默认的读半包字节容器Cumulator未采用CompositeByteBuf，此时可在其子类中调用 setCumulator 进行修改。但需要注意的是，CompositeByteBuf 需要依赖使用场景。<strong>因为CompositeByteBuf使用了复杂的逻辑算法，所以其效率有可能比使用内存拷贝的低。</strong></p>
<p>CompositeByteBuf内部定义了一个Component类型的集合，实际上，Component是ByteBuf的包装实现类，它聚合了ByteBuf对象并维护了ByteBuf对象在集合中的位置偏移信息等。下图展示了CompositeByteBuf功能。</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20211225170221.png" srcset="/img/loading.gif"></p>
<p>在开始分析CompositeByteBuf之前，我们先来了解下它的基本结构和属性。</p>
<h3 id="基本结构与属性"><a href="#基本结构与属性" class="headerlink" title="基本结构与属性"></a>基本结构与属性</h3><p>CompisteByteBuf中有两个重要的属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 数组中存在component的个数。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> componentCount; <br><span class="hljs-comment">// component 数组</span><br><span class="hljs-keyword">private</span> Component[] components; <br></code></pre></td></tr></table></figure>

<p><code>CompositeByteBuf</code>的大致结构如下图，里面有一个<strong>Component数组</strong>，Component里面放着缓冲区，还有各种索引。外部操作好像是只操作了CompositeByteBuf，其实<strong>具体操作Component中的缓冲区。</strong></p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20211205225919.png" srcset="/img/loading.gif"></p>
<p>Component是CompositeByteBuf的核心组建，CompositeByteBuf也叫做组合ByteBuf，<strong>通过Component数组将多个ByteBuf合并成一个逻辑上一个BytBuf</strong>，避免了各个ByteBuf之间的相互拷贝，提高了整体的效率。想要深入理解CompositeByteBuf，Component是一个绕不开的对象，Component有以下一些属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> ByteBuf srcBuf; <span class="hljs-comment">// 原始的buf，传进来是什么就是什么</span><br><span class="hljs-keyword">final</span> ByteBuf buf; <span class="hljs-comment">// 去掉包装的后的buf，传进来的可能是包装之后的buf</span><br><br><span class="hljs-keyword">int</span> srcAdjustment; <span class="hljs-comment">// 相对于srcBuf，CompoisteByteBuf的起始索引，读索引的偏移。</span><br><span class="hljs-keyword">int</span> adjustment; <span class="hljs-comment">// 相对于buf，CompositeByteBuf的起始索引，读索引的偏移。</span><br><br><span class="hljs-keyword">int</span> offset; <span class="hljs-comment">// 相对于CompositeByteBuf的起始索引。</span><br><span class="hljs-keyword">int</span> endOffset; <span class="hljs-comment">//相对于CompositeByteBuf的结束缩影</span><br><br><span class="hljs-keyword">private</span> ByteBuf slice; <span class="hljs-comment">// 缓存切片</span><br><br><span class="hljs-comment">//构造方法</span><br><span class="hljs-comment">//io.netty.buffer.CompositeByteBuf.Component#Component</span><br>Component(ByteBuf srcBuf, <span class="hljs-keyword">int</span> srcOffset, ByteBuf buf, <span class="hljs-keyword">int</span> bufOffset,<br>          <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> len, ByteBuf slice) &#123;<br>    <span class="hljs-keyword">this</span>.srcBuf = srcBuf;<br>    <span class="hljs-keyword">this</span>.srcAdjustment = srcOffset - offset;<br>    <span class="hljs-keyword">this</span>.buf = buf;<br>    <span class="hljs-keyword">this</span>.adjustment = bufOffset - offset;<br>    <span class="hljs-keyword">this</span>.offset = offset;<br>    <span class="hljs-keyword">this</span>.endOffset = offset + len;<br>    <span class="hljs-keyword">this</span>.slice = slice;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="addComponent-剖析解读"><a href="#addComponent-剖析解读" class="headerlink" title="addComponent() 剖析解读"></a>addComponent() 剖析解读</h3><p>下面是关于<code>addComponent()</code>方法及相关方法的代码解读：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.buffer.CompositeByteBuf#addComponent(boolean, int, io.netty.buffer.ByteBuf)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> CompositeByteBuf <span class="hljs-title">addComponent</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> increaseWriterIndex, <span class="hljs-keyword">int</span> cIndex, ByteBuf buffer)</span> </span>&#123;<br>    checkNotNull(buffer, <span class="hljs-string">&quot;buffer&quot;</span>);<br>    <span class="hljs-comment">// 把buffer加入Component数组中，并对数组中的元素进行相应的挪动</span><br>    addComponent0(increaseWriterIndex, cIndex, buffer);<br> 	<span class="hljs-comment">// 是否需要合成一个ByteBuf</span><br>    consolidateIfNeeded();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这里会调用一个<code>addComponent0</code>的方法，在这个方法中会先将传入的ByteBuf解掉包装，然后根据其读索引，可读长度和偏移量等信息封装成一个Component，然后添加到components数组中，在这个过程中还会涉及到对原有components数组的扩容移动等操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.buffer.CompositeByteBuf#addComponent0</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">addComponent0</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> increaseWriterIndex, <span class="hljs-keyword">int</span> cIndex, ByteBuf buffer)</span> </span>&#123;<br>    <span class="hljs-keyword">assert</span> buffer != <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">boolean</span> wasAdded = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 校验component索引是否越界</span><br>        checkComponentIndex(cIndex);<br><br>        <span class="hljs-comment">//创建一个新的Component，这里没有必要校验，直接加一个到Component的list中</span><br>        <span class="hljs-comment">// No need to consolidate - just add a component to the list.</span><br>        Component c = newComponent(ensureAccessible(buffer), <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">int</span> readableBytes = c.length();<br><br>        <span class="hljs-comment">// 校验溢出</span><br>        <span class="hljs-comment">// Check if we would overflow.</span><br>        <span class="hljs-comment">// See https://github.com/netty/netty/issues/10194</span><br>        checkForOverflow(capacity(), readableBytes);<br>		<br>        <span class="hljs-comment">//将创建的component加入到component数组中位于cIndex的位置上。</span><br>        addComp(cIndex, c);<br>        <span class="hljs-comment">// 添加成功</span><br>        wasAdded = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span> (readableBytes &gt; <span class="hljs-number">0</span> &amp;&amp; cIndex &lt; componentCount - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 插入位置在component数组中间，调整更新指针位置。</span><br>            updateComponentOffsets(cIndex); <span class="hljs-comment">// 调整Component的偏移量</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cIndex &gt; <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-comment">// 插入索引不是第一个索引，且不是插入到中间。插入在最后。根据上一个</span><br>           <span class="hljs-comment">// endOffset进行一些索引调整</span><br>            c.reposition(components[cIndex - <span class="hljs-number">1</span>].endOffset);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (increaseWriterIndex) &#123;<br>            <span class="hljs-comment">// 增加写索引</span><br>            writerIndex += readableBytes;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cIndex;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (!wasAdded) &#123;<br>            <span class="hljs-comment">// 执行到这里说明插入异常，释放buffer</span><br>            buffer.release();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>newComponent()</code>先获取源缓冲区<code>buf</code>的读索引和可读长度，然后将<code>buf</code>的包装去掉，获取去掉<code>unwrapped</code>的读索引<code>unwrappedIndex</code>，最后创建Component。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.buffer.CompositeByteBuf#newComponent</span><br><span class="hljs-meta">@SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> Component <span class="hljs-title">newComponent</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ByteBuf buf, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> offset)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> srcIndex = buf.readerIndex();<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> len = buf.readableBytes();<br><br>    <span class="hljs-comment">// unpeel any intermediate outer layers (UnreleasableByteBuf, LeakAwareByteBufs, SwappedByteBuf)</span><br>    ByteBuf unwrapped = buf;<br>    <span class="hljs-keyword">int</span> unwrappedIndex = srcIndex;<br>    <span class="hljs-keyword">while</span> (unwrapped <span class="hljs-keyword">instanceof</span> WrappedByteBuf || unwrapped <span class="hljs-keyword">instanceof</span> SwappedByteBuf) &#123;<br>        unwrapped = unwrapped.unwrap();<span class="hljs-comment">// 剥离外层，获取最原始的缓冲区</span><br>    &#125;<br><br>    <span class="hljs-comment">// unwrap if already sliced</span><br>    <span class="hljs-keyword">if</span> (unwrapped <span class="hljs-keyword">instanceof</span> AbstractUnpooledSlicedByteBuf) &#123;<br>        unwrappedIndex += ((AbstractUnpooledSlicedByteBuf) unwrapped).idx(<span class="hljs-number">0</span>);<br>        unwrapped = unwrapped.unwrap();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (unwrapped <span class="hljs-keyword">instanceof</span> PooledSlicedByteBuf) &#123;<br>        unwrappedIndex += ((PooledSlicedByteBuf) unwrapped).adjustment;<br>        unwrapped = unwrapped.unwrap();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (unwrapped <span class="hljs-keyword">instanceof</span> DuplicatedByteBuf || unwrapped <span class="hljs-keyword">instanceof</span> PooledDuplicatedByteBuf) &#123;<br>        unwrapped = unwrapped.unwrap();<br>    &#125;<br><br>    <span class="hljs-comment">// We don&#x27;t need to slice later to expose the internal component if the readable range</span><br>    <span class="hljs-comment">// is already the entire buffer</span><br>    <span class="hljs-comment">// 如果可读范围就是容量的话，就可以返回切片，合并后的缓冲去就会有切片</span><br>    <span class="hljs-keyword">final</span> ByteBuf slice = buf.capacity() == len ? buf : <span class="hljs-keyword">null</span>;<br>	<span class="hljs-comment">// 大端</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Component(buf.order(ByteOrder.BIG_ENDIAN), srcIndex,<br>                         unwrapped.order(ByteOrder.BIG_ENDIAN), unwrappedIndex, offset, len, slice);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>addComp()</code>这里就要将组建插入到数组相应的位置，默认当然是最后一个位置，也就是<code>componentCount</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.buffer.CompositeByteBuf#addComp</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addComp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, Component c)</span> </span>&#123;<br>    shiftComps(i, <span class="hljs-number">1</span>); <span class="hljs-comment">// 移出索引处的位置，超出数组大小就要扩容。</span><br>    components[i] = c; <span class="hljs-comment">// 放入数组。</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>shiftComps()</code> 插入新的component，可能是中间位置，那就需要腾出这个位置，也可能是最后，也可能要扩容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.buffer.CompositeByteBuf#shiftComps</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shiftComps</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> count)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size = componentCount, newSize = size + count;<br>    <span class="hljs-keyword">assert</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt;= size &amp;&amp; count &gt; <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (newSize &gt; components.length) &#123;<br>        <span class="hljs-comment">// 需要扩容，扩到现有components个数的1.5倍，或者新数组size大小。</span><br>        <span class="hljs-comment">// grow the array</span><br>        <span class="hljs-keyword">int</span> newArrSize = Math.max(size + (size &gt;&gt; <span class="hljs-number">1</span>), newSize);<br>        Component[] newArr; <span class="hljs-comment">// 创建新数组</span><br>        <span class="hljs-keyword">if</span> (i == size) &#123;<br>            <span class="hljs-comment">// 如果插入到最后，扩容到newArrSize, 然后把原来的拷贝过去，浅拷贝</span><br>            newArr = Arrays.copyOf(components, newArrSize, Component[].class);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 插入到中间，扩容且需要腾出索引位置。</span><br>            newArr = <span class="hljs-keyword">new</span> Component[newArrSize];<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// i索引之前的拷贝到newArr，从0索引到i，拷贝i个。</span><br>                System.arraycopy(components, <span class="hljs-number">0</span>, newArr, <span class="hljs-number">0</span>, i);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i &lt; size) &#123;<br>                <span class="hljs-comment">// i索引之后的拷贝到newArr, 从i + cout索引到最后，拷贝size-i个</span><br>                System.arraycopy(components, i, newArr, i + count, size - i);<br>            &#125;<br>        &#125;<br>        components = newArr; <span class="hljs-comment">// 新数组</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &lt; size) &#123;<br>        <span class="hljs-comment">//不需要扩容，只需要把i索引之后的往后count位。</span><br>        System.arraycopy(components, i, components, i + count, size - i);<br>    &#125;<br>    componentCount = newSize; <span class="hljs-comment">// 更新components 个数。</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>扩容的大体逻辑如下：</p>
<ul>
<li>如果需要扩容，扩容大小是原来大小的1.5倍，如果插入是最后，那就直接扩容拷贝到新数组里，如果不是插入到中间的话，需要把前后的元素分别拷贝到新数组的位置上，留出要插入的索引的位置，最后插入。</li>
<li>如果不进行扩容，默认插入位置就是最后，否则的话需要把位置所在元素以及后面的往后挪，把位置腾出来，插入数据。</li>
</ul>
<p><strong>要注意这里的数组拷贝全是浅拷贝</strong><code>Arrays.copyOf</code>和<code>System.arraycopy</code>，<strong>只是拷贝引用。</strong></p>
<p>以下几个图是插入的逻辑分析：</p>
<ul>
<li><strong>插入到最后，无需扩容：</strong></li>
</ul>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20211213235317.png" srcset="/img/loading.gif"></p>
<ul>
<li><strong>扩容，插入到最后。</strong></li>
</ul>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20211215000408.png" srcset="/img/loading.gif"></p>
<ul>
<li><strong>插入到中间需要移动元素，再插入并且不进行扩容。</strong></li>
</ul>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20211214235738.png" srcset="/img/loading.gif"></p>
<ul>
<li><strong>插入到中间，并进行扩容。</strong></li>
</ul>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20211216002439.png" srcset="/img/loading.gif"></p>
<p><code>updateComponentOffsets()</code>如果是有可读数据，且插入在中间位置就需要更新位置以及后面的component的索引，因为被插队了，偏移就变了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.buffer.CompositeByteBuf#updateComponentOffsets</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateComponentOffsets</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cIndex)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> size = componentCount;<br>    <span class="hljs-keyword">if</span> (size &lt;= cIndex) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>	<span class="hljs-comment">// 获取前一个组建的endOffset</span><br>    <span class="hljs-keyword">int</span> nextIndex = cIndex &gt; <span class="hljs-number">0</span> ? components[cIndex - <span class="hljs-number">1</span>].endOffset : <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (; cIndex &lt; size; cIndex++) &#123; <span class="hljs-comment">// 更新cIndex及之后的所有偏移。</span><br>        Component c = components[cIndex];<br>        c.reposition(nextIndex); <span class="hljs-comment">// 根据前一个更新endOffset来更新偏移。</span><br>        nextIndex = c.endOffset;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://gitee.com/realDaiwei/img/raw/master/20211216235107.png" srcset="/img/loading.gif"></p>
<p><code>consolidateIfNeeded()</code>这个方法就是<strong>合并操作</strong>，当components数组中的个数超过限制的最大个数时（默认16个），就会开始进行合并操作。实际的合并操作由<code>consolidate0</code>来完成。操作逻辑也比价简单。首先计算component的可读字节数，然后创建一个新buffer，然后循环遍历要合并的component并将他们转移到新的buffer中。最后把他们在原数组中移除，将新的buffer封装成一个新的component并重新加入到components数组中，同时更新索引偏移量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * This should only be called as last operation from a method as this may adjust the underlying</span><br><span class="hljs-comment"> * array of components and so affect the index etc.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//io.netty.buffer.CompositeByteBuf#consolidateIfNeeded</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consolidateIfNeeded</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Consolidate if the number of components will exceed the allowed maximum by the current</span><br>    <span class="hljs-comment">// operation.</span><br>    <span class="hljs-keyword">int</span> size = componentCount;<br>    <span class="hljs-keyword">if</span> (size &gt; maxNumComponents) &#123;<br>        consolidate0(<span class="hljs-number">0</span>, size); 从头开始合并成一个<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 这一段逻辑很简单，申请一个数组中所有bytebuf总和大小的空间，并把每一个byteBuf</span><br><span class="hljs-comment">// 拷贝里面整合成一个bytebuf.</span><br><span class="hljs-comment">//io.netty.buffer.CompositeByteBuf#consolidate0</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consolidate0</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cIndex, <span class="hljs-keyword">int</span> numComponents)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (numComponents &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//计算需要合并的components结束的索引</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> endCIndex = cIndex + numComponents;<br>    <span class="hljs-comment">//计算需要合并的开始位置的偏移量</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> startOffset = cIndex != <span class="hljs-number">0</span> ? components[cIndex].offset : <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//计算需要合并的components的总容量大小</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> capacity = components[endCIndex - <span class="hljs-number">1</span>].endOffset - startOffset;<br>	<span class="hljs-comment">// 申请对应容量的ByteBuf</span><br>    <span class="hljs-keyword">final</span> ByteBuf consolidated = allocBuffer(capacity);<br><br>    <span class="hljs-comment">// 循环写入components中的byteBuf到新的空间中。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = cIndex; i &lt; endCIndex; i ++) &#123;<br>        components[i].transferTo(consolidated);<br>    &#125;<br>    lastAccessed = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// 移除components数组中已经合并的component。</span><br>    removeCompRange(cIndex + <span class="hljs-number">1</span>, endCIndex);<br>    <span class="hljs-comment">//为合并后的byteBuf创建component并插入到对应的位置上，最后调整bytebuf的偏移量。</span><br>    components[cIndex] = newComponent(consolidated, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (cIndex != <span class="hljs-number">0</span> || numComponents != componentCount) &#123;<br>        updateComponentOffsets(cIndex);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//移除的逻辑也很简单，将范围后的元素拷贝到移除范围区间内，并将后面的无效元素设置为null即可。</span><br><span class="hljs-comment">//io.netty.buffer.CompositeByteBuf#removeCompRange</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeCompRange</span><span class="hljs-params">(<span class="hljs-keyword">int</span> from, <span class="hljs-keyword">int</span> to)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (from &gt;= to) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size = componentCount;<br>    <span class="hljs-keyword">assert</span> from &gt;= <span class="hljs-number">0</span> &amp;&amp; to &lt;= size;<br>    <span class="hljs-keyword">if</span> (to &lt; size) &#123;<br>        System.arraycopy(components, to, components, from, size - to);<br>    &#125;<br>    <span class="hljs-keyword">int</span> newSize = size - to + from;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = newSize; i &lt; size; i++) &#123;<br>        components[i] = <span class="hljs-keyword">null</span>;<br>    &#125;<br>    componentCount = newSize;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="removeComponent-剖析解读"><a href="#removeComponent-剖析解读" class="headerlink" title="removeComponent() 剖析解读"></a>removeComponent() 剖析解读</h3><p>上面我们分析了将component加入数组的逻辑addComponent()的逻辑，当然有add操作就会有remove操作，而移除操作相较于add，removeComponent()操作则简单不少，其实前面的合并操作也设计了一些移除操作。在移除过程中我们不必考虑数组的扩容问题，<strong>只需要删除需要移除的元素，并整理数组更新索引即可</strong>。以下是移除操作代码剖析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.buffer.CompositeByteBuf#removeComponents</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> CompositeByteBuf <span class="hljs-title">removeComponents</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cIndex, <span class="hljs-keyword">int</span> numComponents)</span> </span>&#123;<br>    <span class="hljs-comment">// 校验要移除位置的索引</span><br>    checkComponentIndex(cIndex, numComponents);<br><br>    <span class="hljs-keyword">if</span> (numComponents == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-comment">//计算移除的范围索引</span><br>    <span class="hljs-keyword">int</span> endIndex = cIndex + numComponents;<br>    <span class="hljs-keyword">boolean</span> needsUpdate = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = cIndex; i &lt; endIndex; ++i) &#123;<br>        <span class="hljs-comment">// 循环遍历要移除的component进行释放。</span><br>        <span class="hljs-comment">// 如果遍历的component的长度大0，则表明要需要更新数组偏移量。</span><br>        Component c = components[i];<br>        <span class="hljs-keyword">if</span> (c.length() &gt; <span class="hljs-number">0</span>) &#123;<br>            needsUpdate = <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (lastAccessed == c) &#123;<br>            lastAccessed = <span class="hljs-keyword">null</span>;<br>        &#125;<br>        c.free();<br>    &#125;<br>    <span class="hljs-comment">// 在数组上移除范围内的component</span><br>    removeCompRange(cIndex, endIndex);<br><br>    <span class="hljs-keyword">if</span> (needsUpdate) &#123;<br>        <span class="hljs-comment">// Only need to call updateComponentOffsets if the length was &gt; 0</span><br>        <span class="hljs-comment">// 更新数组中component的offset。</span><br>        updateComponentOffsets(cIndex);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="discardReadComponents-源码剖析"><a href="#discardReadComponents-源码剖析" class="headerlink" title="discardReadComponents() 源码剖析"></a>discardReadComponents() 源码剖析</h3><p>compositeByteBuf的最后还有一个重要的方法<code>discardReadComponents()</code>，即移除已读字节，其方法解读如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.buffer.CompositeByteBuf#discardReadComponents</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> CompositeByteBuf <span class="hljs-title">discardReadComponents</span><span class="hljs-params">()</span> </span>&#123;<br>    ensureAccessible();<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> readerIndex = readerIndex();<br>    <span class="hljs-keyword">if</span> (readerIndex == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Discard everything if (readerIndex = writerIndex = capacity).</span><br>    <span class="hljs-keyword">int</span> writerIndex = writerIndex();<br>    <span class="hljs-comment">// 如果当前读索引等于当前写索引并且写索引等于当前容量，这说明当前容量已经用完。</span><br>    <span class="hljs-comment">// 全部释放即可</span><br>    <span class="hljs-keyword">if</span> (readerIndex == writerIndex &amp;&amp; writerIndex == capacity()) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, size = componentCount; i &lt; size; i++) &#123;<br>            components[i].free();<br>        &#125;<br>        lastAccessed = <span class="hljs-keyword">null</span>;<br>        clearComps();<br>        setIndex(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        adjustMarkers(readerIndex);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Remove read components.</span><br>    <span class="hljs-keyword">int</span> firstComponentId = <span class="hljs-number">0</span>;<br>    Component c = <span class="hljs-keyword">null</span>;<br>   	<span class="hljs-comment">// 从数组第一个元素开始遍历。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> size = componentCount; firstComponentId &lt; size; firstComponentId++) &#123;<br>        c = components[firstComponentId];<br>        <span class="hljs-comment">// 如果endOffset &gt; readIndex, 则说明当前ByteBuf中还有数据没未读完，</span><br>        <span class="hljs-comment">// 直接跳过，否则直接进行释放。</span><br>        <span class="hljs-keyword">if</span> (c.endOffset &gt; readerIndex) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        c.free();<br>    &#125;<br>    <span class="hljs-comment">//一个都没有释放。</span><br>    <span class="hljs-keyword">if</span> (firstComponentId == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; <span class="hljs-comment">// Nothing to discard</span><br>    &#125;<br>    <span class="hljs-comment">// 如果最后一个读取的buffer不为空并且已经全部完成读取直接置空la</span><br>    Component la = lastAccessed;<br>    <span class="hljs-keyword">if</span> (la != <span class="hljs-keyword">null</span> &amp;&amp; la.endOffset &lt;= readerIndex) &#123;<br>        lastAccessed = <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 从数组中移除已释放的元素</span><br>    removeCompRange(<span class="hljs-number">0</span>, firstComponentId);<br>    <span class="hljs-comment">// Update indexes and markers.</span><br>    <span class="hljs-keyword">int</span> offset = c.offset;<br>    <span class="hljs-comment">// 在移除元素后需要重新整理数组中的offset</span><br>    updateComponentOffsets(<span class="hljs-number">0</span>);<br>    setIndex(readerIndex - offset, writerIndex - offset);<br>    <span class="hljs-comment">//更新标记索引</span><br>    adjustMarkers(offset);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="PooledByteBuf-源码剖析"><a href="#PooledByteBuf-源码剖析" class="headerlink" title="PooledByteBuf 源码剖析"></a>PooledByteBuf 源码剖析</h2><p>PooledByteBuf是ByteBuf非常重要的抽象类，这个类继承于<code>AbstractReferenceCountedByteBuf</code>，其对象主要由内存分配器PoolByteBufAllocator创建。比较常见的实现类有两种：一种是基于对外直接内存池构建的PoolDirectByteBuf，是Netty在进行IO读写的时的内存分配的默认方式，堆外直接内存可以减少内存数据拷贝次数；另一种是基于堆内内存池构建的PoolHeapByteBuf。这里我们简单分析PooledByteBuf，池化的ByteBuf涉及到一些Netty的内存的分配管理策略这个我们会在后面的小节中详细分析。</p>
<h3 id="基础结构与属性"><a href="#基础结构与属性" class="headerlink" title="基础结构与属性"></a>基础结构与属性</h3><p>创建<code>PooledByteBuf</code>对象的开销非常大，而且在高并发的情况下，当网络IO进行读写时会创建大量的实例。因此，为了降低系统的开销，Netty对Buffer对象进行了池化，缓存了Buffer对象，使对此类型的Buffer可进行重复利用，<strong>PooledByteBuf是从内存池中分配出来的Buffer，因此他需要包含内存池的相关信息，如内存块Chunk、PooledByteBuf在内存块中的位置及本身所占空间的大小等。</strong>下图描述了<code>PooledByteBuf</code>的核心功能和属性。</p>
<p><img src="https://gitee.com/realDaiwei/img/raw/master/20211219152022.png" srcset="/img/loading.gif"></p>
<blockquote>
<p>如果对于这块的内存池的部分感到陌生不知所措，不必感到沮丧。后面我们会对Netty的池化内存管理进行分析，完成那部分的梳理，对于这里的各个属性字段也就熟悉了。</p>
</blockquote>
<h3 id="初始化与从Channel中读写数据"><a href="#初始化与从Channel中读写数据" class="headerlink" title="初始化与从Channel中读写数据"></a>初始化与从Channel中读写数据</h3><p>以下是PooledByteBuf的初始化方法解读，这个初始化的过程很简单，前面我们也提到了PooledByteBuf是从内存池中分配出来的Buffer。因此需要记录当前ByteBuf是属于那块chunk，哪部分缓存空间。因此这下面会带有<code>chunk</code>、<code>memory</code>、<code>handler</code>等属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.buffer.PooledByteBuf#init0</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init0</span><span class="hljs-params">(PoolChunk&lt;T&gt; chunk, ByteBuffer nioBuffer,</span></span><br><span class="hljs-function"><span class="hljs-params">                   <span class="hljs-keyword">long</span> handle, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> length, <span class="hljs-keyword">int</span> maxLength, PoolThreadCache cache)</span> </span>&#123;<br>    <span class="hljs-keyword">assert</span> handle &gt;= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">assert</span> chunk != <span class="hljs-keyword">null</span>;<br>	<span class="hljs-comment">// 大块内存默认为16MB，被分配给多个PooledByteBuf</span><br>    <span class="hljs-keyword">this</span>.chunk = chunk;<br>    <span class="hljs-comment">// chunk中具体的缓存空间</span><br>    memory = chunk.memory;<br>    <span class="hljs-comment">// 将PooledByteBuf 转换成 ByteBuffer</span><br>    tmpNioBuf = nioBuffer;<br>    <span class="hljs-comment">// 内存分配器：PooledByteBuf 是由Arena 的分配器构建的。</span><br>    allocator = chunk.arena.parent;<br>    <span class="hljs-comment">// 线程缓存：优先从线程缓存中获取</span><br>    <span class="hljs-keyword">this</span>.cache = cache;<br>    <span class="hljs-comment">// 通过这个指针可以得到 PooledByteBuffer在 chunk 这颗二叉树中的具体位置</span><br>    <span class="hljs-keyword">this</span>.handle = handle;<br>    <span class="hljs-comment">// 偏移量</span><br>    <span class="hljs-keyword">this</span>.offset = offset;<br>    <span class="hljs-comment">// 实际具体长度</span><br>    <span class="hljs-keyword">this</span>.length = length;<br>    <span class="hljs-comment">// 写指针不能超过PooledByteBuf的最大可用长度</span><br>    <span class="hljs-keyword">this</span>.maxLength = maxLength;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从Channel中写数据的解读剖析如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * channel从PooledByteBuf中获取数据，及将数据写入到channel中</span><br><span class="hljs-comment"> * PooledByteBuf的读索引的变化</span><br><span class="hljs-comment"> * 由父类 AbstractByteBuf的readBytes()方法维护</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//io.netty.buffer.PooledByteBuf#getBytes(int, java.nio.channels.GatheringByteChannel, int)</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getBytes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, GatheringByteChannel out, <span class="hljs-keyword">int</span> length)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">return</span> out.write(duplicateInternalNioBuffer(index, length));<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 从memory中创建一份缓存 ByteBuffer</span><br><span class="hljs-comment"> * 与memory共享底层数据，但读写索引独立维护</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//io.netty.buffer.PooledByteBuf#duplicateInternalNioBuffer</span><br><span class="hljs-function">ByteBuffer <span class="hljs-title">duplicateInternalNioBuffer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>    <span class="hljs-comment">// 校验检查</span><br>    checkIndex(index, length);<br>    <span class="hljs-comment">//这里传入的是true，就是要构建memory的bytebuf</span><br>    <span class="hljs-keyword">return</span> _internalNioBuffer(index, length, <span class="hljs-keyword">true</span>);<br>&#125;<br><br><span class="hljs-comment">//io.netty.buffer.PooledByteBuf#_internalNioBuffer</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> ByteBuffer <span class="hljs-title">_internalNioBuffer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> length, <span class="hljs-keyword">boolean</span> duplicate)</span> </span>&#123;<br>    <span class="hljs-comment">// 获取索引</span><br>    index = idx(index);<br>    <span class="hljs-comment">// 当duplicate为true时，在memory中创建共享此缓冲区内从的新的字节缓冲区</span><br>    <span class="hljs-comment">// 当duplicate为false时，先从tmpNioBuf中获取，当tmpNioBuf为空时</span><br>    <span class="hljs-comment">// 再次newInternalNioBuffer，此处与memory的类型有关，因此具体实现由子类完成。</span><br>    ByteBuffer buffer = duplicate ? newInternalNioBuffer(memory) : internalNioBuffer();<br>    buffer.limit(index + length).position(index);<br>    <span class="hljs-keyword">return</span> buffer;<br>&#125;<br><br><span class="hljs-comment">//io.netty.buffer.PooledByteBuf#internalNioBuffer()</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> ByteBuffer <span class="hljs-title">internalNioBuffer</span><span class="hljs-params">()</span> </span>&#123;<br>    ByteBuffer tmpNioBuf = <span class="hljs-keyword">this</span>.tmpNioBuf;<br>    <span class="hljs-keyword">if</span> (tmpNioBuf == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">this</span>.tmpNioBuf = tmpNioBuf = newInternalNioBuffer(memory);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        tmpNioBuf.clear();<br>    &#125;<br>    <span class="hljs-keyword">return</span> tmpNioBuf;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>往Channel中读入数据的解读如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.buffer.PooledByteBuf#setBytes(int, java.nio.channels.ScatteringByteChannel, int)</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">setBytes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, ScatteringByteChannel in, <span class="hljs-keyword">int</span> length)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        构建空的缓冲区，将数据读入<br>        <span class="hljs-keyword">return</span> in.read(internalNioBuffer(index, length));<br>    &#125; <span class="hljs-keyword">catch</span> (ClosedChannelException ignored) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//io.netty.buffer.PooledByteBuf#duplicateInternalNioBuffer</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ByteBuffer <span class="hljs-title">internalNioBuffer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>    checkIndex(index, length);<br>    <span class="hljs-comment">// 这里传入的false，即当tmpNioBuf为空的时候构建新的buffer</span><br>    <span class="hljs-keyword">return</span> _internalNioBuffer(index, length, <span class="hljs-keyword">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="自动扩容与代码对象回收"><a href="#自动扩容与代码对象回收" class="headerlink" title="自动扩容与代码对象回收"></a>自动扩容与代码对象回收</h3><p>有容量上线就会涉及到有容量就会有扩容操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自动扩容</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//io.netty.buffer.PooledByteBuf#capacity(int)</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ByteBuf <span class="hljs-title">capacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newCapacity)</span> </span>&#123;<br>    <span class="hljs-comment">// 若新的容量值与长度相等，则无需扩容，直接返回即可。</span><br>    <span class="hljs-keyword">if</span> (newCapacity == length) &#123;<br>        ensureAccessible();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-comment">// 检查新的容量值是否大于最大允许容量。</span><br>    checkNewCapacity(newCapacity);<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 非内存池，在新容量值小于最大长度值的情况下，无需重新分配</span><br><span class="hljs-comment">     * 只需修改索引和数据长度即可</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (!chunk.unpooled) &#123;<br>        <span class="hljs-comment">// If the request capacity does not require reallocation, just update the length of the memory.</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 新的容量值大于长度值</span><br><span class="hljs-comment">         * 在没有超过 Buffer 的最大长度值时，只需把长度设为新的容量值即可</span><br><span class="hljs-comment">         * 若超过了最大可用长度值，则可能重新分配</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (newCapacity &gt; length) &#123;<br>            <span class="hljs-keyword">if</span> (newCapacity &lt;= maxLength) &#123;<br>                length = newCapacity;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newCapacity &gt; maxLength &gt;&gt;&gt; <span class="hljs-number">1</span> &amp;&amp;<br>                   (maxLength &gt; <span class="hljs-number">512</span> || newCapacity &gt; maxLength - <span class="hljs-number">16</span>)) &#123;<br>            <span class="hljs-comment">//当新容量值小于大于最大可用长度值时，其读/写索引不能超过新容量值。</span><br>            <span class="hljs-comment">// here newCapacity &lt; length</span><br>            length = newCapacity;<br>            trimIndicesToCapacity(newCapacity);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// Reallocation required.</span><br>    <span class="hljs-comment">// 由Arena重新分配内存分配并释放旧的内存</span><br>    chunk.arena.reallocate(<span class="hljs-keyword">this</span>, newCapacity, <span class="hljs-keyword">true</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>PooledByteBuf 对象回收代码解读如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 对象回收，把对象属性清空</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//io.netty.buffer.PooledByteBuf#deallocate</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (handle &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> handle = <span class="hljs-keyword">this</span>.handle;<br>        <span class="hljs-keyword">this</span>.handle = -<span class="hljs-number">1</span>;<br>        memory = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">// 释放内存</span><br>        chunk.arena.free(chunk, tmpNioBuf, handle, maxLength, cache);<br>        tmpNioBuf = <span class="hljs-keyword">null</span>;<br>        chunk = <span class="hljs-keyword">null</span>;<br>        recycle();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 把PooledByteBuf 放回对象池Stack中，以便下次使用</span><br><span class="hljs-comment">//io.netty.buffer.PooledByteBuf#recycle</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recycle</span><span class="hljs-params">()</span> </span>&#123;<br>    recyclerHandle.recycle(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这一小节我们梳理了ByteBuf，开篇我们快速回顾了ByteBuffer，介绍了了ByteBuf的实例方法和一些常用方法。随后我们梳理了Netty中ByteBuf的子类，我们介绍了<code>AbstractByteBuf</code>、<code>AbstractReferenceCountedByteBuf</code>、<code>ReferenceCountUpdater</code>基于引用计数的ByteBuf的实现，通过引用计数来管理，ByteBuf的申请与释放。随后我们介绍了<code>PooledByteBuf</code>。它继承于<code>AbstractReferenceCountedByteBuf</code>，基于引用计数，对内存资源进行池化管理，避免重复的申请和释放带来的资源消耗。中间我们还用了比较大的篇幅去介绍了<code>CompositeByteBuf</code>，它通过把多个ByteBuf组合起来，然后通过把ByteBuf封装成一个个component组成的components数组来管理操作多个ByteBuf。随后我们梳理剖析了它的 add、remove和discard等方法。下一小节开始我们结合这一小节和前面几个小结梳理的Netty核心组件，来看看Netty的读写流程是怎么样。</p>
<h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><ul>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xialong_927/article/details/81044759">JAVA NIO缓冲区(Buffer)-ByteBuffer常用方法详解</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://book.douban.com/subject/35246428/">Netty源码剖析与应用</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wangwei19871103/article/details/104486129">吃透Netty源码系列三十五之CompositeByteBuf详解一</a></p>
</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/NIO%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">NIO与网络编程</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Java%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84%E6%A2%B3%E7%90%86/">Java知识结构梳理</a>
                    
                      <a class="hover-with-bg" href="/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">学习总结</a>
                    
                      <a class="hover-with-bg" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
                    
                      <a class="hover-with-bg" href="/tags/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">源码剖析</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/11/05/netty-source-code-channel/">
                        <span class="hidden-mobile">Netty核心组件源码剖析 — Channel</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
